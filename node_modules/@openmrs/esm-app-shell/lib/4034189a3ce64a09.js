"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_openmrs_esm_app_shell"] = self["webpackChunk_openmrs_esm_app_shell"] || []).push([["vendors-node_modules_single-spa_lib_es2015_esm_single-spa_dev_js"],{

/***/ "../../../node_modules/single-spa/lib/es2015/esm/single-spa.dev.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/single-spa/lib/es2015/esm/single-spa.dev.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BOOTSTRAPPING: () => (/* binding */ BOOTSTRAPPING),\n/* harmony export */   LOADING_SOURCE_CODE: () => (/* binding */ LOADING_SOURCE_CODE),\n/* harmony export */   LOAD_ERROR: () => (/* binding */ LOAD_ERROR),\n/* harmony export */   MOUNTED: () => (/* binding */ MOUNTED),\n/* harmony export */   MOUNTING: () => (/* binding */ MOUNTING),\n/* harmony export */   NOT_BOOTSTRAPPED: () => (/* binding */ NOT_BOOTSTRAPPED),\n/* harmony export */   NOT_LOADED: () => (/* binding */ NOT_LOADED),\n/* harmony export */   NOT_MOUNTED: () => (/* binding */ NOT_MOUNTED),\n/* harmony export */   SKIP_BECAUSE_BROKEN: () => (/* binding */ SKIP_BECAUSE_BROKEN),\n/* harmony export */   UNLOADING: () => (/* binding */ UNLOADING),\n/* harmony export */   UNMOUNTING: () => (/* binding */ UNMOUNTING),\n/* harmony export */   UPDATING: () => (/* binding */ UPDATING),\n/* harmony export */   addErrorHandler: () => (/* binding */ addErrorHandler),\n/* harmony export */   checkActivityFunctions: () => (/* binding */ checkActivityFunctions),\n/* harmony export */   ensureJQuerySupport: () => (/* binding */ ensureJQuerySupport),\n/* harmony export */   getAppNames: () => (/* binding */ getAppNames),\n/* harmony export */   getAppStatus: () => (/* binding */ getAppStatus),\n/* harmony export */   getMountedApps: () => (/* binding */ getMountedApps),\n/* harmony export */   getProfilerData: () => (/* binding */ getProfilerData),\n/* harmony export */   mountRootParcel: () => (/* binding */ mountRootParcel),\n/* harmony export */   navigateToUrl: () => (/* binding */ navigateToUrl),\n/* harmony export */   patchHistoryApi: () => (/* binding */ patchHistoryApi),\n/* harmony export */   pathToActiveWhen: () => (/* binding */ pathToActiveWhen),\n/* harmony export */   registerApplication: () => (/* binding */ registerApplication),\n/* harmony export */   removeErrorHandler: () => (/* binding */ removeErrorHandler),\n/* harmony export */   setBootstrapMaxTime: () => (/* binding */ setBootstrapMaxTime),\n/* harmony export */   setMountMaxTime: () => (/* binding */ setMountMaxTime),\n/* harmony export */   setUnloadMaxTime: () => (/* binding */ setUnloadMaxTime),\n/* harmony export */   setUnmountMaxTime: () => (/* binding */ setUnmountMaxTime),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   triggerAppChange: () => (/* binding */ triggerAppChange),\n/* harmony export */   unloadApplication: () => (/* binding */ unloadApplication),\n/* harmony export */   unregisterApplication: () => (/* binding */ unregisterApplication)\n/* harmony export */ });\n/* single-spa@6.0.3 - ES2015 - dev */ function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar singleSpa = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    get start () {\n        return start;\n    },\n    get ensureJQuerySupport () {\n        return ensureJQuerySupport;\n    },\n    get setBootstrapMaxTime () {\n        return setBootstrapMaxTime;\n    },\n    get setMountMaxTime () {\n        return setMountMaxTime;\n    },\n    get setUnmountMaxTime () {\n        return setUnmountMaxTime;\n    },\n    get setUnloadMaxTime () {\n        return setUnloadMaxTime;\n    },\n    get registerApplication () {\n        return registerApplication;\n    },\n    get unregisterApplication () {\n        return unregisterApplication;\n    },\n    get getMountedApps () {\n        return getMountedApps;\n    },\n    get getAppStatus () {\n        return getAppStatus;\n    },\n    get unloadApplication () {\n        return unloadApplication;\n    },\n    get checkActivityFunctions () {\n        return checkActivityFunctions;\n    },\n    get getAppNames () {\n        return getAppNames;\n    },\n    get pathToActiveWhen () {\n        return pathToActiveWhen;\n    },\n    get navigateToUrl () {\n        return navigateToUrl;\n    },\n    get patchHistoryApi () {\n        return patchHistoryApi;\n    },\n    get triggerAppChange () {\n        return triggerAppChange;\n    },\n    get addErrorHandler () {\n        return addErrorHandler;\n    },\n    get removeErrorHandler () {\n        return removeErrorHandler;\n    },\n    get mountRootParcel () {\n        return mountRootParcel;\n    },\n    get NOT_LOADED () {\n        return NOT_LOADED;\n    },\n    get LOADING_SOURCE_CODE () {\n        return LOADING_SOURCE_CODE;\n    },\n    get NOT_BOOTSTRAPPED () {\n        return NOT_BOOTSTRAPPED;\n    },\n    get BOOTSTRAPPING () {\n        return BOOTSTRAPPING;\n    },\n    get NOT_MOUNTED () {\n        return NOT_MOUNTED;\n    },\n    get MOUNTING () {\n        return MOUNTING;\n    },\n    get UPDATING () {\n        return UPDATING;\n    },\n    get LOAD_ERROR () {\n        return LOAD_ERROR;\n    },\n    get MOUNTED () {\n        return MOUNTED;\n    },\n    get UNLOADING () {\n        return UNLOADING;\n    },\n    get UNMOUNTING () {\n        return UNMOUNTING;\n    },\n    get SKIP_BECAUSE_BROKEN () {\n        return SKIP_BECAUSE_BROKEN;\n    }\n});\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nvar NativeCustomEvent = commonjsGlobal.CustomEvent;\nfunction useNative() {\n    try {\n        var p = new NativeCustomEvent('cat', {\n            detail: {\n                foo: 'bar'\n            }\n        });\n        return 'cat' === p.type && 'bar' === p.detail.foo;\n    } catch (e) {}\n    return false;\n}\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */ var customEvent = useNative() ? NativeCustomEvent : // IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent(type, params) {\n    var e = document.createEvent('CustomEvent');\n    if (params) {\n        e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n    } else {\n        e.initCustomEvent(type, false, false, void 0);\n    }\n    return e;\n} : // IE <= 8\nfunction CustomEvent(type, params) {\n    var e = document.createEventObject();\n    e.type = type;\n    if (params) {\n        e.bubbles = Boolean(params.bubbles);\n        e.cancelable = Boolean(params.cancelable);\n        e.detail = params.detail;\n    } else {\n        e.bubbles = false;\n        e.cancelable = false;\n        e.detail = void 0;\n    }\n    return e;\n};\nvar errorHandlers = [];\nfunction handleAppError(err, app, newStatus) {\n    var transformedErr = transformErr(err, app, newStatus);\n    if (errorHandlers.length) {\n        errorHandlers.forEach(function(handler) {\n            return handler(transformedErr);\n        });\n    } else {\n        setTimeout(function() {\n            throw transformedErr;\n        });\n    }\n}\nfunction addErrorHandler(handler) {\n    if (typeof handler !== \"function\") {\n        throw Error(formatErrorMessage(28, \"a single-spa error handler must be a function\"));\n    }\n    errorHandlers.push(handler);\n}\nfunction removeErrorHandler(handler) {\n    if (typeof handler !== \"function\") {\n        throw Error(formatErrorMessage(29, \"a single-spa error handler must be a function\"));\n    }\n    var removedSomething = false;\n    errorHandlers = errorHandlers.filter(function(h) {\n        var isHandler = h === handler;\n        removedSomething = removedSomething || isHandler;\n        return !isHandler;\n    });\n    return removedSomething;\n}\nfunction formatErrorMessage(code, msg) {\n    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        args[_key - 2] = arguments[_key];\n    }\n    return \"single-spa minified message #\".concat(code, \": \").concat(msg ? msg + \" \" : \"\", \"See https://single-spa.js.org/error/?code=\").concat(code).concat(args.length ? \"&arg=\".concat(args.join(\"&arg=\")) : \"\");\n}\nfunction transformErr(ogErr, appOrParcel, newStatus) {\n    var errPrefix = \"\".concat(objectType(appOrParcel), \" '\").concat(toName(appOrParcel), \"' died in status \").concat(appOrParcel.status, \": \");\n    var result;\n    if (_instanceof(ogErr, Error)) {\n        try {\n            ogErr.message = errPrefix + ogErr.message;\n        } catch (err) {\n        /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */ }\n        result = ogErr;\n    } else {\n        console.warn(formatErrorMessage(30, \"While \".concat(appOrParcel.status, \", '\").concat(toName(appOrParcel), \"' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.\"), appOrParcel.status, toName(appOrParcel)));\n        try {\n            result = Error(errPrefix + JSON.stringify(ogErr));\n        } catch (err) {\n            // If it's not an Error and you can't stringify it, then what else can you even do to it?\n            result = ogErr;\n        }\n    }\n    result.appOrParcelName = toName(appOrParcel); // We set the status after transforming the error so that the error message\n    // references the state the application was in before the status change.\n    appOrParcel.status = newStatus;\n    return result;\n}\nvar NOT_LOADED = \"NOT_LOADED\";\nvar LOADING_SOURCE_CODE = \"LOADING_SOURCE_CODE\";\nvar NOT_BOOTSTRAPPED = \"NOT_BOOTSTRAPPED\";\nvar BOOTSTRAPPING = \"BOOTSTRAPPING\";\nvar NOT_MOUNTED = \"NOT_MOUNTED\";\nvar MOUNTING = \"MOUNTING\";\nvar MOUNTED = \"MOUNTED\";\nvar UPDATING = \"UPDATING\";\nvar UNMOUNTING = \"UNMOUNTING\";\nvar UNLOADING = \"UNLOADING\";\nvar LOAD_ERROR = \"LOAD_ERROR\";\nvar SKIP_BECAUSE_BROKEN = \"SKIP_BECAUSE_BROKEN\";\nfunction isActive(app) {\n    return app.status === MOUNTED;\n}\nfunction shouldBeActive(app) {\n    try {\n        return app.activeWhen(window.location);\n    } catch (err) {\n        handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n        return false;\n    }\n}\nfunction toName(app) {\n    return app.name;\n}\nfunction isParcel(appOrParcel) {\n    return Boolean(appOrParcel.unmountThisParcel);\n}\nfunction objectType(appOrParcel) {\n    return isParcel(appOrParcel) ? \"parcel\" : \"application\";\n}\n// Object.assign() is not available in IE11. And the babel compiled output for object spread\n// syntax checks a bunch of Symbol stuff and is almost a kb. So this function is the smaller replacement.\nfunction assign() {\n    for(var i = arguments.length - 1; i > 0; i--){\n        for(var key in arguments[i]){\n            if (key === \"__proto__\") {\n                continue;\n            }\n            arguments[i - 1][key] = arguments[i][key];\n        }\n    }\n    return arguments[0];\n}\n/* the array.prototype.find polyfill on npmjs.com is ~20kb (not worth it)\n * and lodash is ~200kb (not worth it)\n */ function find(arr, func) {\n    for(var i = 0; i < arr.length; i++){\n        if (func(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\nfunction validLifecycleFn(fn) {\n    return fn && (typeof fn === \"function\" || isArrayOfFns(fn));\n    function isArrayOfFns(arr) {\n        return Array.isArray(arr) && !find(arr, function(item) {\n            return typeof item !== \"function\";\n        });\n    }\n}\nfunction flattenFnArray(appOrParcel, lifecycle) {\n    var fns = appOrParcel[lifecycle] || [];\n    fns = Array.isArray(fns) ? fns : [\n        fns\n    ];\n    if (fns.length === 0) {\n        fns = [\n            function() {\n                return Promise.resolve();\n            }\n        ];\n    }\n    var type = objectType(appOrParcel);\n    var name = toName(appOrParcel);\n    return function(props) {\n        return fns.reduce(function(resultPromise, fn, index) {\n            return resultPromise.then(function() {\n                var thisPromise = fn(props);\n                return smellsLikeAPromise(thisPromise) ? thisPromise : Promise.reject(formatErrorMessage(15, \"Within \".concat(type, \" \").concat(name, \", the lifecycle function \").concat(lifecycle, \" at array index \").concat(index, \" did not return a promise\"), type, name, lifecycle, index));\n            });\n        }, Promise.resolve());\n    };\n}\nfunction smellsLikeAPromise(promise) {\n    return promise && typeof promise.then === \"function\" && typeof promise.catch === \"function\";\n}\nvar profileEntries = [];\nfunction getProfilerData() {\n    return profileEntries;\n}\n/**\n *\n * @type {'application' | 'parcel' | 'routing'} ProfileType\n *\n * @param {ProfileType} type\n * @param {String} name\n * @param {number} start\n * @param {number} end\n */ function addProfileEntry(type, name, kind, start, end, operationSucceeded) {\n    profileEntries.push({\n        type: type,\n        name: name,\n        start: start,\n        end: end,\n        kind: kind,\n        operationSucceeded: operationSucceeded\n    });\n}\nfunction toBootstrapPromise(appOrParcel, hardFail) {\n    var startTime, profileEventType;\n    return Promise.resolve().then(function() {\n        if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n            return appOrParcel;\n        }\n        {\n            profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n            startTime = performance.now();\n        }\n        appOrParcel.status = BOOTSTRAPPING;\n        if (!appOrParcel.bootstrap) {\n            // Default implementation of bootstrap\n            return Promise.resolve().then(successfulBootstrap);\n        }\n        return reasonableTime(appOrParcel, \"bootstrap\").then(successfulBootstrap).catch(function(err) {\n            {\n                addProfileEntry(profileEventType, toName(appOrParcel), \"bootstrap\", startTime, performance.now(), false);\n            }\n            if (hardFail) {\n                throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n            } else {\n                handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n                return appOrParcel;\n            }\n        });\n    });\n    function successfulBootstrap() {\n        appOrParcel.status = NOT_MOUNTED;\n        {\n            addProfileEntry(profileEventType, toName(appOrParcel), \"bootstrap\", startTime, performance.now(), true);\n        }\n        return appOrParcel;\n    }\n}\nfunction toUnmountPromise(appOrParcel, hardFail) {\n    return Promise.resolve().then(function() {\n        var unmountAppOrParcel = function unmountAppOrParcel() {\n            // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n            return reasonableTime(appOrParcel, \"unmount\").then(function() {\n                // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n                {\n                    appOrParcel.status = NOT_MOUNTED;\n                }\n                {\n                    addProfileEntry(profileEventType, toName(appOrParcel), \"unmount\", startTime, performance.now(), true);\n                }\n            }, function(err) {\n                {\n                    addProfileEntry(profileEventType, toName(appOrParcel), \"unmount\", startTime, performance.now(), false);\n                }\n                if (hardFail) {\n                    throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n                } else {\n                    handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n                }\n            });\n        };\n        if (appOrParcel.status !== MOUNTED) {\n            return appOrParcel;\n        }\n        var startTime, profileEventType;\n        {\n            startTime = performance.now();\n            profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n        }\n        appOrParcel.status = UNMOUNTING;\n        var unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(function(parcelId) {\n            return appOrParcel.parcels[parcelId].unmountThisParcel();\n        });\n        return Promise.all(unmountChildrenParcels).then(unmountAppOrParcel, function(parcelError) {\n            // There is a parcel unmount error\n            return unmountAppOrParcel().then(function() {\n                // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n                var parentError = Error(parcelError.message);\n                if (hardFail) {\n                    throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n                } else {\n                    handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n                }\n            });\n        }).then(function() {\n            return appOrParcel;\n        });\n    });\n}\nvar beforeFirstMountFired = false;\nvar firstMountFired = false;\nfunction toMountPromise(appOrParcel, hardFail) {\n    return Promise.resolve().then(function() {\n        if (appOrParcel.status !== NOT_MOUNTED) {\n            return appOrParcel;\n        }\n        var startTime, profileEventType;\n        {\n            profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n            startTime = performance.now();\n        }\n        if (!beforeFirstMountFired) {\n            window.dispatchEvent(new customEvent(\"single-spa:before-first-mount\"));\n            beforeFirstMountFired = true;\n        }\n        appOrParcel.status = MOUNTING;\n        return reasonableTime(appOrParcel, \"mount\").then(function() {\n            appOrParcel.status = MOUNTED;\n            if (!firstMountFired) {\n                window.dispatchEvent(new customEvent(\"single-spa:first-mount\"));\n                firstMountFired = true;\n            }\n            {\n                addProfileEntry(profileEventType, toName(appOrParcel), \"mount\", startTime, performance.now(), true);\n            }\n            return appOrParcel;\n        }).catch(function(err) {\n            var setSkipBecauseBroken = function setSkipBecauseBroken() {\n                {\n                    addProfileEntry(profileEventType, toName(appOrParcel), \"mount\", startTime, performance.now(), false);\n                }\n                if (!hardFail) {\n                    handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n                    return appOrParcel;\n                } else {\n                    throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n                }\n            };\n            // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n            // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n            // instead of just doing a no-op.\n            appOrParcel.status = MOUNTED;\n            return toUnmountPromise(appOrParcel, true).then(setSkipBecauseBroken, setSkipBecauseBroken);\n        });\n    });\n}\nfunction toUpdatePromise(appOrParcel) {\n    return Promise.resolve().then(function() {\n        var startTime, profileEventType;\n        {\n            profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n            startTime = performance.now();\n        }\n        if (appOrParcel.status !== MOUNTED) {\n            throw Error(formatErrorMessage(32, \"Cannot update parcel '\".concat(toName(appOrParcel), \"' because it is not mounted\"), toName(appOrParcel)));\n        }\n        appOrParcel.status = UPDATING;\n        return reasonableTime(appOrParcel, \"update\").then(function() {\n            appOrParcel.status = MOUNTED;\n            {\n                addProfileEntry(profileEventType, toName(appOrParcel), \"update\", startTime, performance.now(), true);\n            }\n            return appOrParcel;\n        }).catch(function(err) {\n            {\n                addProfileEntry(profileEventType, toName(appOrParcel), \"update\", startTime, performance.now(), false);\n            }\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        });\n    });\n}\nvar parcelCount = 0;\nvar rootParcels = {\n    parcels: {}\n}; // This is a public api, exported to users of single-spa\nfunction mountRootParcel() {\n    return mountParcel.apply(rootParcels, arguments);\n}\nfunction mountParcel(config, customProps) {\n    var owningAppOrParcel = this; // Validate inputs\n    if (!config || (typeof config === \"undefined\" ? \"undefined\" : _type_of(config)) !== \"object\" && typeof config !== \"function\") {\n        throw Error(formatErrorMessage(2, \"Cannot mount parcel without a config object or config loading function\"));\n    }\n    if (config.name && typeof config.name !== \"string\") {\n        throw Error(formatErrorMessage(3, \"Parcel name must be a string, if provided. Was given \".concat(_type_of(config.name)), _type_of(config.name)));\n    }\n    var id = parcelCount++;\n    var name = config.name || \"parcel-\".concat(id);\n    if ((typeof customProps === \"undefined\" ? \"undefined\" : _type_of(customProps)) !== \"object\") {\n        throw Error(formatErrorMessage(4, \"Parcel \".concat(name, \" has invalid customProps -- must be an object but was given \").concat(typeof customProps === \"undefined\" ? \"undefined\" : _type_of(customProps)), name, typeof customProps === \"undefined\" ? \"undefined\" : _type_of(customProps)));\n    }\n    if (!customProps.domElement) {\n        throw Error(formatErrorMessage(5, \"Parcel \".concat(name, \" cannot be mounted without a domElement provided as a prop\"), name));\n    }\n    var passedConfigLoadingFunction = typeof config === \"function\";\n    var configLoadingFunction = passedConfigLoadingFunction ? config : function() {\n        return Promise.resolve(config);\n    }; // Internal representation\n    var parcel = {\n        id: id,\n        parcels: {},\n        status: passedConfigLoadingFunction ? LOADING_SOURCE_CODE : NOT_BOOTSTRAPPED,\n        customProps: customProps,\n        parentName: toName(owningAppOrParcel),\n        unmountThisParcel: function unmountThisParcel() {\n            return mountPromise.then(function() {\n                if (parcel.status !== MOUNTED) {\n                    throw Error(formatErrorMessage(6, \"Cannot unmount parcel '\".concat(name, \"' -- it is in a \").concat(parcel.status, \" status\"), name, parcel.status));\n                }\n                return toUnmountPromise(parcel, true);\n            }).then(function(value) {\n                if (parcel.parentName) {\n                    delete owningAppOrParcel.parcels[parcel.id];\n                }\n                return value;\n            }).then(function(value) {\n                resolveUnmount(value);\n                return value;\n            }).catch(function(err) {\n                parcel.status = SKIP_BECAUSE_BROKEN;\n                rejectUnmount(err);\n                throw err;\n            });\n        }\n    }; // We return an external representation\n    var externalRepresentation; // Add to owning app or parcel\n    owningAppOrParcel.parcels[id] = parcel;\n    var loadPromise = configLoadingFunction();\n    if (!loadPromise || typeof loadPromise.then !== \"function\") {\n        throw Error(formatErrorMessage(7, \"When mounting a parcel, the config loading function must return a promise that resolves with the parcel config\"));\n    }\n    loadPromise = loadPromise.then(function(config) {\n        if (!config) {\n            throw Error(formatErrorMessage(8, \"When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config\"));\n        }\n        name = config.name || \"parcel-\".concat(id);\n        if (Object.prototype.hasOwnProperty.call(config, \"bootstrap\") && !validLifecycleFn(config.bootstrap)) {\n            throw Error(formatErrorMessage(9, \"Parcel \".concat(name, \" provided an invalid bootstrap function\"), name));\n        }\n        if (!validLifecycleFn(config.mount)) {\n            throw Error(formatErrorMessage(10, \"Parcel \".concat(name, \" must have a valid mount function\"), name));\n        }\n        if (!validLifecycleFn(config.unmount)) {\n            throw Error(formatErrorMessage(11, \"Parcel \".concat(name, \" must have a valid unmount function\"), name));\n        }\n        if (config.update && !validLifecycleFn(config.update)) {\n            throw Error(formatErrorMessage(12, \"Parcel \".concat(name, \" provided an invalid update function\"), name));\n        }\n        var bootstrap = flattenFnArray(config, \"bootstrap\");\n        var mount = flattenFnArray(config, \"mount\");\n        var unmount = flattenFnArray(config, \"unmount\");\n        parcel.status = NOT_BOOTSTRAPPED;\n        parcel.name = name;\n        parcel.bootstrap = bootstrap;\n        parcel.mount = mount;\n        parcel.unmount = unmount;\n        parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n        if (config.update) {\n            parcel.update = flattenFnArray(config, \"update\");\n            externalRepresentation.update = function(customProps) {\n                parcel.customProps = customProps;\n                return promiseWithoutReturnValue(toUpdatePromise(parcel));\n            };\n        }\n    }); // Start bootstrapping and mounting\n    // The .then() causes the work to be put on the event loop instead of happening immediately\n    var bootstrapPromise = loadPromise.then(function() {\n        return toBootstrapPromise(parcel, true);\n    });\n    var mountPromise = bootstrapPromise.then(function() {\n        return toMountPromise(parcel, true);\n    });\n    var resolveUnmount, rejectUnmount;\n    var unmountPromise = new Promise(function(resolve, reject) {\n        resolveUnmount = resolve;\n        rejectUnmount = reject;\n    });\n    externalRepresentation = {\n        mount: function mount() {\n            return promiseWithoutReturnValue(Promise.resolve().then(function() {\n                if (parcel.status !== NOT_MOUNTED) {\n                    throw Error(formatErrorMessage(13, \"Cannot mount parcel '\".concat(name, \"' -- it is in a \").concat(parcel.status, \" status\"), name, parcel.status));\n                } // Add to owning app or parcel\n                owningAppOrParcel.parcels[id] = parcel;\n                return toMountPromise(parcel);\n            }));\n        },\n        unmount: function unmount() {\n            return promiseWithoutReturnValue(parcel.unmountThisParcel());\n        },\n        getStatus: function getStatus() {\n            return parcel.status;\n        },\n        loadPromise: promiseWithoutReturnValue(loadPromise),\n        bootstrapPromise: promiseWithoutReturnValue(bootstrapPromise),\n        mountPromise: promiseWithoutReturnValue(mountPromise),\n        unmountPromise: promiseWithoutReturnValue(unmountPromise)\n    };\n    return externalRepresentation;\n}\nfunction promiseWithoutReturnValue(promise) {\n    return promise.then(function() {\n        return null;\n    });\n}\nfunction getProps(appOrParcel) {\n    var name = toName(appOrParcel);\n    var customProps = typeof appOrParcel.customProps === \"function\" ? appOrParcel.customProps(name, window.location) : appOrParcel.customProps;\n    if ((typeof customProps === \"undefined\" ? \"undefined\" : _type_of(customProps)) !== \"object\" || customProps === null || Array.isArray(customProps)) {\n        customProps = {};\n        console.warn(formatErrorMessage(40, \"single-spa: \".concat(name, \"'s customProps function must return an object. Received \").concat(customProps)), name, customProps);\n    }\n    var result = assign({}, customProps, {\n        name: name,\n        mountParcel: mountParcel.bind(appOrParcel),\n        singleSpa: singleSpa\n    });\n    if (isParcel(appOrParcel)) {\n        result.unmountSelf = appOrParcel.unmountThisParcel;\n    }\n    return result;\n}\nvar defaultWarningMillis = 1000;\nvar globalTimeoutConfig = {\n    bootstrap: {\n        millis: 4000,\n        dieOnTimeout: false,\n        warningMillis: defaultWarningMillis\n    },\n    mount: {\n        millis: 3000,\n        dieOnTimeout: false,\n        warningMillis: defaultWarningMillis\n    },\n    unmount: {\n        millis: 3000,\n        dieOnTimeout: false,\n        warningMillis: defaultWarningMillis\n    },\n    unload: {\n        millis: 3000,\n        dieOnTimeout: false,\n        warningMillis: defaultWarningMillis\n    },\n    update: {\n        millis: 3000,\n        dieOnTimeout: false,\n        warningMillis: defaultWarningMillis\n    }\n};\nfunction setBootstrapMaxTime(time, dieOnTimeout, warningMillis) {\n    if (typeof time !== \"number\" || time <= 0) {\n        throw Error(formatErrorMessage(16, \"bootstrap max time must be a positive integer number of milliseconds\"));\n    }\n    globalTimeoutConfig.bootstrap = {\n        millis: time,\n        dieOnTimeout: dieOnTimeout,\n        warningMillis: warningMillis || defaultWarningMillis\n    };\n}\nfunction setMountMaxTime(time, dieOnTimeout, warningMillis) {\n    if (typeof time !== \"number\" || time <= 0) {\n        throw Error(formatErrorMessage(17, \"mount max time must be a positive integer number of milliseconds\"));\n    }\n    globalTimeoutConfig.mount = {\n        millis: time,\n        dieOnTimeout: dieOnTimeout,\n        warningMillis: warningMillis || defaultWarningMillis\n    };\n}\nfunction setUnmountMaxTime(time, dieOnTimeout, warningMillis) {\n    if (typeof time !== \"number\" || time <= 0) {\n        throw Error(formatErrorMessage(18, \"unmount max time must be a positive integer number of milliseconds\"));\n    }\n    globalTimeoutConfig.unmount = {\n        millis: time,\n        dieOnTimeout: dieOnTimeout,\n        warningMillis: warningMillis || defaultWarningMillis\n    };\n}\nfunction setUnloadMaxTime(time, dieOnTimeout, warningMillis) {\n    if (typeof time !== \"number\" || time <= 0) {\n        throw Error(formatErrorMessage(19, \"unload max time must be a positive integer number of milliseconds\"));\n    }\n    globalTimeoutConfig.unload = {\n        millis: time,\n        dieOnTimeout: dieOnTimeout,\n        warningMillis: warningMillis || defaultWarningMillis\n    };\n}\nfunction reasonableTime(appOrParcel, lifecycle) {\n    var timeoutConfig = appOrParcel.timeouts[lifecycle];\n    var warningPeriod = timeoutConfig.warningMillis;\n    var type = objectType(appOrParcel);\n    return new Promise(function(resolve, reject) {\n        var finished = false;\n        var errored = false;\n        appOrParcel[lifecycle](getProps(appOrParcel)).then(function(val) {\n            finished = true;\n            resolve(val);\n        }).catch(function(val) {\n            finished = true;\n            reject(val);\n        });\n        setTimeout(function() {\n            return maybeTimingOut(1);\n        }, warningPeriod);\n        setTimeout(function() {\n            return maybeTimingOut(true);\n        }, timeoutConfig.millis);\n        var errMsg = formatErrorMessage(31, \"Lifecycle function \".concat(lifecycle, \" for \").concat(type, \" \").concat(toName(appOrParcel), \" lifecycle did not resolve or reject for \").concat(timeoutConfig.millis, \" ms.\"), lifecycle, type, toName(appOrParcel), timeoutConfig.millis);\n        function maybeTimingOut(shouldError) {\n            if (!finished) {\n                if (shouldError === true) {\n                    errored = true;\n                    if (timeoutConfig.dieOnTimeout) {\n                        reject(Error(errMsg));\n                    } else {\n                        console.error(errMsg); //don't resolve or reject, we're waiting this one out\n                    }\n                } else if (!errored) {\n                    var numWarnings = shouldError;\n                    var numMillis = numWarnings * warningPeriod;\n                    console.warn(errMsg);\n                    if (numMillis + warningPeriod < timeoutConfig.millis) {\n                        setTimeout(function() {\n                            return maybeTimingOut(numWarnings + 1);\n                        }, warningPeriod);\n                    }\n                }\n            }\n        }\n    });\n}\nfunction ensureValidAppTimeouts(timeouts) {\n    var result = {};\n    for(var key in globalTimeoutConfig){\n        result[key] = assign({}, globalTimeoutConfig[key], timeouts && timeouts[key] || {});\n    }\n    return result;\n}\nfunction toLoadPromise(appOrParcel) {\n    return Promise.resolve().then(function() {\n        if (appOrParcel.loadPromise) {\n            return appOrParcel.loadPromise;\n        }\n        if (appOrParcel.status !== NOT_LOADED && appOrParcel.status !== LOAD_ERROR) {\n            return appOrParcel;\n        }\n        var startTime;\n        {\n            startTime = performance.now();\n        }\n        appOrParcel.status = LOADING_SOURCE_CODE;\n        var appOpts, isUserErr;\n        return appOrParcel.loadPromise = Promise.resolve().then(function() {\n            var loadPromise = appOrParcel.loadApp(getProps(appOrParcel));\n            if (!smellsLikeAPromise(loadPromise)) {\n                // The name of the app will be prepended to this error message inside of the handleAppError function\n                isUserErr = true;\n                throw Error(formatErrorMessage(33, \"single-spa loading function did not return a promise. Check the second argument to registerApplication('\".concat(toName(appOrParcel), \"', loadingFunction, activityFunction)\"), toName(appOrParcel)));\n            }\n            return loadPromise.then(function(val) {\n                appOrParcel.loadErrorTime = null;\n                appOpts = val;\n                var validationErrMessage, validationErrCode;\n                if ((typeof appOpts === \"undefined\" ? \"undefined\" : _type_of(appOpts)) !== \"object\") {\n                    validationErrCode = 34;\n                    {\n                        validationErrMessage = \"does not export anything\";\n                    }\n                }\n                if (Object.prototype.hasOwnProperty.call(appOpts, \"bootstrap\") && !validLifecycleFn(appOpts.bootstrap)) {\n                    validationErrCode = 35;\n                    {\n                        validationErrMessage = \"does not export a valid bootstrap function or array of functions\";\n                    }\n                }\n                if (!validLifecycleFn(appOpts.mount)) {\n                    validationErrCode = 36;\n                    {\n                        validationErrMessage = \"does not export a mount function or array of functions\";\n                    }\n                }\n                if (!validLifecycleFn(appOpts.unmount)) {\n                    validationErrCode = 37;\n                    {\n                        validationErrMessage = \"does not export a unmount function or array of functions\";\n                    }\n                }\n                var type = objectType(appOpts);\n                if (validationErrCode) {\n                    var appOptsStr;\n                    try {\n                        appOptsStr = JSON.stringify(appOpts);\n                    } catch (_unused) {}\n                    console.error(formatErrorMessage(validationErrCode, \"The loading function for single-spa \".concat(type, \" '\").concat(toName(appOrParcel), \"' resolved with the following, which does not have bootstrap, mount, and unmount functions\"), type, toName(appOrParcel), appOptsStr), appOpts);\n                    handleAppError(validationErrMessage, appOrParcel, SKIP_BECAUSE_BROKEN);\n                    return appOrParcel;\n                }\n                if (appOpts.devtools && appOpts.devtools.overlays) {\n                    appOrParcel.devtools.overlays = assign({}, appOrParcel.devtools.overlays, appOpts.devtools.overlays);\n                }\n                appOrParcel.status = NOT_BOOTSTRAPPED;\n                appOrParcel.bootstrap = flattenFnArray(appOpts, \"bootstrap\");\n                appOrParcel.mount = flattenFnArray(appOpts, \"mount\");\n                appOrParcel.unmount = flattenFnArray(appOpts, \"unmount\");\n                appOrParcel.unload = flattenFnArray(appOpts, \"unload\");\n                appOrParcel.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n                delete appOrParcel.loadPromise;\n                {\n                    addProfileEntry(\"application\", toName(appOrParcel), \"load\", startTime, performance.now(), true);\n                }\n                return appOrParcel;\n            });\n        }).catch(function(err) {\n            delete appOrParcel.loadPromise;\n            var newStatus;\n            if (isUserErr) {\n                newStatus = SKIP_BECAUSE_BROKEN;\n            } else {\n                newStatus = LOAD_ERROR;\n                appOrParcel.loadErrorTime = new Date().getTime();\n            }\n            handleAppError(err, appOrParcel, newStatus);\n            {\n                addProfileEntry(\"application\", toName(appOrParcel), \"load\", startTime, performance.now(), false);\n            }\n            return appOrParcel;\n        });\n    });\n}\nvar isInBrowser = typeof window !== \"undefined\";\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */ var capturedEventListeners = {\n    hashchange: [],\n    popstate: []\n};\nvar routingEventsListeningTo = [\n    \"hashchange\",\n    \"popstate\"\n];\nfunction navigateToUrl(obj) {\n    var url;\n    if (typeof obj === \"string\") {\n        url = obj;\n    } else if (this && this.href) {\n        url = this.href;\n    } else if (obj && obj.currentTarget && obj.currentTarget.href && obj.preventDefault) {\n        url = obj.currentTarget.href;\n        obj.preventDefault();\n    } else {\n        throw Error(formatErrorMessage(14, \"singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag\"));\n    }\n    var current = parseUri(window.location.href);\n    var destination = parseUri(url);\n    if (url.indexOf(\"#\") === 0) {\n        window.location.hash = destination.hash;\n    } else if (current.host !== destination.host && destination.host) {\n        {\n            window.location.href = url;\n        }\n    } else if (destination.pathname === current.pathname && destination.search === current.search) {\n        window.location.hash = destination.hash;\n    } else {\n        // different path, host, or query params\n        window.history.pushState(null, null, url);\n    }\n}\nfunction callCapturedEventListeners(eventArguments) {\n    var _this = this;\n    if (eventArguments) {\n        var eventType = eventArguments[0].type;\n        if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n            capturedEventListeners[eventType].forEach(function(listener) {\n                try {\n                    // The error thrown by application event listener should not break single-spa down.\n                    // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n                    listener.apply(_this, eventArguments);\n                } catch (e) {\n                    setTimeout(function() {\n                        throw e;\n                    });\n                }\n            });\n        }\n    }\n}\nvar urlRerouteOnly;\nfunction urlReroute() {\n    reroute([], arguments);\n}\nfunction patchedUpdateState(updateState, methodName) {\n    return function() {\n        var urlBefore = window.location.href;\n        var result = updateState.apply(this, arguments);\n        var urlAfter = window.location.href;\n        if (!urlRerouteOnly || urlBefore !== urlAfter) {\n            // fire an artificial popstate event so that\n            // single-spa applications know about routing that\n            // occurs in a different application\n            window.dispatchEvent(createPopStateEvent(window.history.state, methodName));\n        }\n        return result;\n    };\n}\nfunction createPopStateEvent(state, originalMethodName) {\n    // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n    // We need a popstate event even though the browser doesn't do one by default when you call replaceState, so that\n    // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n    // singleSpaTrigger=<pushState|replaceState> on the event instance.\n    var evt;\n    try {\n        evt = new PopStateEvent(\"popstate\", {\n            state: state\n        });\n    } catch (err) {\n        // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299\n        // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n        evt = document.createEvent(\"PopStateEvent\");\n        evt.initPopStateEvent(\"popstate\", false, false, state);\n    }\n    evt.singleSpa = true;\n    evt.singleSpaTrigger = originalMethodName;\n    return evt;\n}\nvar originalReplaceState = null;\nvar historyApiIsPatched = false; // We patch the history API so single-spa is notified of all calls to pushState/replaceState.\n// We patch addEventListener/removeEventListener so we can capture all popstate/hashchange event listeners,\n// and delay calling them until single-spa has finished mounting/unmounting applications\nfunction patchHistoryApi(opts) {\n    if (historyApiIsPatched) {\n        throw Error(formatErrorMessage(43, \"single-spa: patchHistoryApi() was called after the history api was already patched.\"));\n    } // True by default, as a performance optimization that reduces\n    // the number of extraneous popstate events\n    urlRerouteOnly = opts && opts.hasOwnProperty(\"urlRerouteOnly\") ? opts.urlRerouteOnly : true;\n    historyApiIsPatched = true;\n    originalReplaceState = window.history.replaceState; // We will trigger an app change for any routing events.\n    window.addEventListener(\"hashchange\", urlReroute);\n    window.addEventListener(\"popstate\", urlReroute); // Monkeypatch addEventListener so that we can ensure correct timing\n    var originalAddEventListener = window.addEventListener;\n    var originalRemoveEventListener = window.removeEventListener;\n    window.addEventListener = function(eventName, fn) {\n        if (typeof fn === \"function\") {\n            if (routingEventsListeningTo.indexOf(eventName) >= 0 && !find(capturedEventListeners[eventName], function(listener) {\n                return listener === fn;\n            })) {\n                capturedEventListeners[eventName].push(fn);\n                return;\n            }\n        }\n        return originalAddEventListener.apply(this, arguments);\n    };\n    window.removeEventListener = function(eventName, listenerFn) {\n        if (typeof listenerFn === \"function\") {\n            if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n                capturedEventListeners[eventName] = capturedEventListeners[eventName].filter(function(fn) {\n                    return fn !== listenerFn;\n                });\n            }\n        }\n        return originalRemoveEventListener.apply(this, arguments);\n    };\n    window.history.pushState = patchedUpdateState(window.history.pushState, \"pushState\");\n    window.history.replaceState = patchedUpdateState(originalReplaceState, \"replaceState\");\n} // Detect if single-spa has already been loaded on the page.\n// If so, warn because this can result in lots of problems, including\n// lots of extraneous popstate events and unexpected results for\n// apis like getAppNames().\nif (isInBrowser) {\n    if (window.singleSpaNavigate) {\n        console.warn(formatErrorMessage(41, \"single-spa has been loaded twice on the page. This can result in unexpected behavior.\"));\n    } else {\n        /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag's href is.\n     */ window.singleSpaNavigate = navigateToUrl;\n    }\n}\nfunction parseUri(str) {\n    var anchor = document.createElement(\"a\");\n    anchor.href = str;\n    return anchor;\n}\nvar hasInitialized = false;\nfunction ensureJQuerySupport() {\n    var jQuery = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.jQuery;\n    if (!jQuery) {\n        if (window.$ && window.$.fn && window.$.fn.jquery) {\n            jQuery = window.$;\n        }\n    }\n    if (jQuery && !hasInitialized) {\n        var originalJQueryOn = jQuery.fn.on;\n        var originalJQueryOff = jQuery.fn.off;\n        jQuery.fn.on = function(eventString, fn) {\n            return captureRoutingEvents.call(this, originalJQueryOn, window.addEventListener, eventString, fn, arguments);\n        };\n        jQuery.fn.off = function(eventString, fn) {\n            return captureRoutingEvents.call(this, originalJQueryOff, window.removeEventListener, eventString, fn, arguments);\n        };\n        hasInitialized = true;\n    }\n}\nfunction captureRoutingEvents(originalJQueryFunction, nativeFunctionToCall, eventString, fn, originalArgs) {\n    if (typeof eventString !== \"string\") {\n        return originalJQueryFunction.apply(this, originalArgs);\n    }\n    var eventNames = eventString.split(/\\s+/);\n    eventNames.forEach(function(eventName) {\n        if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n            nativeFunctionToCall(eventName, fn);\n            eventString = eventString.replace(eventName, \"\");\n        }\n    });\n    if (eventString.trim() === \"\") {\n        return this;\n    } else {\n        return originalJQueryFunction.apply(this, originalArgs);\n    }\n}\nvar appsToUnload = {};\nfunction toUnloadPromise(appOrParcel) {\n    return Promise.resolve().then(function() {\n        var unloadInfo = appsToUnload[toName(appOrParcel)];\n        if (!unloadInfo) {\n            /* No one has called unloadApplication for this app,\n       */ return appOrParcel;\n        }\n        if (appOrParcel.status === NOT_LOADED) {\n            /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */ finishUnloadingApp(appOrParcel, unloadInfo);\n            return appOrParcel;\n        }\n        if (appOrParcel.status === UNLOADING) {\n            /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */ return unloadInfo.promise.then(function() {\n                return appOrParcel;\n            });\n        }\n        if (appOrParcel.status !== NOT_MOUNTED && appOrParcel.status !== LOAD_ERROR) {\n            /* The app cannot be unloaded until it is unmounted.\n       */ return appOrParcel;\n        }\n        var startTime;\n        {\n            startTime = performance.now();\n        }\n        var unloadPromise = appOrParcel.status === LOAD_ERROR ? Promise.resolve() : reasonableTime(appOrParcel, \"unload\");\n        appOrParcel.status = UNLOADING;\n        return unloadPromise.then(function() {\n            {\n                addProfileEntry(\"application\", toName(appOrParcel), \"unload\", startTime, performance.now(), true);\n            }\n            finishUnloadingApp(appOrParcel, unloadInfo);\n            return appOrParcel;\n        }).catch(function(err) {\n            {\n                addProfileEntry(\"application\", toName(appOrParcel), \"unload\", startTime, performance.now(), false);\n            }\n            errorUnloadingApp(appOrParcel, unloadInfo, err);\n            return appOrParcel;\n        });\n    });\n}\nfunction finishUnloadingApp(app, unloadInfo) {\n    delete appsToUnload[toName(app)]; // Unloaded apps don't have lifecycles\n    delete app.bootstrap;\n    delete app.mount;\n    delete app.unmount;\n    delete app.unload;\n    app.status = NOT_LOADED;\n    /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */ unloadInfo.resolve();\n}\nfunction errorUnloadingApp(app, unloadInfo, err) {\n    delete appsToUnload[toName(app)]; // Unloaded apps don't have lifecycles\n    delete app.bootstrap;\n    delete app.mount;\n    delete app.unmount;\n    delete app.unload;\n    handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n    unloadInfo.reject(err);\n}\nfunction addAppToUnload(app, promiseGetter, resolve, reject) {\n    appsToUnload[toName(app)] = {\n        app: app,\n        resolve: resolve,\n        reject: reject\n    };\n    Object.defineProperty(appsToUnload[toName(app)], \"promise\", {\n        get: promiseGetter\n    });\n}\nfunction getAppUnloadInfo(appName) {\n    return appsToUnload[appName];\n}\nvar apps = [];\nfunction getAppChanges() {\n    var appsToUnload = [], appsToUnmount = [], appsToLoad = [], appsToMount = []; // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n    var currentTime = new Date().getTime();\n    apps.forEach(function(app) {\n        var appShouldBeActive = app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n        switch(app.status){\n            case LOAD_ERROR:\n                if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n                    appsToLoad.push(app);\n                }\n                break;\n            case NOT_LOADED:\n            case LOADING_SOURCE_CODE:\n                if (appShouldBeActive) {\n                    appsToLoad.push(app);\n                }\n                break;\n            case NOT_BOOTSTRAPPED:\n            case NOT_MOUNTED:\n                if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n                    appsToUnload.push(app);\n                } else if (appShouldBeActive) {\n                    appsToMount.push(app);\n                }\n                break;\n            case MOUNTED:\n                if (!appShouldBeActive) {\n                    appsToUnmount.push(app);\n                }\n                break;\n        }\n    });\n    return {\n        appsToUnload: appsToUnload,\n        appsToUnmount: appsToUnmount,\n        appsToLoad: appsToLoad,\n        appsToMount: appsToMount\n    };\n}\nfunction getMountedApps() {\n    return apps.filter(isActive).map(toName);\n}\nfunction getAppNames() {\n    return apps.map(toName);\n} // used in devtools, not (currently) exposed as a single-spa API\nfunction getRawAppData() {\n    return _to_consumable_array(apps);\n}\nfunction getAppStatus(appName) {\n    var app = find(apps, function(app) {\n        return toName(app) === appName;\n    });\n    return app ? app.status : null;\n}\nvar startWarningInitialized = false;\nfunction registerApplication(appNameOrConfig, appOrLoadApp, activeWhen, customProps) {\n    var registration = sanitizeArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps);\n    if (!isStarted() && !startWarningInitialized) {\n        startWarningInitialized = true;\n        setTimeout(function() {\n            if (!isStarted()) {\n                console.warn(formatErrorMessage(1, \"singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted.\"));\n            }\n        }, 5000);\n    }\n    if (getAppNames().indexOf(registration.name) !== -1) throw Error(formatErrorMessage(21, \"There is already an app registered with name \".concat(registration.name), registration.name));\n    apps.push(assign({\n        loadErrorTime: null,\n        status: NOT_LOADED,\n        parcels: {},\n        devtools: {\n            overlays: {\n                options: {},\n                selectors: []\n            }\n        }\n    }, registration));\n    if (isInBrowser) {\n        ensureJQuerySupport();\n        reroute();\n    }\n}\nfunction checkActivityFunctions() {\n    var location1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.location;\n    return apps.filter(function(app) {\n        return app.activeWhen(location1);\n    }).map(toName);\n}\nfunction unregisterApplication(appName) {\n    if (apps.filter(function(app) {\n        return toName(app) === appName;\n    }).length === 0) {\n        throw Error(formatErrorMessage(25, \"Cannot unregister application '\".concat(appName, \"' because no such application has been registered\"), appName));\n    }\n    var unloadPromise = isInBrowser ? unloadApplication(appName, {\n        waitForUnmount: false\n    }) : Promise.resolve();\n    return unloadPromise.then(function() {\n        var appIndex = apps.map(toName).indexOf(appName);\n        apps.splice(appIndex, 1);\n    });\n}\nfunction unloadApplication(appName) {\n    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n        waitForUnmount: false\n    };\n    if (typeof appName !== \"string\") {\n        throw Error(formatErrorMessage(26, \"unloadApplication requires a string 'appName'\"));\n    }\n    var app = find(apps, function(App) {\n        return toName(App) === appName;\n    });\n    if (!app) {\n        throw Error(formatErrorMessage(27, \"Could not unload application '\".concat(appName, \"' because no such application has been registered\"), appName));\n    }\n    var appUnloadInfo = getAppUnloadInfo(toName(app));\n    if (opts && opts.waitForUnmount) {\n        // We need to wait for unmount before unloading the app\n        if (appUnloadInfo) {\n            // Someone else is already waiting for this, too\n            return appUnloadInfo.promise;\n        } else {\n            // We're the first ones wanting the app to be resolved.\n            var promise = new Promise(function(resolve, reject) {\n                addAppToUnload(app, function() {\n                    return promise;\n                }, resolve, reject);\n            });\n            return promise;\n        }\n    } else {\n        /* We should unmount the app, unload it, and remount it immediately.\n     */ var resultPromise;\n        if (appUnloadInfo) {\n            // Someone else is already waiting for this app to unload\n            resultPromise = appUnloadInfo.promise;\n            immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n        } else {\n            // We're the first ones wanting the app to be resolved.\n            resultPromise = new Promise(function(resolve, reject) {\n                addAppToUnload(app, function() {\n                    return resultPromise;\n                }, resolve, reject);\n                immediatelyUnloadApp(app, resolve, reject);\n            });\n        }\n        return resultPromise;\n    }\n}\nfunction immediatelyUnloadApp(app, resolve, reject) {\n    Promise.resolve().then(function() {\n        // Before unmounting the application, we first must wait for it to finish mounting\n        // Otherwise, the test for issue 871 in unregister-application.spec.js fails because\n        // the application isn't really unmounted.\n        if (find(checkActivityFunctions(), function(activeApp) {\n            return activeApp === toName(app);\n        })) {\n            return triggerAppChange();\n        }\n    }).then(function() {\n        return toUnmountPromise(app).then(toUnloadPromise).then(function() {\n            resolve();\n            setTimeout(function() {\n                // reroute, but the unload promise is done\n                reroute();\n            });\n        });\n    }).catch(reject);\n}\nfunction validateRegisterWithArguments(name, appOrLoadApp, activeWhen, customProps) {\n    if (typeof name !== \"string\" || name.length === 0) throw Error(formatErrorMessage(20, \"The 1st argument to registerApplication must be a non-empty string 'appName'\"));\n    if (!appOrLoadApp) throw Error(formatErrorMessage(23, \"The 2nd argument to registerApplication must be an application or loading application function\"));\n    if (typeof activeWhen !== \"function\") throw Error(formatErrorMessage(24, \"The 3rd argument to registerApplication must be an activeWhen function\"));\n    if (!validCustomProps(customProps)) throw Error(formatErrorMessage(22, \"The optional 4th argument is a customProps and must be an object\"));\n}\nfunction validateRegisterWithConfig(config) {\n    if (Array.isArray(config) || config === null) throw Error(formatErrorMessage(39, \"Configuration object can't be an Array or null!\"));\n    var validKeys = [\n        \"name\",\n        \"app\",\n        \"activeWhen\",\n        \"customProps\"\n    ];\n    var invalidKeys = Object.keys(config).reduce(function(invalidKeys, prop) {\n        return validKeys.indexOf(prop) >= 0 ? invalidKeys : invalidKeys.concat(prop);\n    }, []);\n    if (invalidKeys.length !== 0) throw Error(formatErrorMessage(38, \"The configuration object accepts only: \".concat(validKeys.join(\", \"), \". Invalid keys: \").concat(invalidKeys.join(\", \"), \".\"), validKeys.join(\", \"), invalidKeys.join(\", \")));\n    if (typeof config.name !== \"string\" || config.name.length === 0) throw Error(formatErrorMessage(20, \"The config.name on registerApplication must be a non-empty string\"));\n    if (_type_of(config.app) !== \"object\" && typeof config.app !== \"function\") throw Error(formatErrorMessage(20, \"The config.app on registerApplication must be an application or a loading function\"));\n    var allowsStringAndFunction = function(activeWhen) {\n        return typeof activeWhen === \"string\" || typeof activeWhen === \"function\";\n    };\n    if (!allowsStringAndFunction(config.activeWhen) && !(Array.isArray(config.activeWhen) && config.activeWhen.every(allowsStringAndFunction))) throw Error(formatErrorMessage(24, \"The config.activeWhen on registerApplication must be a string, function or an array with both\"));\n    if (!validCustomProps(config.customProps)) throw Error(formatErrorMessage(22, \"The optional config.customProps must be an object\"));\n}\nfunction validCustomProps(customProps) {\n    return !customProps || typeof customProps === \"function\" || (typeof customProps === \"undefined\" ? \"undefined\" : _type_of(customProps)) === \"object\" && customProps !== null && !Array.isArray(customProps);\n}\nfunction sanitizeArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps) {\n    var usingObjectAPI = (typeof appNameOrConfig === \"undefined\" ? \"undefined\" : _type_of(appNameOrConfig)) === \"object\";\n    var registration = {\n        name: null,\n        loadApp: null,\n        activeWhen: null,\n        customProps: null\n    };\n    if (usingObjectAPI) {\n        validateRegisterWithConfig(appNameOrConfig);\n        registration.name = appNameOrConfig.name;\n        registration.loadApp = appNameOrConfig.app;\n        registration.activeWhen = appNameOrConfig.activeWhen;\n        registration.customProps = appNameOrConfig.customProps;\n    } else {\n        validateRegisterWithArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps);\n        registration.name = appNameOrConfig;\n        registration.loadApp = appOrLoadApp;\n        registration.activeWhen = activeWhen;\n        registration.customProps = customProps;\n    }\n    registration.loadApp = sanitizeLoadApp(registration.loadApp);\n    registration.customProps = sanitizeCustomProps(registration.customProps);\n    registration.activeWhen = sanitizeActiveWhen(registration.activeWhen);\n    return registration;\n}\nfunction sanitizeLoadApp(loadApp) {\n    if (typeof loadApp !== \"function\") {\n        return function() {\n            return Promise.resolve(loadApp);\n        };\n    }\n    return loadApp;\n}\nfunction sanitizeCustomProps(customProps) {\n    return customProps ? customProps : {};\n}\nfunction sanitizeActiveWhen(activeWhen) {\n    var activeWhenArray = Array.isArray(activeWhen) ? activeWhen : [\n        activeWhen\n    ];\n    activeWhenArray = activeWhenArray.map(function(activeWhenOrPath) {\n        return typeof activeWhenOrPath === \"function\" ? activeWhenOrPath : pathToActiveWhen(activeWhenOrPath);\n    });\n    return function(location1) {\n        return activeWhenArray.some(function(activeWhen) {\n            return activeWhen(location1);\n        });\n    };\n}\nfunction pathToActiveWhen(path, exactMatch) {\n    var regex = toDynamicPathValidatorRegex(path, exactMatch);\n    return function(location1) {\n        // compatible with IE10\n        var origin = location1.origin;\n        if (!origin) {\n            origin = \"\".concat(location1.protocol, \"//\").concat(location1.host);\n        }\n        var route = location1.href.replace(origin, \"\").replace(location1.search, \"\").split(\"?\")[0];\n        return regex.test(route);\n    };\n}\nfunction toDynamicPathValidatorRegex(path, exactMatch) {\n    var lastIndex = 0, inDynamic = false, regexStr = \"^\";\n    if (path[0] !== \"/\") {\n        path = \"/\" + path;\n    }\n    for(var charIndex = 0; charIndex < path.length; charIndex++){\n        var char = path[charIndex];\n        var startOfDynamic = !inDynamic && char === \":\";\n        var endOfDynamic = inDynamic && char === \"/\";\n        if (startOfDynamic || endOfDynamic) {\n            appendToRegex(charIndex);\n        }\n    }\n    appendToRegex(path.length);\n    return new RegExp(regexStr, \"i\");\n    function appendToRegex(index) {\n        var anyCharMaybeTrailingSlashRegex = \"[^/]+/?\";\n        var commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n        regexStr += inDynamic ? anyCharMaybeTrailingSlashRegex : commonStringSubPath;\n        if (index === path.length) {\n            if (inDynamic) {\n                if (exactMatch) {\n                    // Ensure exact match paths that end in a dynamic portion don't match\n                    // urls with characters after a slash after the dynamic portion.\n                    regexStr += \"$\";\n                }\n            } else {\n                // For exact matches, expect no more characters. Otherwise, allow\n                // any characters.\n                var suffix = exactMatch ? \"\" : \".*\";\n                regexStr = regexStr.charAt(regexStr.length - 1) === \"/\" ? \"\".concat(regexStr).concat(suffix, \"$\") : \"\".concat(regexStr, \"(/\").concat(suffix, \")?(#.*)?$\");\n            }\n        }\n        inDynamic = !inDynamic;\n        lastIndex = index;\n    }\n    function escapeStrRegex(str) {\n        // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n        return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    }\n}\nvar appChangeUnderway = false, peopleWaitingOnAppChange = [], currentUrl = isInBrowser && window.location.href;\nfunction triggerAppChange() {\n    // Call reroute with no arguments, intentionally\n    return reroute();\n}\nfunction reroute() {\n    var pendingPromises = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], eventArguments = arguments.length > 1 ? arguments[1] : void 0, silentNavigation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    if (appChangeUnderway) {\n        return new Promise(function(resolve, reject) {\n            peopleWaitingOnAppChange.push({\n                resolve: resolve,\n                reject: reject,\n                eventArguments: eventArguments\n            });\n        });\n    }\n    var startTime, profilerKind;\n    {\n        startTime = performance.now();\n        if (silentNavigation) {\n            profilerKind = \"silentNavigation\";\n        } else if (eventArguments) {\n            profilerKind = \"browserNavigation\";\n        } else {\n            profilerKind = \"triggerAppChange\";\n        }\n    }\n    var _getAppChanges = getAppChanges(), appsToUnload = _getAppChanges.appsToUnload, appsToUnmount = _getAppChanges.appsToUnmount, appsToLoad = _getAppChanges.appsToLoad, appsToMount = _getAppChanges.appsToMount;\n    var appsThatChanged, cancelPromises = [], oldUrl = currentUrl, newUrl = currentUrl = window.location.href;\n    if (isStarted()) {\n        appChangeUnderway = true;\n        appsThatChanged = appsToUnload.concat(appsToLoad, appsToUnmount, appsToMount);\n        return performAppChanges();\n    } else {\n        appsThatChanged = appsToLoad;\n        return loadApps();\n    }\n    function cancelNavigation() {\n        var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        var promise = typeof (val === null || val === void 0 ? void 0 : val.then) === \"function\" ? val : Promise.resolve(val);\n        cancelPromises.push(promise.catch(function(err) {\n            console.warn(Error(formatErrorMessage(42, \"single-spa: A cancelNavigation promise rejected with the following value: \".concat(err))));\n            console.warn(err); // Interpret a Promise rejection to mean that the navigation should not be canceled\n            return false;\n        }));\n    }\n    function loadApps() {\n        return Promise.resolve().then(function() {\n            var loadPromises = appsToLoad.map(toLoadPromise);\n            var succeeded;\n            return Promise.all(loadPromises).then(callAllEventListeners) // there are no mounted apps, before start() is called, so we always return []\n            .then(function() {\n                {\n                    succeeded = true;\n                }\n                return [];\n            }).catch(function(err) {\n                {\n                    succeeded = false;\n                }\n                callAllEventListeners();\n                throw err;\n            }).finally(function() {\n                {\n                    addProfileEntry(\"routing\", \"loadApps\", profilerKind, startTime, performance.now(), succeeded);\n                }\n            });\n        });\n    }\n    function performAppChanges() {\n        return Promise.resolve().then(function() {\n            // https://github.com/single-spa/single-spa/issues/545\n            fireSingleSpaEvent(appsThatChanged.length === 0 ? \"before-no-app-change\" : \"before-app-change\", getCustomEventDetail(true));\n            fireSingleSpaEvent(\"before-routing-event\", getCustomEventDetail(true, {\n                cancelNavigation: cancelNavigation\n            }));\n            return Promise.all(cancelPromises).then(function(cancelValues) {\n                var navigationIsCanceled = cancelValues.some(function(v) {\n                    return v;\n                });\n                if (navigationIsCanceled) {\n                    // Change url back to old url, without triggering the normal single-spa reroute\n                    originalReplaceState.call(window.history, history.state, \"\", oldUrl.substring(location.origin.length)); // Single-spa's internal tracking of current url needs to be updated after the url change above\n                    currentUrl = location.href; // necessary for the reroute function to know that the current reroute is finished\n                    appChangeUnderway = false;\n                    {\n                        addProfileEntry(\"routing\", \"navigationCanceled\", profilerKind, startTime, performance.now(), true);\n                    }\n                    return reroute(pendingPromises, eventArguments, true);\n                }\n                var unloadPromises = appsToUnload.map(toUnloadPromise);\n                var unmountUnloadPromises = appsToUnmount.map(toUnmountPromise).map(function(unmountPromise) {\n                    return unmountPromise.then(toUnloadPromise);\n                });\n                var allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n                var unmountAllPromise = Promise.all(allUnmountPromises);\n                var unmountFinishedTime;\n                unmountAllPromise.then(function() {\n                    {\n                        unmountFinishedTime = performance.now();\n                        addProfileEntry(\"routing\", \"unmountAndUnload\", profilerKind, startTime, performance.now(), true);\n                    }\n                    fireSingleSpaEvent(\"before-mount-routing-event\", getCustomEventDetail(true));\n                }, function(err) {\n                    {\n                        addProfileEntry(\"routing\", \"unmountAndUnload\", profilerKind, startTime, performance.now(), true);\n                    }\n                    throw err;\n                });\n                /* We load and bootstrap apps while other apps are unmounting, but we\n         * wait to mount the app until all apps are finishing unmounting\n         */ var loadThenMountPromises = appsToLoad.map(function(app) {\n                    return toLoadPromise(app).then(function(app) {\n                        return tryToBootstrapAndMount(app, unmountAllPromise);\n                    });\n                });\n                /* These are the apps that are already bootstrapped and just need\n         * to be mounted. They each wait for all unmounting apps to finish up\n         * before they mount.\n         */ var mountPromises = appsToMount.filter(function(appToMount) {\n                    return appsToLoad.indexOf(appToMount) < 0;\n                }).map(function(appToMount) {\n                    return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n                });\n                return unmountAllPromise.catch(function(err) {\n                    callAllEventListeners();\n                    throw err;\n                }).then(function() {\n                    /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it's safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */ callAllEventListeners();\n                    return Promise.all(loadThenMountPromises.concat(mountPromises)).catch(function(err) {\n                        pendingPromises.forEach(function(promise) {\n                            return promise.reject(err);\n                        });\n                        throw err;\n                    }).then(finishUpAndReturn).then(function() {\n                        {\n                            addProfileEntry(\"routing\", \"loadAndMount\", profilerKind, unmountFinishedTime, performance.now(), true);\n                        }\n                    }, function(err) {\n                        {\n                            addProfileEntry(\"routing\", \"loadAndMount\", profilerKind, unmountFinishedTime, performance.now(), false);\n                        }\n                        throw err;\n                    });\n                });\n            });\n        });\n    }\n    function finishUpAndReturn() {\n        var returnValue = getMountedApps();\n        pendingPromises.forEach(function(promise) {\n            return promise.resolve(returnValue);\n        });\n        try {\n            var appChangeEventName = appsThatChanged.length === 0 ? \"no-app-change\" : \"app-change\";\n            fireSingleSpaEvent(appChangeEventName, getCustomEventDetail());\n            fireSingleSpaEvent(\"routing-event\", getCustomEventDetail());\n        } catch (err) {\n            /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */ setTimeout(function() {\n                throw err;\n            });\n        }\n        /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */ appChangeUnderway = false;\n        if (peopleWaitingOnAppChange.length > 0) {\n            /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */ var nextPendingPromises = peopleWaitingOnAppChange;\n            peopleWaitingOnAppChange = [];\n            reroute(nextPendingPromises);\n        }\n        return returnValue;\n    }\n    /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */ function callAllEventListeners() {\n        // During silent navigation (when navigation was canceled and we're going back to the old URL),\n        // we should not fire any popstate / hashchange events\n        if (!silentNavigation) {\n            pendingPromises.forEach(function(pendingPromise) {\n                callCapturedEventListeners(pendingPromise.eventArguments);\n            });\n            callCapturedEventListeners(eventArguments);\n        }\n    }\n    function getCustomEventDetail() {\n        var isBeforeChanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, extraProperties = arguments.length > 1 ? arguments[1] : void 0;\n        var newAppStatuses = {};\n        var _obj;\n        var appsByNewStatus = (_obj = {}, // for apps that were mounted\n        _define_property(_obj, MOUNTED, []), // for apps that were unmounted\n        _define_property(_obj, NOT_MOUNTED, []), // apps that were forcibly unloaded\n        _define_property(_obj, NOT_LOADED, []), // apps that attempted to do something but are broken now\n        _define_property(_obj, SKIP_BECAUSE_BROKEN, []), _obj);\n        if (isBeforeChanges) {\n            appsToLoad.concat(appsToMount).forEach(function(app, index) {\n                addApp(app, MOUNTED);\n            });\n            appsToUnload.forEach(function(app) {\n                addApp(app, NOT_LOADED);\n            });\n            appsToUnmount.forEach(function(app) {\n                addApp(app, NOT_MOUNTED);\n            });\n        } else {\n            appsThatChanged.forEach(function(app) {\n                addApp(app);\n            });\n        }\n        var result = {\n            detail: {\n                newAppStatuses: newAppStatuses,\n                appsByNewStatus: appsByNewStatus,\n                totalAppChanges: appsThatChanged.length,\n                originalEvent: eventArguments === null || eventArguments === void 0 ? void 0 : eventArguments[0],\n                oldUrl: oldUrl,\n                newUrl: newUrl\n            }\n        };\n        if (extraProperties) {\n            assign(result.detail, extraProperties);\n        }\n        return result;\n        function addApp(app, status) {\n            var appName = toName(app);\n            status = status || getAppStatus(appName);\n            newAppStatuses[appName] = status;\n            var statusArr = appsByNewStatus[status] = appsByNewStatus[status] || [];\n            statusArr.push(appName);\n        }\n    }\n    function fireSingleSpaEvent(name, eventProperties) {\n        // During silent navigation (caused by navigation cancelation), we should not\n        // fire any single-spa events\n        if (!silentNavigation) {\n            window.dispatchEvent(new customEvent(\"single-spa:\".concat(name), eventProperties));\n        }\n    }\n}\n/**\n * Let's imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn't bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */ function tryToBootstrapAndMount(app, unmountAllPromise) {\n    if (shouldBeActive(app)) {\n        return toBootstrapPromise(app).then(function(app) {\n            return unmountAllPromise.then(function() {\n                return shouldBeActive(app) ? toMountPromise(app) : app;\n            });\n        });\n    } else {\n        return unmountAllPromise.then(function() {\n            return app;\n        });\n    }\n}\nvar started = false;\nfunction start(opts) {\n    started = true;\n    if (isInBrowser) {\n        patchHistoryApi(opts);\n        reroute();\n    }\n}\nfunction isStarted() {\n    return started;\n}\nvar devtools = {\n    getRawAppData: getRawAppData,\n    reroute: reroute,\n    NOT_LOADED: NOT_LOADED,\n    toLoadPromise: toLoadPromise,\n    toBootstrapPromise: toBootstrapPromise,\n    unregisterApplication: unregisterApplication,\n    getProfilerData: getProfilerData\n};\nif (isInBrowser && window.__SINGLE_SPA_DEVTOOLS__) {\n    window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools;\n}\n //# sourceMappingURL=single-spa.dev.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbmdsZS1zcGEvbGliL2VzMjAxNS9lc20vc2luZ2xlLXNwYS5kZXYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJLGlCQUFpQixHQUFHQSxjQUFNLENBQUMsV0FBVyxDQUFDO0FBRTNDLFNBQVMsU0FBUyxJQUFJO0lBQ3BCLElBQUk7UUFDRixJQUFJLENBQUMsR0FBRyxJQUFJLGlCQUFpQixDQUFDLEtBQUssRUFBRTtZQUFFLE1BQU0sRUFBRTtnQkFBRSxHQUFHLEVBQUUsS0FBSztZQUFBLENBQUU7UUFBQSxDQUFFLENBQUMsQ0FBQztRQUNqRSxPQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUN2RCxDQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FDZCxDQUFHO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7OztDQU1BLEdBRUEsZUFBYyxHQUFHLFNBQVMsRUFBRSxHQUFHLGlCQUFpQixHQUVoRDtBQUNBLFdBQVcsS0FBSyxPQUFPLFFBQVEsSUFBSSxVQUFVLEtBQUssT0FBTyxRQUFRLENBQUMsV0FBVyxHQUFHLFNBQVMsV0FBVyxDQUFFLElBQUksRUFBRSxNQUFNLEVBQUU7SUFDbEgsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUM1QyxJQUFJLE1BQU0sRUFBRTtRQUNWLENBQUMsQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0s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LFdBQUosRUFBaUI7UUFDZjZDLGVBQWUsQ0FBQ0MsSUFBRCxDQUFmO1FBQ0FsQixPQUFPO0lBQ1I7QUFDRjtBQUVNLFNBQVM2RSxTQUFULEdBQXFCO0lBQzFCLE9BQU9xRyxPQUFQO0FBQ0Q7QUNURCxlQUFlO21CQUNiN0csYUFEYTthQUVickUsT0FGYTtnQkFHYnRMLFVBSGE7bUJBSWI4SSxhQUphO3dCQUtickYsa0JBTGE7MkJBTWI4TSxxQkFOYTtxQkFPYnBOLGVBQUFBO0FBUGEsQ0FBZjtBQ3dDQSxJQUFJdUcsV0FBVyxJQUFJM0ksTUFBTSxDQUFDMFYsdUJBQTFCLEVBQW1EO0lBQ2pEMVYsTUFBTSxDQUFDMFYsdUJBQVAsQ0FBK0JDLGNBQS9CLEdBQWdEcE4sUUFBaEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2N1c3RvbS1ldmVudEAxLjAuMS9ub2RlX21vZHVsZXMvY3VzdG9tLWV2ZW50L2luZGV4LmpzPzNkYjYiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanM/OTQwYSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbnMvYXBwLmhlbHBlcnMuanM/YTRlMSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy91dGlscy9hc3NpZ24uanM/ZDQzNiIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy91dGlscy9maW5kLmpzP2JiY2QiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvbGlmZWN5Y2xlcy9saWZlY3ljbGUuaGVscGVycy5qcz85NDAwIiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vc3JjL2RldnRvb2xzL3Byb2ZpbGVyLmpzPzk2NzAiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvbGlmZWN5Y2xlcy9ib290c3RyYXAuanM/ZDBkYyIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9saWZlY3ljbGVzL3VubW91bnQuanM/MDA2MSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9saWZlY3ljbGVzL21vdW50LmpzPzk4MGUiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvbGlmZWN5Y2xlcy91cGRhdGUuanM/NzE5NSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9wYXJjZWxzL21vdW50LXBhcmNlbC5qcz8wY2NmIiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vc3JjL2xpZmVjeWNsZXMvcHJvcC5oZWxwZXJzLmpzP2FkYmEiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb25zL3RpbWVvdXRzLmpzPzA1YTIiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvbGlmZWN5Y2xlcy9sb2FkLmpzP2NmYTUiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvdXRpbHMvcnVudGltZS1lbnZpcm9ubWVudC5qcz8xNTg2Iiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vc3JjL25hdmlnYXRpb24vbmF2aWdhdGlvbi1ldmVudHMuanM/ZDE5YyIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9qcXVlcnktc3VwcG9ydC5qcz9iZDIwIiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vc3JjL2xpZmVjeWNsZXMvdW5sb2FkLmpzP2U1NjgiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb25zL2FwcHMuanM/NDAxNCIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9uYXZpZ2F0aW9uL3Jlcm91dGUuanM/N2Q3YSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL3NyYy9zdGFydC5qcz9kZDZmIiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vLi4vLi4vc3JjL2RldnRvb2xzL2RldnRvb2xzLmpzP2IyNzkiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi8uLi8uLi9zcmMvc2luZ2xlLXNwYS5qcz80MmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIE5hdGl2ZUN1c3RvbUV2ZW50ID0gZ2xvYmFsLkN1c3RvbUV2ZW50O1xuXG5mdW5jdGlvbiB1c2VOYXRpdmUgKCkge1xuICB0cnkge1xuICAgIHZhciBwID0gbmV3IE5hdGl2ZUN1c3RvbUV2ZW50KCdjYXQnLCB7IGRldGFpbDogeyBmb286ICdiYXInIH0gfSk7XG4gICAgcmV0dXJuICAnY2F0JyA9PT0gcC50eXBlICYmICdiYXInID09PSBwLmRldGFpbC5mb287XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ3Jvc3MtYnJvd3NlciBgQ3VzdG9tRXZlbnRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC5DdXN0b21FdmVudFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZU5hdGl2ZSgpID8gTmF0aXZlQ3VzdG9tRXZlbnQgOlxuXG4vLyBJRSA+PSA5XG4ndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA/IGZ1bmN0aW9uIEN1c3RvbUV2ZW50ICh0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gIH0gZWxzZSB7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCB2b2lkIDApO1xuICB9XG4gIHJldHVybiBlO1xufSA6XG5cbi8vIElFIDw9IDhcbmZ1bmN0aW9uIEN1c3RvbUV2ZW50ICh0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICBlLnR5cGUgPSB0eXBlO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZS5idWJibGVzID0gQm9vbGVhbihwYXJhbXMuYnViYmxlcyk7XG4gICAgZS5jYW5jZWxhYmxlID0gQm9vbGVhbihwYXJhbXMuY2FuY2VsYWJsZSk7XG4gICAgZS5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICB9IGVsc2Uge1xuICAgIGUuYnViYmxlcyA9IGZhbHNlO1xuICAgIGUuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIGUuZGV0YWlsID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiBlO1xufVxuIiwiaW1wb3J0IHsgb2JqZWN0VHlwZSwgdG9OYW1lIH0gZnJvbSBcIi4vYXBwLmhlbHBlcnNcIjtcblxubGV0IGVycm9ySGFuZGxlcnMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUFwcEVycm9yKGVyciwgYXBwLCBuZXdTdGF0dXMpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRFcnIgPSB0cmFuc2Zvcm1FcnIoZXJyLCBhcHAsIG5ld1N0YXR1cyk7XG5cbiAgaWYgKGVycm9ySGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgZXJyb3JIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyKHRyYW5zZm9ybWVkRXJyKSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyB0cmFuc2Zvcm1lZEVycjtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMjgsXG4gICAgICAgIF9fREVWX18gJiYgXCJhIHNpbmdsZS1zcGEgZXJyb3IgaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBlcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyOSxcbiAgICAgICAgX19ERVZfXyAmJiBcImEgc2luZ2xlLXNwYSBlcnJvciBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvblwiXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGxldCByZW1vdmVkU29tZXRoaW5nID0gZmFsc2U7XG4gIGVycm9ySGFuZGxlcnMgPSBlcnJvckhhbmRsZXJzLmZpbHRlcigoaCkgPT4ge1xuICAgIGNvbnN0IGlzSGFuZGxlciA9IGggPT09IGhhbmRsZXI7XG4gICAgcmVtb3ZlZFNvbWV0aGluZyA9IHJlbW92ZWRTb21ldGhpbmcgfHwgaXNIYW5kbGVyO1xuICAgIHJldHVybiAhaXNIYW5kbGVyO1xuICB9KTtcblxuICByZXR1cm4gcmVtb3ZlZFNvbWV0aGluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEVycm9yTWVzc2FnZShjb2RlLCBtc2csIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGBzaW5nbGUtc3BhIG1pbmlmaWVkIG1lc3NhZ2UgIyR7Y29kZX06ICR7XG4gICAgbXNnID8gbXNnICsgXCIgXCIgOiBcIlwiXG4gIH1TZWUgaHR0cHM6Ly9zaW5nbGUtc3BhLmpzLm9yZy9lcnJvci8/Y29kZT0ke2NvZGV9JHtcbiAgICBhcmdzLmxlbmd0aCA/IGAmYXJnPSR7YXJncy5qb2luKFwiJmFyZz1cIil9YCA6IFwiXCJcbiAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FcnIob2dFcnIsIGFwcE9yUGFyY2VsLCBuZXdTdGF0dXMpIHtcbiAgY29uc3QgZXJyUHJlZml4ID0gYCR7b2JqZWN0VHlwZShhcHBPclBhcmNlbCl9ICcke3RvTmFtZShcbiAgICBhcHBPclBhcmNlbFxuICApfScgZGllZCBpbiBzdGF0dXMgJHthcHBPclBhcmNlbC5zdGF0dXN9OiBgO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgaWYgKG9nRXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgb2dFcnIubWVzc2FnZSA9IGVyclByZWZpeCArIG9nRXJyLm1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvKiBTb21lIGVycm9ycyBoYXZlIHJlYWQtb25seSBtZXNzYWdlIHByb3BlcnRpZXMsIGluIHdoaWNoIGNhc2UgdGhlcmUgaXMgbm90aGluZ1xuICAgICAgICogdGhhdCB3ZSBjYW4gZG8uXG4gICAgICAgKi9cbiAgICB9XG4gICAgcmVzdWx0ID0gb2dFcnI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAzMCxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBXaGlsZSAke2FwcE9yUGFyY2VsLnN0YXR1c30sICcke3RvTmFtZShcbiAgICAgICAgICAgIGFwcE9yUGFyY2VsXG4gICAgICAgICAgKX0nIHJlamVjdGVkIGl0cyBsaWZlY3ljbGUgZnVuY3Rpb24gcHJvbWlzZSB3aXRoIGEgbm9uLUVycm9yLiBUaGlzIHdpbGwgY2F1c2Ugc3RhY2sgdHJhY2VzIHRvIG5vdCBiZSBhY2N1cmF0ZS5gLFxuICAgICAgICBhcHBPclBhcmNlbC5zdGF0dXMsXG4gICAgICAgIHRvTmFtZShhcHBPclBhcmNlbClcbiAgICAgIClcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBFcnJvcihlcnJQcmVmaXggKyBKU09OLnN0cmluZ2lmeShvZ0VycikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgaXQncyBub3QgYW4gRXJyb3IgYW5kIHlvdSBjYW4ndCBzdHJpbmdpZnkgaXQsIHRoZW4gd2hhdCBlbHNlIGNhbiB5b3UgZXZlbiBkbyB0byBpdD9cbiAgICAgIHJlc3VsdCA9IG9nRXJyO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdC5hcHBPclBhcmNlbE5hbWUgPSB0b05hbWUoYXBwT3JQYXJjZWwpO1xuXG4gIC8vIFdlIHNldCB0aGUgc3RhdHVzIGFmdGVyIHRyYW5zZm9ybWluZyB0aGUgZXJyb3Igc28gdGhhdCB0aGUgZXJyb3IgbWVzc2FnZVxuICAvLyByZWZlcmVuY2VzIHRoZSBzdGF0ZSB0aGUgYXBwbGljYXRpb24gd2FzIGluIGJlZm9yZSB0aGUgc3RhdHVzIGNoYW5nZS5cbiAgYXBwT3JQYXJjZWwuc3RhdHVzID0gbmV3U3RhdHVzO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBoYW5kbGVBcHBFcnJvciB9IGZyb20gXCIuL2FwcC1lcnJvcnMuanNcIjtcblxuLy8gQXBwIHN0YXR1c2VzXG5leHBvcnQgY29uc3QgTk9UX0xPQURFRCA9IFwiTk9UX0xPQURFRFwiO1xuZXhwb3J0IGNvbnN0IExPQURJTkdfU09VUkNFX0NPREUgPSBcIkxPQURJTkdfU09VUkNFX0NPREVcIjtcbmV4cG9ydCBjb25zdCBOT1RfQk9PVFNUUkFQUEVEID0gXCJOT1RfQk9PVFNUUkFQUEVEXCI7XG5leHBvcnQgY29uc3QgQk9PVFNUUkFQUElORyA9IFwiQk9PVFNUUkFQUElOR1wiO1xuZXhwb3J0IGNvbnN0IE5PVF9NT1VOVEVEID0gXCJOT1RfTU9VTlRFRFwiO1xuZXhwb3J0IGNvbnN0IE1PVU5USU5HID0gXCJNT1VOVElOR1wiO1xuZXhwb3J0IGNvbnN0IE1PVU5URUQgPSBcIk1PVU5URURcIjtcbmV4cG9ydCBjb25zdCBVUERBVElORyA9IFwiVVBEQVRJTkdcIjtcbmV4cG9ydCBjb25zdCBVTk1PVU5USU5HID0gXCJVTk1PVU5USU5HXCI7XG5leHBvcnQgY29uc3QgVU5MT0FESU5HID0gXCJVTkxPQURJTkdcIjtcbmV4cG9ydCBjb25zdCBMT0FEX0VSUk9SID0gXCJMT0FEX0VSUk9SXCI7XG5leHBvcnQgY29uc3QgU0tJUF9CRUNBVVNFX0JST0tFTiA9IFwiU0tJUF9CRUNBVVNFX0JST0tFTlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBY3RpdmUoYXBwKSB7XG4gIHJldHVybiBhcHAuc3RhdHVzID09PSBNT1VOVEVEO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQmVBY3RpdmUoYXBwKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFwcC5hY3RpdmVXaGVuKHdpbmRvdy5sb2NhdGlvbik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUFwcEVycm9yKGVyciwgYXBwLCBTS0lQX0JFQ0FVU0VfQlJPS0VOKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTmFtZShhcHApIHtcbiAgcmV0dXJuIGFwcC5uYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJjZWwoYXBwT3JQYXJjZWwpIHtcbiAgcmV0dXJuIEJvb2xlYW4oYXBwT3JQYXJjZWwudW5tb3VudFRoaXNQYXJjZWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0VHlwZShhcHBPclBhcmNlbCkge1xuICByZXR1cm4gaXNQYXJjZWwoYXBwT3JQYXJjZWwpID8gXCJwYXJjZWxcIiA6IFwiYXBwbGljYXRpb25cIjtcbn1cbiIsIi8vIE9iamVjdC5hc3NpZ24oKSBpcyBub3QgYXZhaWxhYmxlIGluIElFMTEuIEFuZCB0aGUgYmFiZWwgY29tcGlsZWQgb3V0cHV0IGZvciBvYmplY3Qgc3ByZWFkXG4vLyBzeW50YXggY2hlY2tzIGEgYnVuY2ggb2YgU3ltYm9sIHN0dWZmIGFuZCBpcyBhbG1vc3QgYSBrYi4gU28gdGhpcyBmdW5jdGlvbiBpcyB0aGUgc21hbGxlciByZXBsYWNlbWVudC5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oKSB7XG4gIGZvciAobGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGZvciAobGV0IGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcmd1bWVudHNbaSAtIDFdW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJndW1lbnRzWzBdO1xufVxuIiwiLyogdGhlIGFycmF5LnByb3RvdHlwZS5maW5kIHBvbHlmaWxsIG9uIG5wbWpzLmNvbSBpcyB+MjBrYiAobm90IHdvcnRoIGl0KVxuICogYW5kIGxvZGFzaCBpcyB+MjAwa2IgKG5vdCB3b3J0aCBpdClcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIGZ1bmMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnVuYyhhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgZmluZCB9IGZyb20gXCIuLi91dGlscy9maW5kLmpzXCI7XG5pbXBvcnQgeyBvYmplY3RUeXBlLCB0b05hbWUgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkTGlmZWN5Y2xlRm4oZm4pIHtcbiAgcmV0dXJuIGZuICYmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiB8fCBpc0FycmF5T2ZGbnMoZm4pKTtcblxuICBmdW5jdGlvbiBpc0FycmF5T2ZGbnMoYXJyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEFycmF5LmlzQXJyYXkoYXJyKSAmJiAhZmluZChhcnIsIChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5GbkFycmF5KGFwcE9yUGFyY2VsLCBsaWZlY3ljbGUpIHtcbiAgbGV0IGZucyA9IGFwcE9yUGFyY2VsW2xpZmVjeWNsZV0gfHwgW107XG4gIGZucyA9IEFycmF5LmlzQXJyYXkoZm5zKSA/IGZucyA6IFtmbnNdO1xuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIGZucyA9IFsoKSA9PiBQcm9taXNlLnJlc29sdmUoKV07XG4gIH1cblxuICBjb25zdCB0eXBlID0gb2JqZWN0VHlwZShhcHBPclBhcmNlbCk7XG4gIGNvbnN0IG5hbWUgPSB0b05hbWUoYXBwT3JQYXJjZWwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZSgocmVzdWx0UHJvbWlzZSwgZm4sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGhpc1Byb21pc2UgPSBmbihwcm9wcyk7XG4gICAgICAgIHJldHVybiBzbWVsbHNMaWtlQVByb21pc2UodGhpc1Byb21pc2UpXG4gICAgICAgICAgPyB0aGlzUHJvbWlzZVxuICAgICAgICAgIDogUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgICAxNSxcbiAgICAgICAgICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgICAgICAgICBgV2l0aGluICR7dHlwZX0gJHtuYW1lfSwgdGhlIGxpZmVjeWNsZSBmdW5jdGlvbiAke2xpZmVjeWNsZX0gYXQgYXJyYXkgaW5kZXggJHtpbmRleH0gZGlkIG5vdCByZXR1cm4gYSBwcm9taXNlYCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbWVsbHNMaWtlQVByb21pc2UocHJvbWlzZSkge1xuICByZXR1cm4gKFxuICAgIHByb21pc2UgJiZcbiAgICB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgcHJvbWlzZS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiXG4gICk7XG59XG4iLCJsZXQgcHJvZmlsZUVudHJpZXMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2ZpbGVyRGF0YSgpIHtcbiAgcmV0dXJuIHByb2ZpbGVFbnRyaWVzO1xufVxuXG4vKipcbiAqXG4gKiBAdHlwZSB7J2FwcGxpY2F0aW9uJyB8ICdwYXJjZWwnIHwgJ3JvdXRpbmcnfSBQcm9maWxlVHlwZVxuICpcbiAqIEBwYXJhbSB7UHJvZmlsZVR5cGV9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2ZpbGVFbnRyeShcbiAgdHlwZSxcbiAgbmFtZSxcbiAga2luZCxcbiAgc3RhcnQsXG4gIGVuZCxcbiAgb3BlcmF0aW9uU3VjY2VlZGVkXG4pIHtcbiAgcHJvZmlsZUVudHJpZXMucHVzaCh7XG4gICAgdHlwZSxcbiAgICBuYW1lLFxuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBraW5kLFxuICAgIG9wZXJhdGlvblN1Y2NlZWRlZCxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclByb2ZpbGVyRGF0YSgpIHtcbiAgcHJvZmlsZUVudHJpZXMgPSBbXTtcbn1cbiIsImltcG9ydCB7XG4gIE5PVF9CT09UU1RSQVBQRUQsXG4gIEJPT1RTVFJBUFBJTkcsXG4gIE5PVF9NT1VOVEVELFxuICBTS0lQX0JFQ0FVU0VfQlJPS0VOLFxuICB0b05hbWUsXG4gIGlzUGFyY2VsLFxufSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyByZWFzb25hYmxlVGltZSB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvdGltZW91dHMuanNcIjtcbmltcG9ydCB7IGhhbmRsZUFwcEVycm9yLCB0cmFuc2Zvcm1FcnIgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcbmltcG9ydCB7IGFkZFByb2ZpbGVFbnRyeSB9IGZyb20gXCIuLi9kZXZ0b29scy9wcm9maWxlci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Cb290c3RyYXBQcm9taXNlKGFwcE9yUGFyY2VsLCBoYXJkRmFpbCkge1xuICBsZXQgc3RhcnRUaW1lLCBwcm9maWxlRXZlbnRUeXBlO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoYXBwT3JQYXJjZWwuc3RhdHVzICE9PSBOT1RfQk9PVFNUUkFQUEVEKSB7XG4gICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgfVxuXG4gICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICBwcm9maWxlRXZlbnRUeXBlID0gaXNQYXJjZWwoYXBwT3JQYXJjZWwpID8gXCJwYXJjZWxcIiA6IFwiYXBwbGljYXRpb25cIjtcbiAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IEJPT1RTVFJBUFBJTkc7XG5cbiAgICBpZiAoIWFwcE9yUGFyY2VsLmJvb3RzdHJhcCkge1xuICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBib290c3RyYXBcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKHN1Y2Nlc3NmdWxCb290c3RyYXApO1xuICAgIH1cblxuICAgIHJldHVybiByZWFzb25hYmxlVGltZShhcHBPclBhcmNlbCwgXCJib290c3RyYXBcIilcbiAgICAgIC50aGVuKHN1Y2Nlc3NmdWxCb290c3RyYXApXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICBwcm9maWxlRXZlbnRUeXBlLFxuICAgICAgICAgICAgdG9OYW1lKGFwcE9yUGFyY2VsKSxcbiAgICAgICAgICAgIFwiYm9vdHN0cmFwXCIsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXJkRmFpbCkge1xuICAgICAgICAgIHRocm93IHRyYW5zZm9ybUVycihlcnIsIGFwcE9yUGFyY2VsLCBTS0lQX0JFQ0FVU0VfQlJPS0VOKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVBcHBFcnJvcihlcnIsIGFwcE9yUGFyY2VsLCBTS0lQX0JFQ0FVU0VfQlJPS0VOKTtcbiAgICAgICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBzdWNjZXNzZnVsQm9vdHN0cmFwKCkge1xuICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IE5PVF9NT1VOVEVEO1xuXG4gICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgIHByb2ZpbGVFdmVudFR5cGUsXG4gICAgICAgIHRvTmFtZShhcHBPclBhcmNlbCksXG4gICAgICAgIFwiYm9vdHN0cmFwXCIsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBVTk1PVU5USU5HLFxuICBOT1RfTU9VTlRFRCxcbiAgTU9VTlRFRCxcbiAgU0tJUF9CRUNBVVNFX0JST0tFTixcbiAgdG9OYW1lLFxuICBpc1BhcmNlbCxcbn0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAuaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgaGFuZGxlQXBwRXJyb3IsIHRyYW5zZm9ybUVyciB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLWVycm9ycy5qc1wiO1xuaW1wb3J0IHsgcmVhc29uYWJsZVRpbWUgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL3RpbWVvdXRzLmpzXCI7XG5pbXBvcnQgeyBhZGRQcm9maWxlRW50cnkgfSBmcm9tIFwiLi4vZGV2dG9vbHMvcHJvZmlsZXIuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvVW5tb3VudFByb21pc2UoYXBwT3JQYXJjZWwsIGhhcmRGYWlsKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoYXBwT3JQYXJjZWwuc3RhdHVzICE9PSBNT1VOVEVEKSB7XG4gICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0VGltZSwgcHJvZmlsZUV2ZW50VHlwZTtcblxuICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBwcm9maWxlRXZlbnRUeXBlID0gaXNQYXJjZWwoYXBwT3JQYXJjZWwpID8gXCJwYXJjZWxcIiA6IFwiYXBwbGljYXRpb25cIjtcbiAgICB9XG5cbiAgICBhcHBPclBhcmNlbC5zdGF0dXMgPSBVTk1PVU5USU5HO1xuXG4gICAgY29uc3QgdW5tb3VudENoaWxkcmVuUGFyY2VscyA9IE9iamVjdC5rZXlzKGFwcE9yUGFyY2VsLnBhcmNlbHMpLm1hcChcbiAgICAgIChwYXJjZWxJZCkgPT4gYXBwT3JQYXJjZWwucGFyY2Vsc1twYXJjZWxJZF0udW5tb3VudFRoaXNQYXJjZWwoKVxuICAgICk7XG5cbiAgICBsZXQgcGFyY2VsRXJyb3I7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodW5tb3VudENoaWxkcmVuUGFyY2VscylcbiAgICAgIC50aGVuKHVubW91bnRBcHBPclBhcmNlbCwgKHBhcmNlbEVycm9yKSA9PiB7XG4gICAgICAgIC8vIFRoZXJlIGlzIGEgcGFyY2VsIHVubW91bnQgZXJyb3JcbiAgICAgICAgcmV0dXJuIHVubW91bnRBcHBPclBhcmNlbCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vIFVubW91bnRpbmcgdGhlIGFwcC9wYXJjZWwgc3VjY2VlZGVkLCBidXQgdW5tb3VudGluZyBpdHMgY2hpbGRyZW4gcGFyY2VscyBkaWQgbm90XG4gICAgICAgICAgY29uc3QgcGFyZW50RXJyb3IgPSBFcnJvcihwYXJjZWxFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBpZiAoaGFyZEZhaWwpIHtcbiAgICAgICAgICAgIHRocm93IHRyYW5zZm9ybUVycihwYXJlbnRFcnJvciwgYXBwT3JQYXJjZWwsIFNLSVBfQkVDQVVTRV9CUk9LRU4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVBcHBFcnJvcihwYXJlbnRFcnJvciwgYXBwT3JQYXJjZWwsIFNLSVBfQkVDQVVTRV9CUk9LRU4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4gYXBwT3JQYXJjZWwpO1xuXG4gICAgZnVuY3Rpb24gdW5tb3VudEFwcE9yUGFyY2VsKCkge1xuICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byB1bm1vdW50IHRoZSBhcHBPclBhcmNlbCwgZXZlbiBpZiB0aGUgY2hpbGRyZW4gcGFyY2VscyBmYWlsZWQgdG8gdW5tb3VudC5cbiAgICAgIHJldHVybiByZWFzb25hYmxlVGltZShhcHBPclBhcmNlbCwgXCJ1bm1vdW50XCIpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBUaGUgYXBwT3JQYXJjZWwgbmVlZHMgdG8gc3RheSBpbiBhIGJyb2tlbiBzdGF0dXMgaWYgaXRzIGNoaWxkcmVuIHBhcmNlbHMgZmFpbCB0byB1bm1vdW50XG4gICAgICAgICAgaWYgKCFwYXJjZWxFcnJvcikge1xuICAgICAgICAgICAgYXBwT3JQYXJjZWwuc3RhdHVzID0gTk9UX01PVU5URUQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICAgIHByb2ZpbGVFdmVudFR5cGUsXG4gICAgICAgICAgICAgIHRvTmFtZShhcHBPclBhcmNlbCksXG4gICAgICAgICAgICAgIFwidW5tb3VudFwiLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgICBwcm9maWxlRXZlbnRUeXBlLFxuICAgICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgICBcInVubW91bnRcIixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhcmRGYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyB0cmFuc2Zvcm1FcnIoZXJyLCBhcHBPclBhcmNlbCwgU0tJUF9CRUNBVVNFX0JST0tFTik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUFwcEVycm9yKGVyciwgYXBwT3JQYXJjZWwsIFNLSVBfQkVDQVVTRV9CUk9LRU4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtcbiAgTk9UX01PVU5URUQsXG4gIE1PVU5URUQsXG4gIFNLSVBfQkVDQVVTRV9CUk9LRU4sXG4gIE1PVU5USU5HLFxuICB0b05hbWUsXG4gIGlzUGFyY2VsLFxufSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBoYW5kbGVBcHBFcnJvciwgdHJhbnNmb3JtRXJyIH0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAtZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyByZWFzb25hYmxlVGltZSB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvdGltZW91dHMuanNcIjtcbmltcG9ydCBDdXN0b21FdmVudCBmcm9tIFwiY3VzdG9tLWV2ZW50XCI7XG5pbXBvcnQgeyB0b1VubW91bnRQcm9taXNlIH0gZnJvbSBcIi4vdW5tb3VudC5qc1wiO1xuaW1wb3J0IHsgYWRkUHJvZmlsZUVudHJ5IH0gZnJvbSBcIi4uL2RldnRvb2xzL3Byb2ZpbGVyLmpzXCI7XG5cbmxldCBiZWZvcmVGaXJzdE1vdW50RmlyZWQgPSBmYWxzZTtcbmxldCBmaXJzdE1vdW50RmlyZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvTW91bnRQcm9taXNlKGFwcE9yUGFyY2VsLCBoYXJkRmFpbCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKGFwcE9yUGFyY2VsLnN0YXR1cyAhPT0gTk9UX01PVU5URUQpIHtcbiAgICAgIHJldHVybiBhcHBPclBhcmNlbDtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRUaW1lLCBwcm9maWxlRXZlbnRUeXBlO1xuXG4gICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICBwcm9maWxlRXZlbnRUeXBlID0gaXNQYXJjZWwoYXBwT3JQYXJjZWwpID8gXCJwYXJjZWxcIiA6IFwiYXBwbGljYXRpb25cIjtcbiAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGlmICghYmVmb3JlRmlyc3RNb3VudEZpcmVkKSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzaW5nbGUtc3BhOmJlZm9yZS1maXJzdC1tb3VudFwiKSk7XG4gICAgICBiZWZvcmVGaXJzdE1vdW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IE1PVU5USU5HO1xuXG4gICAgcmV0dXJuIHJlYXNvbmFibGVUaW1lKGFwcE9yUGFyY2VsLCBcIm1vdW50XCIpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IE1PVU5URUQ7XG5cbiAgICAgICAgaWYgKCFmaXJzdE1vdW50RmlyZWQpIHtcbiAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzaW5nbGUtc3BhOmZpcnN0LW1vdW50XCIpKTtcbiAgICAgICAgICBmaXJzdE1vdW50RmlyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgcHJvZmlsZUV2ZW50VHlwZSxcbiAgICAgICAgICAgIHRvTmFtZShhcHBPclBhcmNlbCksXG4gICAgICAgICAgICBcIm1vdW50XCIsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vIElmIHdlIGZhaWwgdG8gbW91bnQgdGhlIGFwcE9yUGFyY2VsLCB3ZSBzaG91bGQgYXR0ZW1wdCB0byB1bm1vdW50IGl0IGJlZm9yZSBwdXR0aW5nIGluIFNLSVBfQkVDQVVTRV9CUk9LRU5cbiAgICAgICAgLy8gV2UgdGVtcG9yYXJpbHkgcHV0IHRoZSBhcHBPclBhcmNlbCBpbnRvIE1PVU5URUQgc3RhdHVzIHNvIHRoYXQgdG9Vbm1vdW50UHJvbWlzZSBhY3R1YWxseSBhdHRlbXB0cyB0byB1bm1vdW50IGl0XG4gICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBkb2luZyBhIG5vLW9wLlxuICAgICAgICBhcHBPclBhcmNlbC5zdGF0dXMgPSBNT1VOVEVEO1xuICAgICAgICByZXR1cm4gdG9Vbm1vdW50UHJvbWlzZShhcHBPclBhcmNlbCwgdHJ1ZSkudGhlbihcbiAgICAgICAgICBzZXRTa2lwQmVjYXVzZUJyb2tlbixcbiAgICAgICAgICBzZXRTa2lwQmVjYXVzZUJyb2tlblxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldFNraXBCZWNhdXNlQnJva2VuKCkge1xuICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgICBwcm9maWxlRXZlbnRUeXBlLFxuICAgICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgICBcIm1vdW50XCIsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaGFyZEZhaWwpIHtcbiAgICAgICAgICAgIGhhbmRsZUFwcEVycm9yKGVyciwgYXBwT3JQYXJjZWwsIFNLSVBfQkVDQVVTRV9CUk9LRU4pO1xuICAgICAgICAgICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0cmFuc2Zvcm1FcnIoZXJyLCBhcHBPclBhcmNlbCwgU0tJUF9CRUNBVVNFX0JST0tFTik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1xuICBVUERBVElORyxcbiAgTU9VTlRFRCxcbiAgU0tJUF9CRUNBVVNFX0JST0tFTixcbiAgdG9OYW1lLFxuICBpc1BhcmNlbCxcbn0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAuaGVscGVycy5qc1wiO1xuaW1wb3J0IHtcbiAgdHJhbnNmb3JtRXJyLFxuICBmb3JtYXRFcnJvck1lc3NhZ2UsXG59IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLWVycm9ycy5qc1wiO1xuaW1wb3J0IHsgcmVhc29uYWJsZVRpbWUgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL3RpbWVvdXRzLmpzXCI7XG5pbXBvcnQgeyBhZGRQcm9maWxlRW50cnkgfSBmcm9tIFwiLi4vZGV2dG9vbHMvcHJvZmlsZXIuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvVXBkYXRlUHJvbWlzZShhcHBPclBhcmNlbCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgbGV0IHN0YXJ0VGltZSwgcHJvZmlsZUV2ZW50VHlwZTtcblxuICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgcHJvZmlsZUV2ZW50VHlwZSA9IGlzUGFyY2VsKGFwcE9yUGFyY2VsKSA/IFwicGFyY2VsXCIgOiBcImFwcGxpY2F0aW9uXCI7XG4gICAgICBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICBpZiAoYXBwT3JQYXJjZWwuc3RhdHVzICE9PSBNT1VOVEVEKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAgIDMyLFxuICAgICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICAgIGBDYW5ub3QgdXBkYXRlIHBhcmNlbCAnJHt0b05hbWUoXG4gICAgICAgICAgICAgIGFwcE9yUGFyY2VsXG4gICAgICAgICAgICApfScgYmVjYXVzZSBpdCBpcyBub3QgbW91bnRlZGAsXG4gICAgICAgICAgdG9OYW1lKGFwcE9yUGFyY2VsKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IFVQREFUSU5HO1xuXG4gICAgcmV0dXJuIHJlYXNvbmFibGVUaW1lKGFwcE9yUGFyY2VsLCBcInVwZGF0ZVwiKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBhcHBPclBhcmNlbC5zdGF0dXMgPSBNT1VOVEVEO1xuXG4gICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgIGFkZFByb2ZpbGVFbnRyeShcbiAgICAgICAgICAgIHByb2ZpbGVFdmVudFR5cGUsXG4gICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgXCJ1cGRhdGVcIixcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgcHJvZmlsZUV2ZW50VHlwZSxcbiAgICAgICAgICAgIHRvTmFtZShhcHBPclBhcmNlbCksXG4gICAgICAgICAgICBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyB0cmFuc2Zvcm1FcnIoZXJyLCBhcHBPclBhcmNlbCwgU0tJUF9CRUNBVVNFX0JST0tFTik7XG4gICAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1xuICB2YWxpZExpZmVjeWNsZUZuLFxuICBmbGF0dGVuRm5BcnJheSxcbn0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvbGlmZWN5Y2xlLmhlbHBlcnMuanNcIjtcbmltcG9ydCB7XG4gIE5PVF9CT09UU1RSQVBQRUQsXG4gIE5PVF9NT1VOVEVELFxuICBNT1VOVEVELFxuICBMT0FESU5HX1NPVVJDRV9DT0RFLFxuICBTS0lQX0JFQ0FVU0VfQlJPS0VOLFxuICB0b05hbWUsXG59IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLmhlbHBlcnMuanNcIjtcbmltcG9ydCB7IHRvQm9vdHN0cmFwUHJvbWlzZSB9IGZyb20gXCIuLi9saWZlY3ljbGVzL2Jvb3RzdHJhcC5qc1wiO1xuaW1wb3J0IHsgdG9Nb3VudFByb21pc2UgfSBmcm9tIFwiLi4vbGlmZWN5Y2xlcy9tb3VudC5qc1wiO1xuaW1wb3J0IHsgdG9VcGRhdGVQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvdXBkYXRlLmpzXCI7XG5pbXBvcnQgeyB0b1VubW91bnRQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvdW5tb3VudC5qc1wiO1xuaW1wb3J0IHsgZW5zdXJlVmFsaWRBcHBUaW1lb3V0cyB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvdGltZW91dHMuanNcIjtcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLWVycm9ycy5qc1wiO1xuXG5sZXQgcGFyY2VsQ291bnQgPSAwO1xuY29uc3Qgcm9vdFBhcmNlbHMgPSB7IHBhcmNlbHM6IHt9IH07XG5cbi8vIFRoaXMgaXMgYSBwdWJsaWMgYXBpLCBleHBvcnRlZCB0byB1c2VycyBvZiBzaW5nbGUtc3BhXG5leHBvcnQgZnVuY3Rpb24gbW91bnRSb290UGFyY2VsKCkge1xuICByZXR1cm4gbW91bnRQYXJjZWwuYXBwbHkocm9vdFBhcmNlbHMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VudFBhcmNlbChjb25maWcsIGN1c3RvbVByb3BzKSB7XG4gIGNvbnN0IG93bmluZ0FwcE9yUGFyY2VsID0gdGhpcztcblxuICAvLyBWYWxpZGF0ZSBpbnB1dHNcbiAgaWYgKCFjb25maWcgfHwgKHR5cGVvZiBjb25maWcgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZyAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgXCJDYW5ub3QgbW91bnQgcGFyY2VsIHdpdGhvdXQgYSBjb25maWcgb2JqZWN0IG9yIGNvbmZpZyBsb2FkaW5nIGZ1bmN0aW9uXCJcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5uYW1lICYmIHR5cGVvZiBjb25maWcubmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAzLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgYFBhcmNlbCBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIGlmIHByb3ZpZGVkLiBXYXMgZ2l2ZW4gJHt0eXBlb2YgY29uZmlnLm5hbWV9YCxcbiAgICAgICAgdHlwZW9mIGNvbmZpZy5uYW1lXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGlkID0gcGFyY2VsQ291bnQrKztcbiAgbGV0IG5hbWUgPSBjb25maWcubmFtZSB8fCBgcGFyY2VsLSR7aWR9YDtcblxuICBpZiAodHlwZW9mIGN1c3RvbVByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDQsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBgUGFyY2VsICR7bmFtZX0gaGFzIGludmFsaWQgY3VzdG9tUHJvcHMgLS0gbXVzdCBiZSBhbiBvYmplY3QgYnV0IHdhcyBnaXZlbiAke3R5cGVvZiBjdXN0b21Qcm9wc31gLFxuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlb2YgY3VzdG9tUHJvcHNcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgaWYgKCFjdXN0b21Qcm9wcy5kb21FbGVtZW50KSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDUsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBgUGFyY2VsICR7bmFtZX0gY2Fubm90IGJlIG1vdW50ZWQgd2l0aG91dCBhIGRvbUVsZW1lbnQgcHJvdmlkZWQgYXMgYSBwcm9wYCxcbiAgICAgICAgbmFtZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBjb25zdCBwYXNzZWRDb25maWdMb2FkaW5nRnVuY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCI7XG4gIGNvbnN0IGNvbmZpZ0xvYWRpbmdGdW5jdGlvbiA9IHBhc3NlZENvbmZpZ0xvYWRpbmdGdW5jdGlvblxuICAgID8gY29uZmlnXG4gICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAvLyBJbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICBjb25zdCBwYXJjZWwgPSB7XG4gICAgaWQsXG4gICAgcGFyY2Vsczoge30sXG4gICAgc3RhdHVzOiBwYXNzZWRDb25maWdMb2FkaW5nRnVuY3Rpb25cbiAgICAgID8gTE9BRElOR19TT1VSQ0VfQ09ERVxuICAgICAgOiBOT1RfQk9PVFNUUkFQUEVELFxuICAgIGN1c3RvbVByb3BzLFxuICAgIHBhcmVudE5hbWU6IHRvTmFtZShvd25pbmdBcHBPclBhcmNlbCksXG4gICAgdW5tb3VudFRoaXNQYXJjZWwoKSB7XG4gICAgICByZXR1cm4gbW91bnRQcm9taXNlXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAocGFyY2VsLnN0YXR1cyAhPT0gTU9VTlRFRCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICAgICAgICAgIGBDYW5ub3QgdW5tb3VudCBwYXJjZWwgJyR7bmFtZX0nIC0tIGl0IGlzIGluIGEgJHtwYXJjZWwuc3RhdHVzfSBzdGF0dXNgLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGFyY2VsLnN0YXR1c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9Vbm1vdW50UHJvbWlzZShwYXJjZWwsIHRydWUpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICBpZiAocGFyY2VsLnBhcmVudE5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvd25pbmdBcHBPclBhcmNlbC5wYXJjZWxzW3BhcmNlbC5pZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICByZXNvbHZlVW5tb3VudCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHBhcmNlbC5zdGF0dXMgPSBTS0lQX0JFQ0FVU0VfQlJPS0VOO1xuICAgICAgICAgIHJlamVjdFVubW91bnQoZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gIH07XG5cbiAgLy8gV2UgcmV0dXJuIGFuIGV4dGVybmFsIHJlcHJlc2VudGF0aW9uXG4gIGxldCBleHRlcm5hbFJlcHJlc2VudGF0aW9uO1xuXG4gIC8vIEFkZCB0byBvd25pbmcgYXBwIG9yIHBhcmNlbFxuICBvd25pbmdBcHBPclBhcmNlbC5wYXJjZWxzW2lkXSA9IHBhcmNlbDtcblxuICBsZXQgbG9hZFByb21pc2UgPSBjb25maWdMb2FkaW5nRnVuY3Rpb24oKTtcblxuICBpZiAoIWxvYWRQcm9taXNlIHx8IHR5cGVvZiBsb2FkUHJvbWlzZS50aGVuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgNyxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBXaGVuIG1vdW50aW5nIGEgcGFyY2VsLCB0aGUgY29uZmlnIGxvYWRpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyY2VsIGNvbmZpZ2BcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgbG9hZFByb21pc2UgPSBsb2FkUHJvbWlzZS50aGVuKChjb25maWcpID0+IHtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICA4LFxuICAgICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICAgIGBXaGVuIG1vdW50aW5nIGEgcGFyY2VsLCB0aGUgY29uZmlnIGxvYWRpbmcgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlIHRoYXQgZGlkIG5vdCByZXNvbHZlIHdpdGggYSBwYXJjZWwgY29uZmlnYFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIG5hbWUgPSBjb25maWcubmFtZSB8fCBgcGFyY2VsLSR7aWR9YDtcblxuICAgIGlmIChcbiAgICAgIC8vIEVTIE1vZHVsZSBvYmplY3RzIGRvbid0IGhhdmUgdGhlIG9iamVjdCBwcm90b3R5cGVcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwiYm9vdHN0cmFwXCIpICYmXG4gICAgICAhdmFsaWRMaWZlY3ljbGVGbihjb25maWcuYm9vdHN0cmFwKVxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICA5LFxuICAgICAgICAgIF9fREVWX18gJiYgYFBhcmNlbCAke25hbWV9IHByb3ZpZGVkIGFuIGludmFsaWQgYm9vdHN0cmFwIGZ1bmN0aW9uYCxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZExpZmVjeWNsZUZuKGNvbmZpZy5tb3VudCkpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgMTAsXG4gICAgICAgICAgX19ERVZfXyAmJiBgUGFyY2VsICR7bmFtZX0gbXVzdCBoYXZlIGEgdmFsaWQgbW91bnQgZnVuY3Rpb25gLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkTGlmZWN5Y2xlRm4oY29uZmlnLnVubW91bnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAgIDExLFxuICAgICAgICAgIF9fREVWX18gJiYgYFBhcmNlbCAke25hbWV9IG11c3QgaGF2ZSBhIHZhbGlkIHVubW91bnQgZnVuY3Rpb25gLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnVwZGF0ZSAmJiAhdmFsaWRMaWZlY3ljbGVGbihjb25maWcudXBkYXRlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICAxMixcbiAgICAgICAgICBfX0RFVl9fICYmIGBQYXJjZWwgJHtuYW1lfSBwcm92aWRlZCBhbiBpbnZhbGlkIHVwZGF0ZSBmdW5jdGlvbmAsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGJvb3RzdHJhcCA9IGZsYXR0ZW5GbkFycmF5KGNvbmZpZywgXCJib290c3RyYXBcIik7XG4gICAgY29uc3QgbW91bnQgPSBmbGF0dGVuRm5BcnJheShjb25maWcsIFwibW91bnRcIik7XG4gICAgY29uc3QgdW5tb3VudCA9IGZsYXR0ZW5GbkFycmF5KGNvbmZpZywgXCJ1bm1vdW50XCIpO1xuXG4gICAgcGFyY2VsLnN0YXR1cyA9IE5PVF9CT09UU1RSQVBQRUQ7XG4gICAgcGFyY2VsLm5hbWUgPSBuYW1lO1xuICAgIHBhcmNlbC5ib290c3RyYXAgPSBib290c3RyYXA7XG4gICAgcGFyY2VsLm1vdW50ID0gbW91bnQ7XG4gICAgcGFyY2VsLnVubW91bnQgPSB1bm1vdW50O1xuICAgIHBhcmNlbC50aW1lb3V0cyA9IGVuc3VyZVZhbGlkQXBwVGltZW91dHMoY29uZmlnLnRpbWVvdXRzKTtcblxuICAgIGlmIChjb25maWcudXBkYXRlKSB7XG4gICAgICBwYXJjZWwudXBkYXRlID0gZmxhdHRlbkZuQXJyYXkoY29uZmlnLCBcInVwZGF0ZVwiKTtcbiAgICAgIGV4dGVybmFsUmVwcmVzZW50YXRpb24udXBkYXRlID0gZnVuY3Rpb24gKGN1c3RvbVByb3BzKSB7XG4gICAgICAgIHBhcmNlbC5jdXN0b21Qcm9wcyA9IGN1c3RvbVByb3BzO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlV2l0aG91dFJldHVyblZhbHVlKHRvVXBkYXRlUHJvbWlzZShwYXJjZWwpKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGFydCBib290c3RyYXBwaW5nIGFuZCBtb3VudGluZ1xuICAvLyBUaGUgLnRoZW4oKSBjYXVzZXMgdGhlIHdvcmsgdG8gYmUgcHV0IG9uIHRoZSBldmVudCBsb29wIGluc3RlYWQgb2YgaGFwcGVuaW5nIGltbWVkaWF0ZWx5XG4gIGNvbnN0IGJvb3RzdHJhcFByb21pc2UgPSBsb2FkUHJvbWlzZS50aGVuKCgpID0+XG4gICAgdG9Cb290c3RyYXBQcm9taXNlKHBhcmNlbCwgdHJ1ZSlcbiAgKTtcbiAgY29uc3QgbW91bnRQcm9taXNlID0gYm9vdHN0cmFwUHJvbWlzZS50aGVuKCgpID0+XG4gICAgdG9Nb3VudFByb21pc2UocGFyY2VsLCB0cnVlKVxuICApO1xuXG4gIGxldCByZXNvbHZlVW5tb3VudCwgcmVqZWN0VW5tb3VudDtcblxuICBjb25zdCB1bm1vdW50UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXNvbHZlVW5tb3VudCA9IHJlc29sdmU7XG4gICAgcmVqZWN0VW5tb3VudCA9IHJlamVjdDtcbiAgfSk7XG5cbiAgZXh0ZXJuYWxSZXByZXNlbnRhdGlvbiA9IHtcbiAgICBtb3VudCgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlV2l0aG91dFJldHVyblZhbHVlKFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAocGFyY2VsLnN0YXR1cyAhPT0gTk9UX01PVU5URUQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgMTMsXG4gICAgICAgICAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgICAgICAgICAgYENhbm5vdCBtb3VudCBwYXJjZWwgJyR7bmFtZX0nIC0tIGl0IGlzIGluIGEgJHtwYXJjZWwuc3RhdHVzfSBzdGF0dXNgLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGFyY2VsLnN0YXR1c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCB0byBvd25pbmcgYXBwIG9yIHBhcmNlbFxuICAgICAgICAgIG93bmluZ0FwcE9yUGFyY2VsLnBhcmNlbHNbaWRdID0gcGFyY2VsO1xuXG4gICAgICAgICAgcmV0dXJuIHRvTW91bnRQcm9taXNlKHBhcmNlbCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlV2l0aG91dFJldHVyblZhbHVlKHBhcmNlbC51bm1vdW50VGhpc1BhcmNlbCgpKTtcbiAgICB9LFxuICAgIGdldFN0YXR1cygpIHtcbiAgICAgIHJldHVybiBwYXJjZWwuc3RhdHVzO1xuICAgIH0sXG4gICAgbG9hZFByb21pc2U6IHByb21pc2VXaXRob3V0UmV0dXJuVmFsdWUobG9hZFByb21pc2UpLFxuICAgIGJvb3RzdHJhcFByb21pc2U6IHByb21pc2VXaXRob3V0UmV0dXJuVmFsdWUoYm9vdHN0cmFwUHJvbWlzZSksXG4gICAgbW91bnRQcm9taXNlOiBwcm9taXNlV2l0aG91dFJldHVyblZhbHVlKG1vdW50UHJvbWlzZSksXG4gICAgdW5tb3VudFByb21pc2U6IHByb21pc2VXaXRob3V0UmV0dXJuVmFsdWUodW5tb3VudFByb21pc2UpLFxuICB9O1xuXG4gIHJldHVybiBleHRlcm5hbFJlcHJlc2VudGF0aW9uO1xufVxuXG5mdW5jdGlvbiBwcm9taXNlV2l0aG91dFJldHVyblZhbHVlKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiBudWxsKTtcbn1cbiIsImltcG9ydCAqIGFzIHNpbmdsZVNwYSBmcm9tIFwiLi4vc2luZ2xlLXNwYS5qc1wiO1xuaW1wb3J0IHsgbW91bnRQYXJjZWwgfSBmcm9tIFwiLi4vcGFyY2Vscy9tb3VudC1wYXJjZWwuanNcIjtcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gXCIuLi91dGlscy9hc3NpZ24uanNcIjtcbmltcG9ydCB7IGlzUGFyY2VsLCB0b05hbWUgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BzKGFwcE9yUGFyY2VsKSB7XG4gIGNvbnN0IG5hbWUgPSB0b05hbWUoYXBwT3JQYXJjZWwpO1xuICBsZXQgY3VzdG9tUHJvcHMgPVxuICAgIHR5cGVvZiBhcHBPclBhcmNlbC5jdXN0b21Qcm9wcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGFwcE9yUGFyY2VsLmN1c3RvbVByb3BzKG5hbWUsIHdpbmRvdy5sb2NhdGlvbilcbiAgICAgIDogYXBwT3JQYXJjZWwuY3VzdG9tUHJvcHM7XG4gIGlmIChcbiAgICB0eXBlb2YgY3VzdG9tUHJvcHMgIT09IFwib2JqZWN0XCIgfHxcbiAgICBjdXN0b21Qcm9wcyA9PT0gbnVsbCB8fFxuICAgIEFycmF5LmlzQXJyYXkoY3VzdG9tUHJvcHMpXG4gICkge1xuICAgIGN1c3RvbVByb3BzID0ge307XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICA0MCxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBzaW5nbGUtc3BhOiAke25hbWV9J3MgY3VzdG9tUHJvcHMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZCAke2N1c3RvbVByb3BzfWBcbiAgICAgICksXG4gICAgICBuYW1lLFxuICAgICAgY3VzdG9tUHJvcHNcbiAgICApO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGFzc2lnbih7fSwgY3VzdG9tUHJvcHMsIHtcbiAgICBuYW1lLFxuICAgIG1vdW50UGFyY2VsOiBtb3VudFBhcmNlbC5iaW5kKGFwcE9yUGFyY2VsKSxcbiAgICBzaW5nbGVTcGEsXG4gIH0pO1xuXG4gIGlmIChpc1BhcmNlbChhcHBPclBhcmNlbCkpIHtcbiAgICByZXN1bHQudW5tb3VudFNlbGYgPSBhcHBPclBhcmNlbC51bm1vdW50VGhpc1BhcmNlbDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tIFwiLi4vdXRpbHMvYXNzaWduXCI7XG5pbXBvcnQgeyBnZXRQcm9wcyB9IGZyb20gXCIuLi9saWZlY3ljbGVzL3Byb3AuaGVscGVyc1wiO1xuaW1wb3J0IHsgb2JqZWN0VHlwZSwgdG9OYW1lIH0gZnJvbSBcIi4vYXBwLmhlbHBlcnNcIjtcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gXCIuL2FwcC1lcnJvcnNcIjtcblxuY29uc3QgZGVmYXVsdFdhcm5pbmdNaWxsaXMgPSAxMDAwO1xuXG5jb25zdCBnbG9iYWxUaW1lb3V0Q29uZmlnID0ge1xuICBib290c3RyYXA6IHtcbiAgICBtaWxsaXM6IDQwMDAsXG4gICAgZGllT25UaW1lb3V0OiBmYWxzZSxcbiAgICB3YXJuaW5nTWlsbGlzOiBkZWZhdWx0V2FybmluZ01pbGxpcyxcbiAgfSxcbiAgbW91bnQ6IHtcbiAgICBtaWxsaXM6IDMwMDAsXG4gICAgZGllT25UaW1lb3V0OiBmYWxzZSxcbiAgICB3YXJuaW5nTWlsbGlzOiBkZWZhdWx0V2FybmluZ01pbGxpcyxcbiAgfSxcbiAgdW5tb3VudDoge1xuICAgIG1pbGxpczogMzAwMCxcbiAgICBkaWVPblRpbWVvdXQ6IGZhbHNlLFxuICAgIHdhcm5pbmdNaWxsaXM6IGRlZmF1bHRXYXJuaW5nTWlsbGlzLFxuICB9LFxuICB1bmxvYWQ6IHtcbiAgICBtaWxsaXM6IDMwMDAsXG4gICAgZGllT25UaW1lb3V0OiBmYWxzZSxcbiAgICB3YXJuaW5nTWlsbGlzOiBkZWZhdWx0V2FybmluZ01pbGxpcyxcbiAgfSxcbiAgdXBkYXRlOiB7XG4gICAgbWlsbGlzOiAzMDAwLFxuICAgIGRpZU9uVGltZW91dDogZmFsc2UsXG4gICAgd2FybmluZ01pbGxpczogZGVmYXVsdFdhcm5pbmdNaWxsaXMsXG4gIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0Qm9vdHN0cmFwTWF4VGltZSh0aW1lLCBkaWVPblRpbWVvdXQsIHdhcm5pbmdNaWxsaXMpIHtcbiAgaWYgKHR5cGVvZiB0aW1lICE9PSBcIm51bWJlclwiIHx8IHRpbWUgPD0gMCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAxNixcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBib290c3RyYXAgbWF4IHRpbWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc2BcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2xvYmFsVGltZW91dENvbmZpZy5ib290c3RyYXAgPSB7XG4gICAgbWlsbGlzOiB0aW1lLFxuICAgIGRpZU9uVGltZW91dCxcbiAgICB3YXJuaW5nTWlsbGlzOiB3YXJuaW5nTWlsbGlzIHx8IGRlZmF1bHRXYXJuaW5nTWlsbGlzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TW91bnRNYXhUaW1lKHRpbWUsIGRpZU9uVGltZW91dCwgd2FybmluZ01pbGxpcykge1xuICBpZiAodHlwZW9mIHRpbWUgIT09IFwibnVtYmVyXCIgfHwgdGltZSA8PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDE3LFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgYG1vdW50IG1heCB0aW1lIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG51bWJlciBvZiBtaWxsaXNlY29uZHNgXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGdsb2JhbFRpbWVvdXRDb25maWcubW91bnQgPSB7XG4gICAgbWlsbGlzOiB0aW1lLFxuICAgIGRpZU9uVGltZW91dCxcbiAgICB3YXJuaW5nTWlsbGlzOiB3YXJuaW5nTWlsbGlzIHx8IGRlZmF1bHRXYXJuaW5nTWlsbGlzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VW5tb3VudE1heFRpbWUodGltZSwgZGllT25UaW1lb3V0LCB3YXJuaW5nTWlsbGlzKSB7XG4gIGlmICh0eXBlb2YgdGltZSAhPT0gXCJudW1iZXJcIiB8fCB0aW1lIDw9IDApIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMTgsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBgdW5tb3VudCBtYXggdGltZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzYFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBnbG9iYWxUaW1lb3V0Q29uZmlnLnVubW91bnQgPSB7XG4gICAgbWlsbGlzOiB0aW1lLFxuICAgIGRpZU9uVGltZW91dCxcbiAgICB3YXJuaW5nTWlsbGlzOiB3YXJuaW5nTWlsbGlzIHx8IGRlZmF1bHRXYXJuaW5nTWlsbGlzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VW5sb2FkTWF4VGltZSh0aW1lLCBkaWVPblRpbWVvdXQsIHdhcm5pbmdNaWxsaXMpIHtcbiAgaWYgKHR5cGVvZiB0aW1lICE9PSBcIm51bWJlclwiIHx8IHRpbWUgPD0gMCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAxOSxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGB1bmxvYWQgbWF4IHRpbWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc2BcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2xvYmFsVGltZW91dENvbmZpZy51bmxvYWQgPSB7XG4gICAgbWlsbGlzOiB0aW1lLFxuICAgIGRpZU9uVGltZW91dCxcbiAgICB3YXJuaW5nTWlsbGlzOiB3YXJuaW5nTWlsbGlzIHx8IGRlZmF1bHRXYXJuaW5nTWlsbGlzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhc29uYWJsZVRpbWUoYXBwT3JQYXJjZWwsIGxpZmVjeWNsZSkge1xuICBjb25zdCB0aW1lb3V0Q29uZmlnID0gYXBwT3JQYXJjZWwudGltZW91dHNbbGlmZWN5Y2xlXTtcbiAgY29uc3Qgd2FybmluZ1BlcmlvZCA9IHRpbWVvdXRDb25maWcud2FybmluZ01pbGxpcztcbiAgY29uc3QgdHlwZSA9IG9iamVjdFR5cGUoYXBwT3JQYXJjZWwpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcblxuICAgIGFwcE9yUGFyY2VsW2xpZmVjeWNsZV0oZ2V0UHJvcHMoYXBwT3JQYXJjZWwpKVxuICAgICAgLnRoZW4oKHZhbCkgPT4ge1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUodmFsKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKHZhbCkgPT4ge1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdCh2YWwpO1xuICAgICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IG1heWJlVGltaW5nT3V0KDEpLCB3YXJuaW5nUGVyaW9kKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IG1heWJlVGltaW5nT3V0KHRydWUpLCB0aW1lb3V0Q29uZmlnLm1pbGxpcyk7XG5cbiAgICBjb25zdCBlcnJNc2cgPSBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAzMSxcbiAgICAgIF9fREVWX18gJiZcbiAgICAgICAgYExpZmVjeWNsZSBmdW5jdGlvbiAke2xpZmVjeWNsZX0gZm9yICR7dHlwZX0gJHt0b05hbWUoXG4gICAgICAgICAgYXBwT3JQYXJjZWxcbiAgICAgICAgKX0gbGlmZWN5Y2xlIGRpZCBub3QgcmVzb2x2ZSBvciByZWplY3QgZm9yICR7dGltZW91dENvbmZpZy5taWxsaXN9IG1zLmAsXG4gICAgICBsaWZlY3ljbGUsXG4gICAgICB0eXBlLFxuICAgICAgdG9OYW1lKGFwcE9yUGFyY2VsKSxcbiAgICAgIHRpbWVvdXRDb25maWcubWlsbGlzXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVGltaW5nT3V0KHNob3VsZEVycm9yKSB7XG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgIGlmIChzaG91bGRFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aW1lb3V0Q29uZmlnLmRpZU9uVGltZW91dCkge1xuICAgICAgICAgICAgcmVqZWN0KEVycm9yKGVyck1zZykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAvL2Rvbid0IHJlc29sdmUgb3IgcmVqZWN0LCB3ZSdyZSB3YWl0aW5nIHRoaXMgb25lIG91dFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3JlZCkge1xuICAgICAgICAgIGNvbnN0IG51bVdhcm5pbmdzID0gc2hvdWxkRXJyb3I7XG4gICAgICAgICAgY29uc3QgbnVtTWlsbGlzID0gbnVtV2FybmluZ3MgKiB3YXJuaW5nUGVyaW9kO1xuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJNc2cpO1xuICAgICAgICAgIGlmIChudW1NaWxsaXMgKyB3YXJuaW5nUGVyaW9kIDwgdGltZW91dENvbmZpZy5taWxsaXMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWF5YmVUaW1pbmdPdXQobnVtV2FybmluZ3MgKyAxKSwgd2FybmluZ1BlcmlvZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbGlkQXBwVGltZW91dHModGltZW91dHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgZm9yIChsZXQga2V5IGluIGdsb2JhbFRpbWVvdXRDb25maWcpIHtcbiAgICByZXN1bHRba2V5XSA9IGFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgZ2xvYmFsVGltZW91dENvbmZpZ1trZXldLFxuICAgICAgKHRpbWVvdXRzICYmIHRpbWVvdXRzW2tleV0pIHx8IHt9XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge1xuICBMT0FEX0VSUk9SLFxuICBOT1RfQk9PVFNUUkFQUEVELFxuICBMT0FESU5HX1NPVVJDRV9DT0RFLFxuICBTS0lQX0JFQ0FVU0VfQlJPS0VOLFxuICBOT1RfTE9BREVELFxuICBvYmplY3RUeXBlLFxuICB0b05hbWUsXG59IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLmhlbHBlcnMuanNcIjtcbmltcG9ydCB7IGVuc3VyZVZhbGlkQXBwVGltZW91dHMgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL3RpbWVvdXRzLmpzXCI7XG5pbXBvcnQge1xuICBoYW5kbGVBcHBFcnJvcixcbiAgZm9ybWF0RXJyb3JNZXNzYWdlLFxufSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcbmltcG9ydCB7XG4gIGZsYXR0ZW5GbkFycmF5LFxuICBzbWVsbHNMaWtlQVByb21pc2UsXG4gIHZhbGlkTGlmZWN5Y2xlRm4sXG59IGZyb20gXCIuL2xpZmVjeWNsZS5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBnZXRQcm9wcyB9IGZyb20gXCIuL3Byb3AuaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSBcIi4uL3V0aWxzL2Fzc2lnbi5qc1wiO1xuaW1wb3J0IHsgYWRkUHJvZmlsZUVudHJ5IH0gZnJvbSBcIi4uL2RldnRvb2xzL3Byb2ZpbGVyLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0xvYWRQcm9taXNlKGFwcE9yUGFyY2VsKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoYXBwT3JQYXJjZWwubG9hZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBhcHBPclBhcmNlbC5sb2FkUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhcHBPclBhcmNlbC5zdGF0dXMgIT09IE5PVF9MT0FERUQgJiZcbiAgICAgIGFwcE9yUGFyY2VsLnN0YXR1cyAhPT0gTE9BRF9FUlJPUlxuICAgICkge1xuICAgICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICAgIH1cblxuICAgIGxldCBzdGFydFRpbWU7XG5cbiAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGFwcE9yUGFyY2VsLnN0YXR1cyA9IExPQURJTkdfU09VUkNFX0NPREU7XG5cbiAgICBsZXQgYXBwT3B0cywgaXNVc2VyRXJyO1xuXG4gICAgcmV0dXJuIChhcHBPclBhcmNlbC5sb2FkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gYXBwT3JQYXJjZWwubG9hZEFwcChnZXRQcm9wcyhhcHBPclBhcmNlbCkpO1xuICAgICAgICBpZiAoIXNtZWxsc0xpa2VBUHJvbWlzZShsb2FkUHJvbWlzZSkpIHtcbiAgICAgICAgICAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoaXMgZXJyb3IgbWVzc2FnZSBpbnNpZGUgb2YgdGhlIGhhbmRsZUFwcEVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAgaXNVc2VyRXJyID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgMzMsXG4gICAgICAgICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICAgICAgICBgc2luZ2xlLXNwYSBsb2FkaW5nIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGEgcHJvbWlzZS4gQ2hlY2sgdGhlIHNlY29uZCBhcmd1bWVudCB0byByZWdpc3RlckFwcGxpY2F0aW9uKCcke3RvTmFtZShcbiAgICAgICAgICAgICAgICAgIGFwcE9yUGFyY2VsXG4gICAgICAgICAgICAgICAgKX0nLCBsb2FkaW5nRnVuY3Rpb24sIGFjdGl2aXR5RnVuY3Rpb24pYCxcbiAgICAgICAgICAgICAgdG9OYW1lKGFwcE9yUGFyY2VsKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRQcm9taXNlLnRoZW4oKHZhbCkgPT4ge1xuICAgICAgICAgIGFwcE9yUGFyY2VsLmxvYWRFcnJvclRpbWUgPSBudWxsO1xuXG4gICAgICAgICAgYXBwT3B0cyA9IHZhbDtcblxuICAgICAgICAgIGxldCB2YWxpZGF0aW9uRXJyTWVzc2FnZSwgdmFsaWRhdGlvbkVyckNvZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGFwcE9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJDb2RlID0gMzQ7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyTWVzc2FnZSA9IGBkb2VzIG5vdCBleHBvcnQgYW55dGhpbmdgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEVTIE1vZHVsZXMgZG9uJ3QgaGF2ZSB0aGUgT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcE9wdHMsIFwiYm9vdHN0cmFwXCIpICYmXG4gICAgICAgICAgICAhdmFsaWRMaWZlY3ljbGVGbihhcHBPcHRzLmJvb3RzdHJhcClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJDb2RlID0gMzU7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyTWVzc2FnZSA9IGBkb2VzIG5vdCBleHBvcnQgYSB2YWxpZCBib290c3RyYXAgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXZhbGlkTGlmZWN5Y2xlRm4oYXBwT3B0cy5tb3VudCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJDb2RlID0gMzY7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyTWVzc2FnZSA9IGBkb2VzIG5vdCBleHBvcnQgYSBtb3VudCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnNgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdmFsaWRMaWZlY3ljbGVGbihhcHBPcHRzLnVubW91bnQpKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyQ29kZSA9IDM3O1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVyck1lc3NhZ2UgPSBgZG9lcyBub3QgZXhwb3J0IGEgdW5tb3VudCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnNgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmplY3RUeXBlKGFwcE9wdHMpO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJDb2RlKSB7XG4gICAgICAgICAgICBsZXQgYXBwT3B0c1N0cjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFwcE9wdHNTdHIgPSBKU09OLnN0cmluZ2lmeShhcHBPcHRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyQ29kZSxcbiAgICAgICAgICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgICAgICAgICBgVGhlIGxvYWRpbmcgZnVuY3Rpb24gZm9yIHNpbmdsZS1zcGEgJHt0eXBlfSAnJHt0b05hbWUoXG4gICAgICAgICAgICAgICAgICAgIGFwcE9yUGFyY2VsXG4gICAgICAgICAgICAgICAgICApfScgcmVzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nLCB3aGljaCBkb2VzIG5vdCBoYXZlIGJvb3RzdHJhcCwgbW91bnQsIGFuZCB1bm1vdW50IGZ1bmN0aW9uc2AsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgICAgIGFwcE9wdHNTdHJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgYXBwT3B0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhbmRsZUFwcEVycm9yKFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyTWVzc2FnZSxcbiAgICAgICAgICAgICAgYXBwT3JQYXJjZWwsXG4gICAgICAgICAgICAgIFNLSVBfQkVDQVVTRV9CUk9LRU5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFwcE9wdHMuZGV2dG9vbHMgJiYgYXBwT3B0cy5kZXZ0b29scy5vdmVybGF5cykge1xuICAgICAgICAgICAgYXBwT3JQYXJjZWwuZGV2dG9vbHMub3ZlcmxheXMgPSBhc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICBhcHBPclBhcmNlbC5kZXZ0b29scy5vdmVybGF5cyxcbiAgICAgICAgICAgICAgYXBwT3B0cy5kZXZ0b29scy5vdmVybGF5c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcHBPclBhcmNlbC5zdGF0dXMgPSBOT1RfQk9PVFNUUkFQUEVEO1xuICAgICAgICAgIGFwcE9yUGFyY2VsLmJvb3RzdHJhcCA9IGZsYXR0ZW5GbkFycmF5KGFwcE9wdHMsIFwiYm9vdHN0cmFwXCIpO1xuICAgICAgICAgIGFwcE9yUGFyY2VsLm1vdW50ID0gZmxhdHRlbkZuQXJyYXkoYXBwT3B0cywgXCJtb3VudFwiKTtcbiAgICAgICAgICBhcHBPclBhcmNlbC51bm1vdW50ID0gZmxhdHRlbkZuQXJyYXkoYXBwT3B0cywgXCJ1bm1vdW50XCIpO1xuICAgICAgICAgIGFwcE9yUGFyY2VsLnVubG9hZCA9IGZsYXR0ZW5GbkFycmF5KGFwcE9wdHMsIFwidW5sb2FkXCIpO1xuICAgICAgICAgIGFwcE9yUGFyY2VsLnRpbWVvdXRzID0gZW5zdXJlVmFsaWRBcHBUaW1lb3V0cyhhcHBPcHRzLnRpbWVvdXRzKTtcblxuICAgICAgICAgIGRlbGV0ZSBhcHBPclBhcmNlbC5sb2FkUHJvbWlzZTtcblxuICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uXCIsXG4gICAgICAgICAgICAgIHRvTmFtZShhcHBPclBhcmNlbCksXG4gICAgICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcHBPclBhcmNlbDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgZGVsZXRlIGFwcE9yUGFyY2VsLmxvYWRQcm9taXNlO1xuXG4gICAgICAgIGxldCBuZXdTdGF0dXM7XG4gICAgICAgIGlmIChpc1VzZXJFcnIpIHtcbiAgICAgICAgICBuZXdTdGF0dXMgPSBTS0lQX0JFQ0FVU0VfQlJPS0VOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1N0YXR1cyA9IExPQURfRVJST1I7XG4gICAgICAgICAgYXBwT3JQYXJjZWwubG9hZEVycm9yVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUFwcEVycm9yKGVyciwgYXBwT3JQYXJjZWwsIG5ld1N0YXR1cyk7XG5cbiAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgXCJhcHBsaWNhdGlvblwiLFxuICAgICAgICAgICAgdG9OYW1lKGFwcE9yUGFyY2VsKSxcbiAgICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgICB9KSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGNvbnN0IGlzSW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiIsImltcG9ydCB7IHJlcm91dGUgfSBmcm9tIFwiLi9yZXJvdXRlLmpzXCI7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSBcIi4uL3V0aWxzL2ZpbmQuanNcIjtcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwLWVycm9ycy5qc1wiO1xuaW1wb3J0IHsgaXNJbkJyb3dzZXIgfSBmcm9tIFwiLi4vdXRpbHMvcnVudGltZS1lbnZpcm9ubWVudC5qc1wiO1xuXG4vKiBXZSBjYXB0dXJlIG5hdmlnYXRpb24gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgd2UgY2FuIG1ha2Ugc3VyZVxuICogdGhhdCBhcHBsaWNhdGlvbiBuYXZpZ2F0aW9uIGxpc3RlbmVycyBhcmUgbm90IGNhbGxlZCB1bnRpbFxuICogc2luZ2xlLXNwYSBoYXMgZW5zdXJlZCB0aGF0IHRoZSBjb3JyZWN0IGFwcGxpY2F0aW9ucyBhcmVcbiAqIHVubW91bnRlZCBhbmQgbW91bnRlZC5cbiAqL1xuY29uc3QgY2FwdHVyZWRFdmVudExpc3RlbmVycyA9IHtcbiAgaGFzaGNoYW5nZTogW10sXG4gIHBvcHN0YXRlOiBbXSxcbn07XG5cbmV4cG9ydCBjb25zdCByb3V0aW5nRXZlbnRzTGlzdGVuaW5nVG8gPSBbXCJoYXNoY2hhbmdlXCIsIFwicG9wc3RhdGVcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZVRvVXJsKG9iaikge1xuICBsZXQgdXJsO1xuICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG9iajtcbiAgfSBlbHNlIGlmICh0aGlzICYmIHRoaXMuaHJlZikge1xuICAgIHVybCA9IHRoaXMuaHJlZjtcbiAgfSBlbHNlIGlmIChcbiAgICBvYmogJiZcbiAgICBvYmouY3VycmVudFRhcmdldCAmJlxuICAgIG9iai5jdXJyZW50VGFyZ2V0LmhyZWYgJiZcbiAgICBvYmoucHJldmVudERlZmF1bHRcbiAgKSB7XG4gICAgdXJsID0gb2JqLmN1cnJlbnRUYXJnZXQuaHJlZjtcbiAgICBvYmoucHJldmVudERlZmF1bHQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMTQsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBgc2luZ2xlU3BhTmF2aWdhdGUvbmF2aWdhdGVUb1VybCBtdXN0IGJlIGVpdGhlciBjYWxsZWQgd2l0aCBhIHN0cmluZyB1cmwsIHdpdGggYW4gPGE+IHRhZyBhcyBpdHMgY29udGV4dCwgb3Igd2l0aCBhbiBldmVudCB3aG9zZSBjdXJyZW50VGFyZ2V0IGlzIGFuIDxhPiB0YWdgXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnQgPSBwYXJzZVVyaSh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gcGFyc2VVcmkodXJsKTtcblxuICBpZiAodXJsLmluZGV4T2YoXCIjXCIpID09PSAwKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBkZXN0aW5hdGlvbi5oYXNoO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQuaG9zdCAhPT0gZGVzdGluYXRpb24uaG9zdCAmJiBkZXN0aW5hdGlvbi5ob3N0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkJBQkVMX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybiB7IHdvdWxkSGF2ZVJlbG9hZGVkVGhlUGFnZTogdHJ1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgZGVzdGluYXRpb24ucGF0aG5hbWUgPT09IGN1cnJlbnQucGF0aG5hbWUgJiZcbiAgICBkZXN0aW5hdGlvbi5zZWFyY2ggPT09IGN1cnJlbnQuc2VhcmNoXG4gICkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZGVzdGluYXRpb24uaGFzaDtcbiAgfSBlbHNlIHtcbiAgICAvLyBkaWZmZXJlbnQgcGF0aCwgaG9zdCwgb3IgcXVlcnkgcGFyYW1zXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHVybCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxDYXB0dXJlZEV2ZW50TGlzdGVuZXJzKGV2ZW50QXJndW1lbnRzKSB7XG4gIGlmIChldmVudEFyZ3VtZW50cykge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50QXJndW1lbnRzWzBdLnR5cGU7XG4gICAgaWYgKHJvdXRpbmdFdmVudHNMaXN0ZW5pbmdUby5pbmRleE9mKGV2ZW50VHlwZSkgPj0gMCkge1xuICAgICAgY2FwdHVyZWRFdmVudExpc3RlbmVyc1tldmVudFR5cGVdLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIHRocm93biBieSBhcHBsaWNhdGlvbiBldmVudCBsaXN0ZW5lciBzaG91bGQgbm90IGJyZWFrIHNpbmdsZS1zcGEgZG93bi5cbiAgICAgICAgICAvLyBKdXN0IGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL3NpbmdsZS1zcGEvc2luZ2xlLXNwYS9ibG9iLzg1ZjUwNDJkZmY5NjBlNDA5MzZmM2E1MDY5ZDU2ZmM5NDc3ZmFjMDQvc3JjL25hdmlnYXRpb24vcmVyb3V0ZS5qcyNMMTQwLUwxNDYgZGlkXG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnRBcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxubGV0IHVybFJlcm91dGVPbmx5O1xuXG5mdW5jdGlvbiB1cmxSZXJvdXRlKCkge1xuICByZXJvdXRlKFtdLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXRjaGVkVXBkYXRlU3RhdGUodXBkYXRlU3RhdGUsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB1cmxCZWZvcmUgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBjb25zdCByZXN1bHQgPSB1cGRhdGVTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNvbnN0IHVybEFmdGVyID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICBpZiAoIXVybFJlcm91dGVPbmx5IHx8IHVybEJlZm9yZSAhPT0gdXJsQWZ0ZXIpIHtcbiAgICAgIC8vIGZpcmUgYW4gYXJ0aWZpY2lhbCBwb3BzdGF0ZSBldmVudCBzbyB0aGF0XG4gICAgICAvLyBzaW5nbGUtc3BhIGFwcGxpY2F0aW9ucyBrbm93IGFib3V0IHJvdXRpbmcgdGhhdFxuICAgICAgLy8gb2NjdXJzIGluIGEgZGlmZmVyZW50IGFwcGxpY2F0aW9uXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgY3JlYXRlUG9wU3RhdGVFdmVudCh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgbWV0aG9kTmFtZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9wU3RhdGVFdmVudChzdGF0ZSwgb3JpZ2luYWxNZXRob2ROYW1lKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEvaXNzdWVzLzIyNCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3NpbmdsZS1zcGEvc2luZ2xlLXNwYS1hbmd1bGFyL2lzc3Vlcy80OVxuICAvLyBXZSBuZWVkIGEgcG9wc3RhdGUgZXZlbnQgZXZlbiB0aG91Z2ggdGhlIGJyb3dzZXIgZG9lc24ndCBkbyBvbmUgYnkgZGVmYXVsdCB3aGVuIHlvdSBjYWxsIHJlcGxhY2VTdGF0ZSwgc28gdGhhdFxuICAvLyBhbGwgdGhlIGFwcGxpY2F0aW9ucyBjYW4gcmVyb3V0ZS4gV2UgZXhwbGljaXRseSBpZGVudGlmeSB0aGlzIGV4dHJhbmVvdXMgZXZlbnQgYnkgc2V0dGluZyBzaW5nbGVTcGE9dHJ1ZSBhbmRcbiAgLy8gc2luZ2xlU3BhVHJpZ2dlcj08cHVzaFN0YXRlfHJlcGxhY2VTdGF0ZT4gb24gdGhlIGV2ZW50IGluc3RhbmNlLlxuICBsZXQgZXZ0O1xuICB0cnkge1xuICAgIGV2dCA9IG5ldyBQb3BTdGF0ZUV2ZW50KFwicG9wc3RhdGVcIiwgeyBzdGF0ZSB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgMTEgY29tcGF0aWJpbGl0eSBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhL2lzc3Vlcy8yOTlcbiAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9vcGVuc3BlY3MvaWVfc3RhbmRhcmRzL21zLWh0bWw1ZS9iZDU2MGY0Ny1iMzQ5LTRkMmMtYmFhOC1mMTU2MGZiNDg5ZGRcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIlBvcFN0YXRlRXZlbnRcIik7XG4gICAgZXZ0LmluaXRQb3BTdGF0ZUV2ZW50KFwicG9wc3RhdGVcIiwgZmFsc2UsIGZhbHNlLCBzdGF0ZSk7XG4gIH1cbiAgZXZ0LnNpbmdsZVNwYSA9IHRydWU7XG4gIGV2dC5zaW5nbGVTcGFUcmlnZ2VyID0gb3JpZ2luYWxNZXRob2ROYW1lO1xuICByZXR1cm4gZXZ0O1xufVxuXG5leHBvcnQgbGV0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gbnVsbDtcblxubGV0IGhpc3RvcnlBcGlJc1BhdGNoZWQgPSBmYWxzZTtcblxuLy8gV2UgcGF0Y2ggdGhlIGhpc3RvcnkgQVBJIHNvIHNpbmdsZS1zcGEgaXMgbm90aWZpZWQgb2YgYWxsIGNhbGxzIHRvIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUuXG4vLyBXZSBwYXRjaCBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXIgc28gd2UgY2FuIGNhcHR1cmUgYWxsIHBvcHN0YXRlL2hhc2hjaGFuZ2UgZXZlbnQgbGlzdGVuZXJzLFxuLy8gYW5kIGRlbGF5IGNhbGxpbmcgdGhlbSB1bnRpbCBzaW5nbGUtc3BhIGhhcyBmaW5pc2hlZCBtb3VudGluZy91bm1vdW50aW5nIGFwcGxpY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoSGlzdG9yeUFwaShvcHRzKSB7XG4gIGlmIChoaXN0b3J5QXBpSXNQYXRjaGVkKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDQzLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgYHNpbmdsZS1zcGE6IHBhdGNoSGlzdG9yeUFwaSgpIHdhcyBjYWxsZWQgYWZ0ZXIgdGhlIGhpc3RvcnkgYXBpIHdhcyBhbHJlYWR5IHBhdGNoZWQuYFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvLyBUcnVlIGJ5IGRlZmF1bHQsIGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRoYXQgcmVkdWNlc1xuICAvLyB0aGUgbnVtYmVyIG9mIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzXG4gIHVybFJlcm91dGVPbmx5ID1cbiAgICBvcHRzICYmIG9wdHMuaGFzT3duUHJvcGVydHkoXCJ1cmxSZXJvdXRlT25seVwiKSA/IG9wdHMudXJsUmVyb3V0ZU9ubHkgOiB0cnVlO1xuXG4gIGhpc3RvcnlBcGlJc1BhdGNoZWQgPSB0cnVlO1xuXG4gIG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlO1xuXG4gIC8vIFdlIHdpbGwgdHJpZ2dlciBhbiBhcHAgY2hhbmdlIGZvciBhbnkgcm91dGluZyBldmVudHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCB1cmxSZXJvdXRlKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB1cmxSZXJvdXRlKTtcblxuICAvLyBNb25rZXlwYXRjaCBhZGRFdmVudExpc3RlbmVyIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSBjb3JyZWN0IHRpbWluZ1xuICBjb25zdCBvcmlnaW5hbEFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgY29uc3Qgb3JpZ2luYWxSZW1vdmVFdmVudExpc3RlbmVyID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcm91dGluZ0V2ZW50c0xpc3RlbmluZ1RvLmluZGV4T2YoZXZlbnROYW1lKSA+PSAwICYmXG4gICAgICAgICFmaW5kKGNhcHR1cmVkRXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSwgKGxpc3RlbmVyKSA9PiBsaXN0ZW5lciA9PT0gZm4pXG4gICAgICApIHtcbiAgICAgICAgY2FwdHVyZWRFdmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXJGbikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXJGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAocm91dGluZ0V2ZW50c0xpc3RlbmluZ1RvLmluZGV4T2YoZXZlbnROYW1lKSA+PSAwKSB7XG4gICAgICAgIGNhcHR1cmVkRXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGNhcHR1cmVkRXZlbnRMaXN0ZW5lcnNbXG4gICAgICAgICAgZXZlbnROYW1lXG4gICAgICAgIF0uZmlsdGVyKChmbikgPT4gZm4gIT09IGxpc3RlbmVyRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBwYXRjaGVkVXBkYXRlU3RhdGUoXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlLFxuICAgIFwicHVzaFN0YXRlXCJcbiAgKTtcbiAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gcGF0Y2hlZFVwZGF0ZVN0YXRlKFxuICAgIG9yaWdpbmFsUmVwbGFjZVN0YXRlLFxuICAgIFwicmVwbGFjZVN0YXRlXCJcbiAgKTtcbn1cblxuLy8gRGV0ZWN0IGlmIHNpbmdsZS1zcGEgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgb24gdGhlIHBhZ2UuXG4vLyBJZiBzbywgd2FybiBiZWNhdXNlIHRoaXMgY2FuIHJlc3VsdCBpbiBsb3RzIG9mIHByb2JsZW1zLCBpbmNsdWRpbmdcbi8vIGxvdHMgb2YgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgYW5kIHVuZXhwZWN0ZWQgcmVzdWx0cyBmb3Jcbi8vIGFwaXMgbGlrZSBnZXRBcHBOYW1lcygpLlxuaWYgKGlzSW5Ccm93c2VyKSB7XG4gIGlmICh3aW5kb3cuc2luZ2xlU3BhTmF2aWdhdGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDQxLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgXCJzaW5nbGUtc3BhIGhhcyBiZWVuIGxvYWRlZCB0d2ljZSBvbiB0aGUgcGFnZS4gVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXCJcbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8qIEZvciBjb252ZW5pZW5jZSBpbiBgb25jbGlja2AgYXR0cmlidXRlcywgd2UgZXhwb3NlIGEgZ2xvYmFsIGZ1bmN0aW9uIGZvciBuYXZpZ2F0aW5nIHRvXG4gICAgICogd2hhdGV2ZXIgYW4gPGE+IHRhZydzIGhyZWYgaXMuXG4gICAgICovXG4gICAgd2luZG93LnNpbmdsZVNwYU5hdmlnYXRlID0gbmF2aWdhdGVUb1VybDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVyaShzdHIpIHtcbiAgY29uc3QgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIGFuY2hvci5ocmVmID0gc3RyO1xuICByZXR1cm4gYW5jaG9yO1xufVxuIiwiaW1wb3J0IHsgcm91dGluZ0V2ZW50c0xpc3RlbmluZ1RvIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWV2ZW50cy5qc1wiO1xuXG5sZXQgaGFzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUpRdWVyeVN1cHBvcnQoalF1ZXJ5ID0gd2luZG93LmpRdWVyeSkge1xuICBpZiAoIWpRdWVyeSkge1xuICAgIGlmICh3aW5kb3cuJCAmJiB3aW5kb3cuJC5mbiAmJiB3aW5kb3cuJC5mbi5qcXVlcnkpIHtcbiAgICAgIGpRdWVyeSA9IHdpbmRvdy4kO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqUXVlcnkgJiYgIWhhc0luaXRpYWxpemVkKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxKUXVlcnlPbiA9IGpRdWVyeS5mbi5vbjtcbiAgICBjb25zdCBvcmlnaW5hbEpRdWVyeU9mZiA9IGpRdWVyeS5mbi5vZmY7XG5cbiAgICBqUXVlcnkuZm4ub24gPSBmdW5jdGlvbiAoZXZlbnRTdHJpbmcsIGZuKSB7XG4gICAgICByZXR1cm4gY2FwdHVyZVJvdXRpbmdFdmVudHMuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgb3JpZ2luYWxKUXVlcnlPbixcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIsXG4gICAgICAgIGV2ZW50U3RyaW5nLFxuICAgICAgICBmbixcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4ub2ZmID0gZnVuY3Rpb24gKGV2ZW50U3RyaW5nLCBmbikge1xuICAgICAgcmV0dXJuIGNhcHR1cmVSb3V0aW5nRXZlbnRzLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG9yaWdpbmFsSlF1ZXJ5T2ZmLFxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgZXZlbnRTdHJpbmcsXG4gICAgICAgIGZuLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGhhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlUm91dGluZ0V2ZW50cyhcbiAgb3JpZ2luYWxKUXVlcnlGdW5jdGlvbixcbiAgbmF0aXZlRnVuY3Rpb25Ub0NhbGwsXG4gIGV2ZW50U3RyaW5nLFxuICBmbixcbiAgb3JpZ2luYWxBcmdzXG4pIHtcbiAgaWYgKHR5cGVvZiBldmVudFN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBvcmlnaW5hbEpRdWVyeUZ1bmN0aW9uLmFwcGx5KHRoaXMsIG9yaWdpbmFsQXJncyk7XG4gIH1cblxuICBjb25zdCBldmVudE5hbWVzID0gZXZlbnRTdHJpbmcuc3BsaXQoL1xccysvKTtcbiAgZXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICBpZiAocm91dGluZ0V2ZW50c0xpc3RlbmluZ1RvLmluZGV4T2YoZXZlbnROYW1lKSA+PSAwKSB7XG4gICAgICBuYXRpdmVGdW5jdGlvblRvQ2FsbChldmVudE5hbWUsIGZuKTtcbiAgICAgIGV2ZW50U3RyaW5nID0gZXZlbnRTdHJpbmcucmVwbGFjZShldmVudE5hbWUsIFwiXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGV2ZW50U3RyaW5nLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcmlnaW5hbEpRdWVyeUZ1bmN0aW9uLmFwcGx5KHRoaXMsIG9yaWdpbmFsQXJncyk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIE5PVF9NT1VOVEVELFxuICBVTkxPQURJTkcsXG4gIE5PVF9MT0FERUQsXG4gIExPQURfRVJST1IsXG4gIFNLSVBfQkVDQVVTRV9CUk9LRU4sXG4gIHRvTmFtZSxcbn0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAuaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgaGFuZGxlQXBwRXJyb3IgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcbmltcG9ydCB7IHJlYXNvbmFibGVUaW1lIH0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy90aW1lb3V0cy5qc1wiO1xuaW1wb3J0IHsgYWRkUHJvZmlsZUVudHJ5IH0gZnJvbSBcIi4uL2RldnRvb2xzL3Byb2ZpbGVyLmpzXCI7XG5cbmNvbnN0IGFwcHNUb1VubG9hZCA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9VbmxvYWRQcm9taXNlKGFwcE9yUGFyY2VsKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBjb25zdCB1bmxvYWRJbmZvID0gYXBwc1RvVW5sb2FkW3RvTmFtZShhcHBPclBhcmNlbCldO1xuXG4gICAgaWYgKCF1bmxvYWRJbmZvKSB7XG4gICAgICAvKiBObyBvbmUgaGFzIGNhbGxlZCB1bmxvYWRBcHBsaWNhdGlvbiBmb3IgdGhpcyBhcHAsXG4gICAgICAgKi9cbiAgICAgIHJldHVybiBhcHBPclBhcmNlbDtcbiAgICB9XG5cbiAgICBpZiAoYXBwT3JQYXJjZWwuc3RhdHVzID09PSBOT1RfTE9BREVEKSB7XG4gICAgICAvKiBUaGlzIGFwcCBpcyBhbHJlYWR5IHVubG9hZGVkLiBXZSBqdXN0IG5lZWQgdG8gY2xlYW4gdXBcbiAgICAgICAqIGFueXRoaW5nIHRoYXQgc3RpbGwgdGhpbmtzIHdlIG5lZWQgdG8gdW5sb2FkIHRoZSBhcHAuXG4gICAgICAgKi9cbiAgICAgIGZpbmlzaFVubG9hZGluZ0FwcChhcHBPclBhcmNlbCwgdW5sb2FkSW5mbyk7XG4gICAgICByZXR1cm4gYXBwT3JQYXJjZWw7XG4gICAgfVxuXG4gICAgaWYgKGFwcE9yUGFyY2VsLnN0YXR1cyA9PT0gVU5MT0FESU5HKSB7XG4gICAgICAvKiBCb3RoIHVubG9hZEFwcGxpY2F0aW9uIGFuZCByZXJvdXRlIHdhbnQgdG8gdW5sb2FkIHRoaXMgYXBwLlxuICAgICAgICogSXQgb25seSBuZWVkcyB0byBiZSBkb25lIG9uY2UsIHRob3VnaC5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHVubG9hZEluZm8ucHJvbWlzZS50aGVuKCgpID0+IGFwcE9yUGFyY2VsKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhcHBPclBhcmNlbC5zdGF0dXMgIT09IE5PVF9NT1VOVEVEICYmXG4gICAgICBhcHBPclBhcmNlbC5zdGF0dXMgIT09IExPQURfRVJST1JcbiAgICApIHtcbiAgICAgIC8qIFRoZSBhcHAgY2Fubm90IGJlIHVubG9hZGVkIHVudGlsIGl0IGlzIHVubW91bnRlZC5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICAgIH1cblxuICAgIGxldCBzdGFydFRpbWU7XG5cbiAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGNvbnN0IHVubG9hZFByb21pc2UgPVxuICAgICAgYXBwT3JQYXJjZWwuc3RhdHVzID09PSBMT0FEX0VSUk9SXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgOiByZWFzb25hYmxlVGltZShhcHBPclBhcmNlbCwgXCJ1bmxvYWRcIik7XG5cbiAgICBhcHBPclBhcmNlbC5zdGF0dXMgPSBVTkxPQURJTkc7XG5cbiAgICByZXR1cm4gdW5sb2FkUHJvbWlzZVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uXCIsXG4gICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgXCJ1bmxvYWRcIixcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5pc2hVbmxvYWRpbmdBcHAoYXBwT3JQYXJjZWwsIHVubG9hZEluZm8pO1xuXG4gICAgICAgIHJldHVybiBhcHBPclBhcmNlbDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uXCIsXG4gICAgICAgICAgICB0b05hbWUoYXBwT3JQYXJjZWwpLFxuICAgICAgICAgICAgXCJ1bmxvYWRcIixcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JVbmxvYWRpbmdBcHAoYXBwT3JQYXJjZWwsIHVubG9hZEluZm8sIGVycik7XG5cbiAgICAgICAgcmV0dXJuIGFwcE9yUGFyY2VsO1xuICAgICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hVbmxvYWRpbmdBcHAoYXBwLCB1bmxvYWRJbmZvKSB7XG4gIGRlbGV0ZSBhcHBzVG9VbmxvYWRbdG9OYW1lKGFwcCldO1xuXG4gIC8vIFVubG9hZGVkIGFwcHMgZG9uJ3QgaGF2ZSBsaWZlY3ljbGVzXG4gIGRlbGV0ZSBhcHAuYm9vdHN0cmFwO1xuICBkZWxldGUgYXBwLm1vdW50O1xuICBkZWxldGUgYXBwLnVubW91bnQ7XG4gIGRlbGV0ZSBhcHAudW5sb2FkO1xuXG4gIGFwcC5zdGF0dXMgPSBOT1RfTE9BREVEO1xuXG4gIC8qIHJlc29sdmUgdGhlIHByb21pc2Ugb2Ygd2hvZXZlciBjYWxsZWQgdW5sb2FkQXBwbGljYXRpb24uXG4gICAqIFRoaXMgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgYWxsIG90aGVyIGNsZWFudXAvYm9va2tlZXBpbmdcbiAgICovXG4gIHVubG9hZEluZm8ucmVzb2x2ZSgpO1xufVxuXG5mdW5jdGlvbiBlcnJvclVubG9hZGluZ0FwcChhcHAsIHVubG9hZEluZm8sIGVycikge1xuICBkZWxldGUgYXBwc1RvVW5sb2FkW3RvTmFtZShhcHApXTtcblxuICAvLyBVbmxvYWRlZCBhcHBzIGRvbid0IGhhdmUgbGlmZWN5Y2xlc1xuICBkZWxldGUgYXBwLmJvb3RzdHJhcDtcbiAgZGVsZXRlIGFwcC5tb3VudDtcbiAgZGVsZXRlIGFwcC51bm1vdW50O1xuICBkZWxldGUgYXBwLnVubG9hZDtcblxuICBoYW5kbGVBcHBFcnJvcihlcnIsIGFwcCwgU0tJUF9CRUNBVVNFX0JST0tFTik7XG4gIHVubG9hZEluZm8ucmVqZWN0KGVycik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBcHBUb1VubG9hZChhcHAsIHByb21pc2VHZXR0ZXIsIHJlc29sdmUsIHJlamVjdCkge1xuICBhcHBzVG9VbmxvYWRbdG9OYW1lKGFwcCldID0geyBhcHAsIHJlc29sdmUsIHJlamVjdCB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwc1RvVW5sb2FkW3RvTmFtZShhcHApXSwgXCJwcm9taXNlXCIsIHtcbiAgICBnZXQ6IHByb21pc2VHZXR0ZXIsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwVW5sb2FkSW5mbyhhcHBOYW1lKSB7XG4gIHJldHVybiBhcHBzVG9VbmxvYWRbYXBwTmFtZV07XG59XG4iLCJpbXBvcnQgeyBlbnN1cmVKUXVlcnlTdXBwb3J0IH0gZnJvbSBcIi4uL2pxdWVyeS1zdXBwb3J0LmpzXCI7XG5pbXBvcnQge1xuICBpc0FjdGl2ZSxcbiAgdG9OYW1lLFxuICBOT1RfTE9BREVELFxuICBOT1RfQk9PVFNUUkFQUEVELFxuICBOT1RfTU9VTlRFRCxcbiAgTU9VTlRFRCxcbiAgTE9BRF9FUlJPUixcbiAgU0tJUF9CRUNBVVNFX0JST0tFTixcbiAgTE9BRElOR19TT1VSQ0VfQ09ERSxcbiAgc2hvdWxkQmVBY3RpdmUsXG59IGZyb20gXCIuL2FwcC5oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyByZXJvdXRlLCB0cmlnZ2VyQXBwQ2hhbmdlIH0gZnJvbSBcIi4uL25hdmlnYXRpb24vcmVyb3V0ZS5qc1wiO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gXCIuLi91dGlscy9maW5kLmpzXCI7XG5pbXBvcnQgeyB0b1VubW91bnRQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvdW5tb3VudC5qc1wiO1xuaW1wb3J0IHtcbiAgdG9VbmxvYWRQcm9taXNlLFxuICBnZXRBcHBVbmxvYWRJbmZvLFxuICBhZGRBcHBUb1VubG9hZCxcbn0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvdW5sb2FkLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9hcHAtZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBpc0luQnJvd3NlciB9IGZyb20gXCIuLi91dGlscy9ydW50aW1lLWVudmlyb25tZW50LmpzXCI7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tIFwiLi4vdXRpbHMvYXNzaWduXCI7XG5pbXBvcnQgeyBpc1N0YXJ0ZWQgfSBmcm9tIFwiLi4vc3RhcnQuanNcIjtcblxuY29uc3QgYXBwcyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwQ2hhbmdlcygpIHtcbiAgY29uc3QgYXBwc1RvVW5sb2FkID0gW10sXG4gICAgYXBwc1RvVW5tb3VudCA9IFtdLFxuICAgIGFwcHNUb0xvYWQgPSBbXSxcbiAgICBhcHBzVG9Nb3VudCA9IFtdO1xuXG4gIC8vIFdlIHJlLWF0dGVtcHQgdG8gZG93bmxvYWQgYXBwbGljYXRpb25zIGluIExPQURfRVJST1IgYWZ0ZXIgYSB0aW1lb3V0IG9mIDIwMCBtaWxsaXNlY29uZHNcbiAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICBhcHBzLmZvckVhY2goKGFwcCkgPT4ge1xuICAgIGNvbnN0IGFwcFNob3VsZEJlQWN0aXZlID1cbiAgICAgIGFwcC5zdGF0dXMgIT09IFNLSVBfQkVDQVVTRV9CUk9LRU4gJiYgc2hvdWxkQmVBY3RpdmUoYXBwKTtcblxuICAgIHN3aXRjaCAoYXBwLnN0YXR1cykge1xuICAgICAgY2FzZSBMT0FEX0VSUk9SOlxuICAgICAgICBpZiAoYXBwU2hvdWxkQmVBY3RpdmUgJiYgY3VycmVudFRpbWUgLSBhcHAubG9hZEVycm9yVGltZSA+PSAyMDApIHtcbiAgICAgICAgICBhcHBzVG9Mb2FkLnB1c2goYXBwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTk9UX0xPQURFRDpcbiAgICAgIGNhc2UgTE9BRElOR19TT1VSQ0VfQ09ERTpcbiAgICAgICAgaWYgKGFwcFNob3VsZEJlQWN0aXZlKSB7XG4gICAgICAgICAgYXBwc1RvTG9hZC5wdXNoKGFwcCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5PVF9CT09UU1RSQVBQRUQ6XG4gICAgICBjYXNlIE5PVF9NT1VOVEVEOlxuICAgICAgICBpZiAoIWFwcFNob3VsZEJlQWN0aXZlICYmIGdldEFwcFVubG9hZEluZm8odG9OYW1lKGFwcCkpKSB7XG4gICAgICAgICAgYXBwc1RvVW5sb2FkLnB1c2goYXBwKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcHBTaG91bGRCZUFjdGl2ZSkge1xuICAgICAgICAgIGFwcHNUb01vdW50LnB1c2goYXBwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9VTlRFRDpcbiAgICAgICAgaWYgKCFhcHBTaG91bGRCZUFjdGl2ZSkge1xuICAgICAgICAgIGFwcHNUb1VubW91bnQucHVzaChhcHApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gYWxsIG90aGVyIHN0YXR1c2VzIGFyZSBpZ25vcmVkXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4geyBhcHBzVG9VbmxvYWQsIGFwcHNUb1VubW91bnQsIGFwcHNUb0xvYWQsIGFwcHNUb01vdW50IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VudGVkQXBwcygpIHtcbiAgcmV0dXJuIGFwcHMuZmlsdGVyKGlzQWN0aXZlKS5tYXAodG9OYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFwcE5hbWVzKCkge1xuICByZXR1cm4gYXBwcy5tYXAodG9OYW1lKTtcbn1cblxuLy8gdXNlZCBpbiBkZXZ0b29scywgbm90IChjdXJyZW50bHkpIGV4cG9zZWQgYXMgYSBzaW5nbGUtc3BhIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd0FwcERhdGEoKSB7XG4gIHJldHVybiBbLi4uYXBwc107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHBTdGF0dXMoYXBwTmFtZSkge1xuICBjb25zdCBhcHAgPSBmaW5kKGFwcHMsIChhcHApID0+IHRvTmFtZShhcHApID09PSBhcHBOYW1lKTtcbiAgcmV0dXJuIGFwcCA/IGFwcC5zdGF0dXMgOiBudWxsO1xufVxuXG5sZXQgc3RhcnRXYXJuaW5nSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQXBwbGljYXRpb24oXG4gIGFwcE5hbWVPckNvbmZpZyxcbiAgYXBwT3JMb2FkQXBwLFxuICBhY3RpdmVXaGVuLFxuICBjdXN0b21Qcm9wc1xuKSB7XG4gIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IHNhbml0aXplQXJndW1lbnRzKFxuICAgIGFwcE5hbWVPckNvbmZpZyxcbiAgICBhcHBPckxvYWRBcHAsXG4gICAgYWN0aXZlV2hlbixcbiAgICBjdXN0b21Qcm9wc1xuICApO1xuXG4gIGlmICghaXNTdGFydGVkKCkgJiYgIXN0YXJ0V2FybmluZ0luaXRpYWxpemVkKSB7XG4gICAgc3RhcnRXYXJuaW5nSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWlzU3RhcnRlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgICAgICBgc2luZ2xlU3BhLnN0YXJ0KCkgaGFzIG5vdCBiZWVuIGNhbGxlZCwgNTAwMG1zIGFmdGVyIHNpbmdsZS1zcGEgd2FzIGxvYWRlZC4gQmVmb3JlIHN0YXJ0KCkgaXMgY2FsbGVkLCBhcHBzIGNhbiBiZSBkZWNsYXJlZCBhbmQgbG9hZGVkLCBidXQgbm90IGJvb3RzdHJhcHBlZCBvciBtb3VudGVkLmBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gIH1cblxuICBpZiAoZ2V0QXBwTmFtZXMoKS5pbmRleE9mKHJlZ2lzdHJhdGlvbi5uYW1lKSAhPT0gLTEpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDIxLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIHJlZ2lzdGVyZWQgd2l0aCBuYW1lICR7cmVnaXN0cmF0aW9uLm5hbWV9YCxcbiAgICAgICAgcmVnaXN0cmF0aW9uLm5hbWVcbiAgICAgIClcbiAgICApO1xuXG4gIGFwcHMucHVzaChcbiAgICBhc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGxvYWRFcnJvclRpbWU6IG51bGwsXG4gICAgICAgIHN0YXR1czogTk9UX0xPQURFRCxcbiAgICAgICAgcGFyY2Vsczoge30sXG4gICAgICAgIGRldnRvb2xzOiB7XG4gICAgICAgICAgb3ZlcmxheXM6IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgc2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHJlZ2lzdHJhdGlvblxuICAgIClcbiAgKTtcblxuICBpZiAoaXNJbkJyb3dzZXIpIHtcbiAgICBlbnN1cmVKUXVlcnlTdXBwb3J0KCk7XG4gICAgcmVyb3V0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FjdGl2aXR5RnVuY3Rpb25zKGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uKSB7XG4gIHJldHVybiBhcHBzLmZpbHRlcigoYXBwKSA9PiBhcHAuYWN0aXZlV2hlbihsb2NhdGlvbikpLm1hcCh0b05hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWdpc3RlckFwcGxpY2F0aW9uKGFwcE5hbWUpIHtcbiAgaWYgKGFwcHMuZmlsdGVyKChhcHApID0+IHRvTmFtZShhcHApID09PSBhcHBOYW1lKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMjUsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBgQ2Fubm90IHVucmVnaXN0ZXIgYXBwbGljYXRpb24gJyR7YXBwTmFtZX0nIGJlY2F1c2Ugbm8gc3VjaCBhcHBsaWNhdGlvbiBoYXMgYmVlbiByZWdpc3RlcmVkYCxcbiAgICAgICAgYXBwTmFtZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBjb25zdCB1bmxvYWRQcm9taXNlID0gaXNJbkJyb3dzZXJcbiAgICA/IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhL2lzc3Vlcy84NzEgZm9yIHdoeSB3YWl0Rm9yVW5tb3VudCBpcyBmYWxzZVxuICAgICAgdW5sb2FkQXBwbGljYXRpb24oYXBwTmFtZSwgeyB3YWl0Rm9yVW5tb3VudDogZmFsc2UgfSlcbiAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIHJldHVybiB1bmxvYWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgIGNvbnN0IGFwcEluZGV4ID0gYXBwcy5tYXAodG9OYW1lKS5pbmRleE9mKGFwcE5hbWUpO1xuICAgIGFwcHMuc3BsaWNlKGFwcEluZGV4LCAxKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmxvYWRBcHBsaWNhdGlvbihhcHBOYW1lLCBvcHRzID0geyB3YWl0Rm9yVW5tb3VudDogZmFsc2UgfSkge1xuICBpZiAodHlwZW9mIGFwcE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMjYsXG4gICAgICAgIF9fREVWX18gJiYgYHVubG9hZEFwcGxpY2F0aW9uIHJlcXVpcmVzIGEgc3RyaW5nICdhcHBOYW1lJ2BcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGNvbnN0IGFwcCA9IGZpbmQoYXBwcywgKEFwcCkgPT4gdG9OYW1lKEFwcCkgPT09IGFwcE5hbWUpO1xuICBpZiAoIWFwcCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyNyxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBDb3VsZCBub3QgdW5sb2FkIGFwcGxpY2F0aW9uICcke2FwcE5hbWV9JyBiZWNhdXNlIG5vIHN1Y2ggYXBwbGljYXRpb24gaGFzIGJlZW4gcmVnaXN0ZXJlZGAsXG4gICAgICAgIGFwcE5hbWVcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgY29uc3QgYXBwVW5sb2FkSW5mbyA9IGdldEFwcFVubG9hZEluZm8odG9OYW1lKGFwcCkpO1xuICBpZiAob3B0cyAmJiBvcHRzLndhaXRGb3JVbm1vdW50KSB7XG4gICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB1bm1vdW50IGJlZm9yZSB1bmxvYWRpbmcgdGhlIGFwcFxuXG4gICAgaWYgKGFwcFVubG9hZEluZm8pIHtcbiAgICAgIC8vIFNvbWVvbmUgZWxzZSBpcyBhbHJlYWR5IHdhaXRpbmcgZm9yIHRoaXMsIHRvb1xuICAgICAgcmV0dXJuIGFwcFVubG9hZEluZm8ucHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UncmUgdGhlIGZpcnN0IG9uZXMgd2FudGluZyB0aGUgYXBwIHRvIGJlIHJlc29sdmVkLlxuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYWRkQXBwVG9VbmxvYWQoYXBwLCAoKSA9PiBwcm9taXNlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLyogV2Ugc2hvdWxkIHVubW91bnQgdGhlIGFwcCwgdW5sb2FkIGl0LCBhbmQgcmVtb3VudCBpdCBpbW1lZGlhdGVseS5cbiAgICAgKi9cblxuICAgIGxldCByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKGFwcFVubG9hZEluZm8pIHtcbiAgICAgIC8vIFNvbWVvbmUgZWxzZSBpcyBhbHJlYWR5IHdhaXRpbmcgZm9yIHRoaXMgYXBwIHRvIHVubG9hZFxuICAgICAgcmVzdWx0UHJvbWlzZSA9IGFwcFVubG9hZEluZm8ucHJvbWlzZTtcbiAgICAgIGltbWVkaWF0ZWx5VW5sb2FkQXBwKGFwcCwgYXBwVW5sb2FkSW5mby5yZXNvbHZlLCBhcHBVbmxvYWRJbmZvLnJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlJ3JlIHRoZSBmaXJzdCBvbmVzIHdhbnRpbmcgdGhlIGFwcCB0byBiZSByZXNvbHZlZC5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGFkZEFwcFRvVW5sb2FkKGFwcCwgKCkgPT4gcmVzdWx0UHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgaW1tZWRpYXRlbHlVbmxvYWRBcHAoYXBwLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1tZWRpYXRlbHlVbmxvYWRBcHAoYXBwLCByZXNvbHZlLCByZWplY3QpIHtcbiAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAvLyBCZWZvcmUgdW5tb3VudGluZyB0aGUgYXBwbGljYXRpb24sIHdlIGZpcnN0IG11c3Qgd2FpdCBmb3IgaXQgdG8gZmluaXNoIG1vdW50aW5nXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB0ZXN0IGZvciBpc3N1ZSA4NzEgaW4gdW5yZWdpc3Rlci1hcHBsaWNhdGlvbi5zcGVjLmpzIGZhaWxzIGJlY2F1c2VcbiAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiBpc24ndCByZWFsbHkgdW5tb3VudGVkLlxuICAgICAgaWYgKFxuICAgICAgICBmaW5kKGNoZWNrQWN0aXZpdHlGdW5jdGlvbnMoKSwgKGFjdGl2ZUFwcCkgPT4gYWN0aXZlQXBwID09PSB0b05hbWUoYXBwKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJpZ2dlckFwcENoYW5nZSgpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRvVW5tb3VudFByb21pc2UoYXBwKVxuICAgICAgICAudGhlbih0b1VubG9hZFByb21pc2UpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyByZXJvdXRlLCBidXQgdGhlIHVubG9hZCBwcm9taXNlIGlzIGRvbmVcbiAgICAgICAgICAgIHJlcm91dGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAuY2F0Y2gocmVqZWN0KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZWdpc3RlcldpdGhBcmd1bWVudHMoXG4gIG5hbWUsXG4gIGFwcE9yTG9hZEFwcCxcbiAgYWN0aXZlV2hlbixcbiAgY3VzdG9tUHJvcHNcbikge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZS5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDIwLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgYFRoZSAxc3QgYXJndW1lbnQgdG8gcmVnaXN0ZXJBcHBsaWNhdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyAnYXBwTmFtZSdgXG4gICAgICApXG4gICAgKTtcblxuICBpZiAoIWFwcE9yTG9hZEFwcClcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGZvcm1hdEVycm9yTWVzc2FnZShcbiAgICAgICAgMjMsXG4gICAgICAgIF9fREVWX18gJiZcbiAgICAgICAgICBcIlRoZSAybmQgYXJndW1lbnQgdG8gcmVnaXN0ZXJBcHBsaWNhdGlvbiBtdXN0IGJlIGFuIGFwcGxpY2F0aW9uIG9yIGxvYWRpbmcgYXBwbGljYXRpb24gZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKHR5cGVvZiBhY3RpdmVXaGVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDI0LFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgXCJUaGUgM3JkIGFyZ3VtZW50IHRvIHJlZ2lzdGVyQXBwbGljYXRpb24gbXVzdCBiZSBhbiBhY3RpdmVXaGVuIGZ1bmN0aW9uXCJcbiAgICAgIClcbiAgICApO1xuXG4gIGlmICghdmFsaWRDdXN0b21Qcm9wcyhjdXN0b21Qcm9wcykpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDIyLFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgXCJUaGUgb3B0aW9uYWwgNHRoIGFyZ3VtZW50IGlzIGEgY3VzdG9tUHJvcHMgYW5kIG11c3QgYmUgYW4gb2JqZWN0XCJcbiAgICAgIClcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSZWdpc3RlcldpdGhDb25maWcoY29uZmlnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykgfHwgY29uZmlnID09PSBudWxsKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAzOSxcbiAgICAgICAgX19ERVZfXyAmJiBcIkNvbmZpZ3VyYXRpb24gb2JqZWN0IGNhbid0IGJlIGFuIEFycmF5IG9yIG51bGwhXCJcbiAgICAgIClcbiAgICApO1xuICBjb25zdCB2YWxpZEtleXMgPSBbXCJuYW1lXCIsIFwiYXBwXCIsIFwiYWN0aXZlV2hlblwiLCBcImN1c3RvbVByb3BzXCJdO1xuICBjb25zdCBpbnZhbGlkS2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykucmVkdWNlKFxuICAgIChpbnZhbGlkS2V5cywgcHJvcCkgPT5cbiAgICAgIHZhbGlkS2V5cy5pbmRleE9mKHByb3ApID49IDAgPyBpbnZhbGlkS2V5cyA6IGludmFsaWRLZXlzLmNvbmNhdChwcm9wKSxcbiAgICBbXVxuICApO1xuICBpZiAoaW52YWxpZEtleXMubGVuZ3RoICE9PSAwKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAzOCxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIGBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgYWNjZXB0cyBvbmx5OiAke3ZhbGlkS2V5cy5qb2luKFxuICAgICAgICAgICAgXCIsIFwiXG4gICAgICAgICAgKX0uIEludmFsaWQga2V5czogJHtpbnZhbGlkS2V5cy5qb2luKFwiLCBcIil9LmAsXG4gICAgICAgIHZhbGlkS2V5cy5qb2luKFwiLCBcIiksXG4gICAgICAgIGludmFsaWRLZXlzLmpvaW4oXCIsIFwiKVxuICAgICAgKVxuICAgICk7XG4gIGlmICh0eXBlb2YgY29uZmlnLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgY29uZmlnLm5hbWUubGVuZ3RoID09PSAwKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyMCxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIFwiVGhlIGNvbmZpZy5uYW1lIG9uIHJlZ2lzdGVyQXBwbGljYXRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIlxuICAgICAgKVxuICAgICk7XG4gIGlmICh0eXBlb2YgY29uZmlnLmFwcCAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uZmlnLmFwcCAhPT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyMCxcbiAgICAgICAgX19ERVZfXyAmJlxuICAgICAgICAgIFwiVGhlIGNvbmZpZy5hcHAgb24gcmVnaXN0ZXJBcHBsaWNhdGlvbiBtdXN0IGJlIGFuIGFwcGxpY2F0aW9uIG9yIGEgbG9hZGluZyBmdW5jdGlvblwiXG4gICAgICApXG4gICAgKTtcbiAgY29uc3QgYWxsb3dzU3RyaW5nQW5kRnVuY3Rpb24gPSAoYWN0aXZlV2hlbikgPT5cbiAgICB0eXBlb2YgYWN0aXZlV2hlbiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYWN0aXZlV2hlbiA9PT0gXCJmdW5jdGlvblwiO1xuICBpZiAoXG4gICAgIWFsbG93c1N0cmluZ0FuZEZ1bmN0aW9uKGNvbmZpZy5hY3RpdmVXaGVuKSAmJlxuICAgICEoXG4gICAgICBBcnJheS5pc0FycmF5KGNvbmZpZy5hY3RpdmVXaGVuKSAmJlxuICAgICAgY29uZmlnLmFjdGl2ZVdoZW4uZXZlcnkoYWxsb3dzU3RyaW5nQW5kRnVuY3Rpb24pXG4gICAgKVxuICApXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgIDI0LFxuICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgXCJUaGUgY29uZmlnLmFjdGl2ZVdoZW4gb24gcmVnaXN0ZXJBcHBsaWNhdGlvbiBtdXN0IGJlIGEgc3RyaW5nLCBmdW5jdGlvbiBvciBhbiBhcnJheSB3aXRoIGJvdGhcIlxuICAgICAgKVxuICAgICk7XG4gIGlmICghdmFsaWRDdXN0b21Qcm9wcyhjb25maWcuY3VzdG9tUHJvcHMpKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0RXJyb3JNZXNzYWdlKFxuICAgICAgICAyMixcbiAgICAgICAgX19ERVZfXyAmJiBcIlRoZSBvcHRpb25hbCBjb25maWcuY3VzdG9tUHJvcHMgbXVzdCBiZSBhbiBvYmplY3RcIlxuICAgICAgKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkQ3VzdG9tUHJvcHMoY3VzdG9tUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICAhY3VzdG9tUHJvcHMgfHxcbiAgICB0eXBlb2YgY3VzdG9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgY3VzdG9tUHJvcHMgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIGN1c3RvbVByb3BzICE9PSBudWxsICYmXG4gICAgICAhQXJyYXkuaXNBcnJheShjdXN0b21Qcm9wcykpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplQXJndW1lbnRzKFxuICBhcHBOYW1lT3JDb25maWcsXG4gIGFwcE9yTG9hZEFwcCxcbiAgYWN0aXZlV2hlbixcbiAgY3VzdG9tUHJvcHNcbikge1xuICBjb25zdCB1c2luZ09iamVjdEFQSSA9IHR5cGVvZiBhcHBOYW1lT3JDb25maWcgPT09IFwib2JqZWN0XCI7XG5cbiAgY29uc3QgcmVnaXN0cmF0aW9uID0ge1xuICAgIG5hbWU6IG51bGwsXG4gICAgbG9hZEFwcDogbnVsbCxcbiAgICBhY3RpdmVXaGVuOiBudWxsLFxuICAgIGN1c3RvbVByb3BzOiBudWxsLFxuICB9O1xuXG4gIGlmICh1c2luZ09iamVjdEFQSSkge1xuICAgIHZhbGlkYXRlUmVnaXN0ZXJXaXRoQ29uZmlnKGFwcE5hbWVPckNvbmZpZyk7XG4gICAgcmVnaXN0cmF0aW9uLm5hbWUgPSBhcHBOYW1lT3JDb25maWcubmFtZTtcbiAgICByZWdpc3RyYXRpb24ubG9hZEFwcCA9IGFwcE5hbWVPckNvbmZpZy5hcHA7XG4gICAgcmVnaXN0cmF0aW9uLmFjdGl2ZVdoZW4gPSBhcHBOYW1lT3JDb25maWcuYWN0aXZlV2hlbjtcbiAgICByZWdpc3RyYXRpb24uY3VzdG9tUHJvcHMgPSBhcHBOYW1lT3JDb25maWcuY3VzdG9tUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVSZWdpc3RlcldpdGhBcmd1bWVudHMoXG4gICAgICBhcHBOYW1lT3JDb25maWcsXG4gICAgICBhcHBPckxvYWRBcHAsXG4gICAgICBhY3RpdmVXaGVuLFxuICAgICAgY3VzdG9tUHJvcHNcbiAgICApO1xuICAgIHJlZ2lzdHJhdGlvbi5uYW1lID0gYXBwTmFtZU9yQ29uZmlnO1xuICAgIHJlZ2lzdHJhdGlvbi5sb2FkQXBwID0gYXBwT3JMb2FkQXBwO1xuICAgIHJlZ2lzdHJhdGlvbi5hY3RpdmVXaGVuID0gYWN0aXZlV2hlbjtcbiAgICByZWdpc3RyYXRpb24uY3VzdG9tUHJvcHMgPSBjdXN0b21Qcm9wcztcbiAgfVxuXG4gIHJlZ2lzdHJhdGlvbi5sb2FkQXBwID0gc2FuaXRpemVMb2FkQXBwKHJlZ2lzdHJhdGlvbi5sb2FkQXBwKTtcbiAgcmVnaXN0cmF0aW9uLmN1c3RvbVByb3BzID0gc2FuaXRpemVDdXN0b21Qcm9wcyhyZWdpc3RyYXRpb24uY3VzdG9tUHJvcHMpO1xuICByZWdpc3RyYXRpb24uYWN0aXZlV2hlbiA9IHNhbml0aXplQWN0aXZlV2hlbihyZWdpc3RyYXRpb24uYWN0aXZlV2hlbik7XG5cbiAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVMb2FkQXBwKGxvYWRBcHApIHtcbiAgaWYgKHR5cGVvZiBsb2FkQXBwICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGxvYWRBcHApO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRBcHA7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplQ3VzdG9tUHJvcHMoY3VzdG9tUHJvcHMpIHtcbiAgcmV0dXJuIGN1c3RvbVByb3BzID8gY3VzdG9tUHJvcHMgOiB7fTtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVBY3RpdmVXaGVuKGFjdGl2ZVdoZW4pIHtcbiAgbGV0IGFjdGl2ZVdoZW5BcnJheSA9IEFycmF5LmlzQXJyYXkoYWN0aXZlV2hlbikgPyBhY3RpdmVXaGVuIDogW2FjdGl2ZVdoZW5dO1xuICBhY3RpdmVXaGVuQXJyYXkgPSBhY3RpdmVXaGVuQXJyYXkubWFwKChhY3RpdmVXaGVuT3JQYXRoKSA9PlxuICAgIHR5cGVvZiBhY3RpdmVXaGVuT3JQYXRoID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gYWN0aXZlV2hlbk9yUGF0aFxuICAgICAgOiBwYXRoVG9BY3RpdmVXaGVuKGFjdGl2ZVdoZW5PclBhdGgpXG4gICk7XG5cbiAgcmV0dXJuIChsb2NhdGlvbikgPT5cbiAgICBhY3RpdmVXaGVuQXJyYXkuc29tZSgoYWN0aXZlV2hlbikgPT4gYWN0aXZlV2hlbihsb2NhdGlvbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvQWN0aXZlV2hlbihwYXRoLCBleGFjdE1hdGNoKSB7XG4gIGNvbnN0IHJlZ2V4ID0gdG9EeW5hbWljUGF0aFZhbGlkYXRvclJlZ2V4KHBhdGgsIGV4YWN0TWF0Y2gpO1xuXG4gIHJldHVybiAobG9jYXRpb24pID0+IHtcbiAgICAvLyBjb21wYXRpYmxlIHdpdGggSUUxMFxuICAgIGxldCBvcmlnaW4gPSBsb2NhdGlvbi5vcmlnaW47XG4gICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgIG9yaWdpbiA9IGAke2xvY2F0aW9uLnByb3RvY29sfS8vJHtsb2NhdGlvbi5ob3N0fWA7XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlID0gbG9jYXRpb24uaHJlZlxuICAgICAgLnJlcGxhY2Uob3JpZ2luLCBcIlwiKVxuICAgICAgLnJlcGxhY2UobG9jYXRpb24uc2VhcmNoLCBcIlwiKVxuICAgICAgLnNwbGl0KFwiP1wiKVswXTtcbiAgICByZXR1cm4gcmVnZXgudGVzdChyb3V0ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvRHluYW1pY1BhdGhWYWxpZGF0b3JSZWdleChwYXRoLCBleGFjdE1hdGNoKSB7XG4gIGxldCBsYXN0SW5kZXggPSAwLFxuICAgIGluRHluYW1pYyA9IGZhbHNlLFxuICAgIHJlZ2V4U3RyID0gXCJeXCI7XG5cbiAgaWYgKHBhdGhbMF0gIT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IFwiL1wiICsgcGF0aDtcbiAgfVxuXG4gIGZvciAobGV0IGNoYXJJbmRleCA9IDA7IGNoYXJJbmRleCA8IHBhdGgubGVuZ3RoOyBjaGFySW5kZXgrKykge1xuICAgIGNvbnN0IGNoYXIgPSBwYXRoW2NoYXJJbmRleF07XG4gICAgY29uc3Qgc3RhcnRPZkR5bmFtaWMgPSAhaW5EeW5hbWljICYmIGNoYXIgPT09IFwiOlwiO1xuICAgIGNvbnN0IGVuZE9mRHluYW1pYyA9IGluRHluYW1pYyAmJiBjaGFyID09PSBcIi9cIjtcbiAgICBpZiAoc3RhcnRPZkR5bmFtaWMgfHwgZW5kT2ZEeW5hbWljKSB7XG4gICAgICBhcHBlbmRUb1JlZ2V4KGNoYXJJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kVG9SZWdleChwYXRoLmxlbmd0aCk7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4U3RyLCBcImlcIik7XG5cbiAgZnVuY3Rpb24gYXBwZW5kVG9SZWdleChpbmRleCkge1xuICAgIGNvbnN0IGFueUNoYXJNYXliZVRyYWlsaW5nU2xhc2hSZWdleCA9IFwiW14vXSsvP1wiO1xuICAgIGNvbnN0IGNvbW1vblN0cmluZ1N1YlBhdGggPSBlc2NhcGVTdHJSZWdleChwYXRoLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcblxuICAgIHJlZ2V4U3RyICs9IGluRHluYW1pY1xuICAgICAgPyBhbnlDaGFyTWF5YmVUcmFpbGluZ1NsYXNoUmVnZXhcbiAgICAgIDogY29tbW9uU3RyaW5nU3ViUGF0aDtcblxuICAgIGlmIChpbmRleCA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChpbkR5bmFtaWMpIHtcbiAgICAgICAgaWYgKGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgZXhhY3QgbWF0Y2ggcGF0aHMgdGhhdCBlbmQgaW4gYSBkeW5hbWljIHBvcnRpb24gZG9uJ3QgbWF0Y2hcbiAgICAgICAgICAvLyB1cmxzIHdpdGggY2hhcmFjdGVycyBhZnRlciBhIHNsYXNoIGFmdGVyIHRoZSBkeW5hbWljIHBvcnRpb24uXG4gICAgICAgICAgcmVnZXhTdHIgKz0gXCIkXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBleGFjdCBtYXRjaGVzLCBleHBlY3Qgbm8gbW9yZSBjaGFyYWN0ZXJzLiBPdGhlcndpc2UsIGFsbG93XG4gICAgICAgIC8vIGFueSBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBzdWZmaXggPSBleGFjdE1hdGNoID8gXCJcIiA6IFwiLipcIjtcblxuICAgICAgICByZWdleFN0ciA9XG4gICAgICAgICAgLy8gdXNlIGNoYXJBdCBpbnN0ZWFkIGFzIHdlIGNvdWxkIG5vdCB1c2UgZXM2IG1ldGhvZCBlbmRzV2l0aFxuICAgICAgICAgIHJlZ2V4U3RyLmNoYXJBdChyZWdleFN0ci5sZW5ndGggLSAxKSA9PT0gXCIvXCJcbiAgICAgICAgICAgID8gYCR7cmVnZXhTdHJ9JHtzdWZmaXh9JGBcbiAgICAgICAgICAgIDogYCR7cmVnZXhTdHJ9KC8ke3N1ZmZpeH0pPygjLiopPyRgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluRHluYW1pYyA9ICFpbkR5bmFtaWM7XG4gICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVTdHJSZWdleChzdHIpIHtcbiAgICAvLyBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHAvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCBcIlxcXFwkJlwiKTtcbiAgfVxufVxuIiwiaW1wb3J0IEN1c3RvbUV2ZW50IGZyb20gXCJjdXN0b20tZXZlbnRcIjtcbmltcG9ydCB7IGlzU3RhcnRlZCB9IGZyb20gXCIuLi9zdGFydC5qc1wiO1xuaW1wb3J0IHsgdG9Mb2FkUHJvbWlzZSB9IGZyb20gXCIuLi9saWZlY3ljbGVzL2xvYWQuanNcIjtcbmltcG9ydCB7IHRvQm9vdHN0cmFwUHJvbWlzZSB9IGZyb20gXCIuLi9saWZlY3ljbGVzL2Jvb3RzdHJhcC5qc1wiO1xuaW1wb3J0IHsgdG9Nb3VudFByb21pc2UgfSBmcm9tIFwiLi4vbGlmZWN5Y2xlcy9tb3VudC5qc1wiO1xuaW1wb3J0IHsgdG9Vbm1vdW50UHJvbWlzZSB9IGZyb20gXCIuLi9saWZlY3ljbGVzL3VubW91bnQuanNcIjtcbmltcG9ydCB7XG4gIGdldEFwcFN0YXR1cyxcbiAgZ2V0QXBwQ2hhbmdlcyxcbiAgZ2V0TW91bnRlZEFwcHMsXG59IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwcy5qc1wiO1xuaW1wb3J0IHtcbiAgY2FsbENhcHR1cmVkRXZlbnRMaXN0ZW5lcnMsXG4gIG9yaWdpbmFsUmVwbGFjZVN0YXRlLFxufSBmcm9tIFwiLi9uYXZpZ2F0aW9uLWV2ZW50cy5qc1wiO1xuaW1wb3J0IHsgdG9VbmxvYWRQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvdW5sb2FkLmpzXCI7XG5pbXBvcnQge1xuICB0b05hbWUsXG4gIHNob3VsZEJlQWN0aXZlLFxuICBOT1RfTU9VTlRFRCxcbiAgTU9VTlRFRCxcbiAgTk9UX0xPQURFRCxcbiAgU0tJUF9CRUNBVVNFX0JST0tFTixcbn0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAuaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSBcIi4uL3V0aWxzL2Fzc2lnbi5qc1wiO1xuaW1wb3J0IHsgaXNJbkJyb3dzZXIgfSBmcm9tIFwiLi4vdXRpbHMvcnVudGltZS1lbnZpcm9ubWVudC5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSBcIi4uL2FwcGxpY2F0aW9ucy9hcHAtZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBhZGRQcm9maWxlRW50cnkgfSBmcm9tIFwiLi4vZGV2dG9vbHMvcHJvZmlsZXIuanNcIjtcblxubGV0IGFwcENoYW5nZVVuZGVyd2F5ID0gZmFsc2UsXG4gIHBlb3BsZVdhaXRpbmdPbkFwcENoYW5nZSA9IFtdLFxuICBjdXJyZW50VXJsID0gaXNJbkJyb3dzZXIgJiYgd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VyQXBwQ2hhbmdlKCkge1xuICAvLyBDYWxsIHJlcm91dGUgd2l0aCBubyBhcmd1bWVudHMsIGludGVudGlvbmFsbHlcbiAgcmV0dXJuIHJlcm91dGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcm91dGUoXG4gIHBlbmRpbmdQcm9taXNlcyA9IFtdLFxuICBldmVudEFyZ3VtZW50cyxcbiAgc2lsZW50TmF2aWdhdGlvbiA9IGZhbHNlXG4pIHtcbiAgaWYgKGFwcENoYW5nZVVuZGVyd2F5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHBlb3BsZVdhaXRpbmdPbkFwcENoYW5nZS5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICBldmVudEFyZ3VtZW50cyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IHN0YXJ0VGltZSwgcHJvZmlsZXJLaW5kO1xuXG4gIGlmIChfX1BST0ZJTEVfXykge1xuICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChzaWxlbnROYXZpZ2F0aW9uKSB7XG4gICAgICBwcm9maWxlcktpbmQgPSBcInNpbGVudE5hdmlnYXRpb25cIjtcbiAgICB9IGVsc2UgaWYgKGV2ZW50QXJndW1lbnRzKSB7XG4gICAgICBwcm9maWxlcktpbmQgPSBcImJyb3dzZXJOYXZpZ2F0aW9uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2ZpbGVyS2luZCA9IFwidHJpZ2dlckFwcENoYW5nZVwiO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgYXBwc1RvVW5sb2FkLCBhcHBzVG9Vbm1vdW50LCBhcHBzVG9Mb2FkLCBhcHBzVG9Nb3VudCB9ID1cbiAgICBnZXRBcHBDaGFuZ2VzKCk7XG4gIGxldCBhcHBzVGhhdENoYW5nZWQsXG4gICAgY2FuY2VsUHJvbWlzZXMgPSBbXSxcbiAgICBvbGRVcmwgPSBjdXJyZW50VXJsLFxuICAgIG5ld1VybCA9IChjdXJyZW50VXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gIGlmIChpc1N0YXJ0ZWQoKSkge1xuICAgIGFwcENoYW5nZVVuZGVyd2F5ID0gdHJ1ZTtcbiAgICBhcHBzVGhhdENoYW5nZWQgPSBhcHBzVG9VbmxvYWQuY29uY2F0KFxuICAgICAgYXBwc1RvTG9hZCxcbiAgICAgIGFwcHNUb1VubW91bnQsXG4gICAgICBhcHBzVG9Nb3VudFxuICAgICk7XG4gICAgcmV0dXJuIHBlcmZvcm1BcHBDaGFuZ2VzKCk7XG4gIH0gZWxzZSB7XG4gICAgYXBwc1RoYXRDaGFuZ2VkID0gYXBwc1RvTG9hZDtcbiAgICByZXR1cm4gbG9hZEFwcHMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbE5hdmlnYXRpb24odmFsID0gdHJ1ZSkge1xuICAgIGNvbnN0IHByb21pc2UgPVxuICAgICAgdHlwZW9mIHZhbD8udGhlbiA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogUHJvbWlzZS5yZXNvbHZlKHZhbCk7XG4gICAgY2FuY2VsUHJvbWlzZXMucHVzaChcbiAgICAgIHByb21pc2UuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBmb3JtYXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgIDQyLFxuICAgICAgICAgICAgICBfX0RFVl9fICYmXG4gICAgICAgICAgICAgICAgYHNpbmdsZS1zcGE6IEEgY2FuY2VsTmF2aWdhdGlvbiBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZTogJHtlcnJ9YFxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG5cbiAgICAgICAgLy8gSW50ZXJwcmV0IGEgUHJvbWlzZSByZWplY3Rpb24gdG8gbWVhbiB0aGF0IHRoZSBuYXZpZ2F0aW9uIHNob3VsZCBub3QgYmUgY2FuY2VsZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZEFwcHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgbG9hZFByb21pc2VzID0gYXBwc1RvTG9hZC5tYXAodG9Mb2FkUHJvbWlzZSk7XG4gICAgICBsZXQgc3VjY2VlZGVkO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBQcm9taXNlLmFsbChsb2FkUHJvbWlzZXMpXG4gICAgICAgICAgLnRoZW4oY2FsbEFsbEV2ZW50TGlzdGVuZXJzKVxuICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBtb3VudGVkIGFwcHMsIGJlZm9yZSBzdGFydCgpIGlzIGNhbGxlZCwgc28gd2UgYWx3YXlzIHJldHVybiBbXVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsQWxsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICAgICAgXCJyb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgXCJsb2FkQXBwc1wiLFxuICAgICAgICAgICAgICAgIHByb2ZpbGVyS2luZCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgICAgc3VjY2VlZGVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtQXBwQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhL2lzc3Vlcy81NDVcbiAgICAgIGZpcmVTaW5nbGVTcGFFdmVudChcbiAgICAgICAgYXBwc1RoYXRDaGFuZ2VkLmxlbmd0aCA9PT0gMFxuICAgICAgICAgID8gXCJiZWZvcmUtbm8tYXBwLWNoYW5nZVwiXG4gICAgICAgICAgOiBcImJlZm9yZS1hcHAtY2hhbmdlXCIsXG4gICAgICAgIGdldEN1c3RvbUV2ZW50RGV0YWlsKHRydWUpXG4gICAgICApO1xuXG4gICAgICBmaXJlU2luZ2xlU3BhRXZlbnQoXG4gICAgICAgIFwiYmVmb3JlLXJvdXRpbmctZXZlbnRcIixcbiAgICAgICAgZ2V0Q3VzdG9tRXZlbnREZXRhaWwodHJ1ZSwgeyBjYW5jZWxOYXZpZ2F0aW9uIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2FuY2VsUHJvbWlzZXMpLnRoZW4oKGNhbmNlbFZhbHVlcykgPT4ge1xuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uSXNDYW5jZWxlZCA9IGNhbmNlbFZhbHVlcy5zb21lKCh2KSA9PiB2KTtcblxuICAgICAgICBpZiAobmF2aWdhdGlvbklzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAvLyBDaGFuZ2UgdXJsIGJhY2sgdG8gb2xkIHVybCwgd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBub3JtYWwgc2luZ2xlLXNwYSByZXJvdXRlXG4gICAgICAgICAgb3JpZ2luYWxSZXBsYWNlU3RhdGUuY2FsbChcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LFxuICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBvbGRVcmwuc3Vic3RyaW5nKGxvY2F0aW9uLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFNpbmdsZS1zcGEncyBpbnRlcm5hbCB0cmFja2luZyBvZiBjdXJyZW50IHVybCBuZWVkcyB0byBiZSB1cGRhdGVkIGFmdGVyIHRoZSB1cmwgY2hhbmdlIGFib3ZlXG4gICAgICAgICAgY3VycmVudFVybCA9IGxvY2F0aW9uLmhyZWY7XG5cbiAgICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHRoZSByZXJvdXRlIGZ1bmN0aW9uIHRvIGtub3cgdGhhdCB0aGUgY3VycmVudCByZXJvdXRlIGlzIGZpbmlzaGVkXG4gICAgICAgICAgYXBwQ2hhbmdlVW5kZXJ3YXkgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgICBcInJvdXRpbmdcIixcbiAgICAgICAgICAgICAgXCJuYXZpZ2F0aW9uQ2FuY2VsZWRcIixcbiAgICAgICAgICAgICAgcHJvZmlsZXJLaW5kLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRlbGwgc2luZ2xlLXNwYSB0byByZXJvdXRlIGFnYWluLCB0aGlzIHRpbWUgd2l0aCB0aGUgdXJsIHNldCB0byB0aGUgb2xkIFVSTFxuICAgICAgICAgIHJldHVybiByZXJvdXRlKHBlbmRpbmdQcm9taXNlcywgZXZlbnRBcmd1bWVudHMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5sb2FkUHJvbWlzZXMgPSBhcHBzVG9VbmxvYWQubWFwKHRvVW5sb2FkUHJvbWlzZSk7XG5cbiAgICAgICAgY29uc3QgdW5tb3VudFVubG9hZFByb21pc2VzID0gYXBwc1RvVW5tb3VudFxuICAgICAgICAgIC5tYXAodG9Vbm1vdW50UHJvbWlzZSlcbiAgICAgICAgICAubWFwKCh1bm1vdW50UHJvbWlzZSkgPT4gdW5tb3VudFByb21pc2UudGhlbih0b1VubG9hZFByb21pc2UpKTtcblxuICAgICAgICBjb25zdCBhbGxVbm1vdW50UHJvbWlzZXMgPSB1bm1vdW50VW5sb2FkUHJvbWlzZXMuY29uY2F0KHVubG9hZFByb21pc2VzKTtcblxuICAgICAgICBjb25zdCB1bm1vdW50QWxsUHJvbWlzZSA9IFByb21pc2UuYWxsKGFsbFVubW91bnRQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IHVubW91bnRGaW5pc2hlZFRpbWU7XG5cbiAgICAgICAgdW5tb3VudEFsbFByb21pc2UudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgICAgICAgICAgdW5tb3VudEZpbmlzaGVkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgICAgICAgIGFkZFByb2ZpbGVFbnRyeShcbiAgICAgICAgICAgICAgICBcInJvdXRpbmdcIixcbiAgICAgICAgICAgICAgICBcInVubW91bnRBbmRVbmxvYWRcIixcbiAgICAgICAgICAgICAgICBwcm9maWxlcktpbmQsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcmVTaW5nbGVTcGFFdmVudChcbiAgICAgICAgICAgICAgXCJiZWZvcmUtbW91bnQtcm91dGluZy1ldmVudFwiLFxuICAgICAgICAgICAgICBnZXRDdXN0b21FdmVudERldGFpbCh0cnVlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChfX1BST0ZJTEVfXykge1xuICAgICAgICAgICAgICBhZGRQcm9maWxlRW50cnkoXG4gICAgICAgICAgICAgICAgXCJyb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ1bm1vdW50QW5kVW5sb2FkXCIsXG4gICAgICAgICAgICAgICAgcHJvZmlsZXJLaW5kLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLyogV2UgbG9hZCBhbmQgYm9vdHN0cmFwIGFwcHMgd2hpbGUgb3RoZXIgYXBwcyBhcmUgdW5tb3VudGluZywgYnV0IHdlXG4gICAgICAgICAqIHdhaXQgdG8gbW91bnQgdGhlIGFwcCB1bnRpbCBhbGwgYXBwcyBhcmUgZmluaXNoaW5nIHVubW91bnRpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGxvYWRUaGVuTW91bnRQcm9taXNlcyA9IGFwcHNUb0xvYWQubWFwKChhcHApID0+IHtcbiAgICAgICAgICByZXR1cm4gdG9Mb2FkUHJvbWlzZShhcHApLnRoZW4oKGFwcCkgPT5cbiAgICAgICAgICAgIHRyeVRvQm9vdHN0cmFwQW5kTW91bnQoYXBwLCB1bm1vdW50QWxsUHJvbWlzZSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBUaGVzZSBhcmUgdGhlIGFwcHMgdGhhdCBhcmUgYWxyZWFkeSBib290c3RyYXBwZWQgYW5kIGp1c3QgbmVlZFxuICAgICAgICAgKiB0byBiZSBtb3VudGVkLiBUaGV5IGVhY2ggd2FpdCBmb3IgYWxsIHVubW91bnRpbmcgYXBwcyB0byBmaW5pc2ggdXBcbiAgICAgICAgICogYmVmb3JlIHRoZXkgbW91bnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBtb3VudFByb21pc2VzID0gYXBwc1RvTW91bnRcbiAgICAgICAgICAuZmlsdGVyKChhcHBUb01vdW50KSA9PiBhcHBzVG9Mb2FkLmluZGV4T2YoYXBwVG9Nb3VudCkgPCAwKVxuICAgICAgICAgIC5tYXAoKGFwcFRvTW91bnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnlUb0Jvb3RzdHJhcEFuZE1vdW50KGFwcFRvTW91bnQsIHVubW91bnRBbGxQcm9taXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVubW91bnRBbGxQcm9taXNlXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNhbGxBbGxFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLyogTm93IHRoYXQgdGhlIGFwcHMgdGhhdCBuZWVkZWQgdG8gYmUgdW5tb3VudGVkIGFyZSB1bm1vdW50ZWQsIHRoZWlyIERPTSBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgKiBldmVudHMgKGxpa2UgaGFzaGNoYW5nZSBvciBwb3BzdGF0ZSkgc2hvdWxkIGhhdmUgYmVlbiBjbGVhbmVkIHVwLiBTbyBpdCdzIHNhZmVcbiAgICAgICAgICAgICAqIHRvIGxldCB0aGUgcmVtYWluaW5nIGNhcHR1cmVkIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgYWJvdXQgdGhlIERPTSBldmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsbEFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkVGhlbk1vdW50UHJvbWlzZXMuY29uY2F0KG1vdW50UHJvbWlzZXMpKVxuICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9taXNlcy5mb3JFYWNoKChwcm9taXNlKSA9PiBwcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC50aGVuKGZpbmlzaFVwQW5kUmV0dXJuKVxuICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoX19QUk9GSUxFX18pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUHJvZmlsZUVudHJ5KFxuICAgICAgICAgICAgICAgICAgICAgIFwicm91dGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibG9hZEFuZE1vdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZXJLaW5kLFxuICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRGaW5pc2hlZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKF9fUFJPRklMRV9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb2ZpbGVFbnRyeShcbiAgICAgICAgICAgICAgICAgICAgICBcInJvdXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImxvYWRBbmRNb3VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVyS2luZCxcbiAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50RmluaXNoZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFVwQW5kUmV0dXJuKCkge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gZ2V0TW91bnRlZEFwcHMoKTtcbiAgICBwZW5kaW5nUHJvbWlzZXMuZm9yRWFjaCgocHJvbWlzZSkgPT4gcHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBwQ2hhbmdlRXZlbnROYW1lID1cbiAgICAgICAgYXBwc1RoYXRDaGFuZ2VkLmxlbmd0aCA9PT0gMCA/IFwibm8tYXBwLWNoYW5nZVwiIDogXCJhcHAtY2hhbmdlXCI7XG4gICAgICBmaXJlU2luZ2xlU3BhRXZlbnQoYXBwQ2hhbmdlRXZlbnROYW1lLCBnZXRDdXN0b21FdmVudERldGFpbCgpKTtcbiAgICAgIGZpcmVTaW5nbGVTcGFFdmVudChcInJvdXRpbmctZXZlbnRcIiwgZ2V0Q3VzdG9tRXZlbnREZXRhaWwoKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvKiBXZSB1c2UgYSBzZXRUaW1lb3V0IGJlY2F1c2UgaWYgc29tZW9uZSBlbHNlJ3MgZXZlbnQgaGFuZGxlciB0aHJvd3MgYW4gZXJyb3IsIHNpbmdsZS1zcGFcbiAgICAgICAqIG5lZWRzIHRvIGNhcnJ5IG9uLiBJZiBhIGxpc3RlbmVyIHRvIHRoZSBldmVudCB0aHJvd3MgYW4gZXJyb3IsIGl0J3MgdGhlaXIgb3duIGZhdWx0LCBub3RcbiAgICAgICAqIHNpbmdsZS1zcGEncy5cbiAgICAgICAqL1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIFNldHRpbmcgdGhpcyBhbGxvd3MgZm9yIHN1YnNlcXVlbnQgY2FsbHMgdG8gcmVyb3V0ZSgpIHRvIGFjdHVhbGx5IHBlcmZvcm1cbiAgICAgKiBhIHJlcm91dGUgaW5zdGVhZCBvZiBqdXN0IGdldHRpbmcgcXVldWVkIGJlaGluZCB0aGUgY3VycmVudCByZXJvdXRlIGNhbGwuXG4gICAgICogV2Ugd2FudCB0byBkbyB0aGlzIGFmdGVyIHRoZSBtb3VudGluZy91bm1vdW50aW5nIGlzIGRvbmUgYnV0IGJlZm9yZSB3ZVxuICAgICAqIHJlc29sdmUgdGhlIHByb21pc2UgZm9yIHRoZSBgcmVyb3V0ZWAgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXBwQ2hhbmdlVW5kZXJ3YXkgPSBmYWxzZTtcblxuICAgIGlmIChwZW9wbGVXYWl0aW5nT25BcHBDaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgLyogV2hpbGUgd2Ugd2VyZSByZXJvdXRpbmcsIHNvbWVvbmUgZWxzZSB0cmlnZ2VyZWQgYW5vdGhlciByZXJvdXRlIHRoYXQgZ290IHF1ZXVlZC5cbiAgICAgICAqIFNvIHdlIG5lZWQgcmVyb3V0ZSBhZ2Fpbi5cbiAgICAgICAqL1xuICAgICAgY29uc3QgbmV4dFBlbmRpbmdQcm9taXNlcyA9IHBlb3BsZVdhaXRpbmdPbkFwcENoYW5nZTtcbiAgICAgIHBlb3BsZVdhaXRpbmdPbkFwcENoYW5nZSA9IFtdO1xuICAgICAgcmVyb3V0ZShuZXh0UGVuZGluZ1Byb21pc2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICAvKiBXZSBuZWVkIHRvIGNhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IGhhdmUgYmVlbiBkZWxheWVkIGJlY2F1c2UgdGhleSB3ZXJlXG4gICAqIHdhaXRpbmcgb24gc2luZ2xlLXNwYS4gVGhpcyBpbmNsdWRlcyBoYXNjaGFuZ2UgYW5kIHBvcHN0YXRlIGV2ZW50cyBmb3IgYm90aFxuICAgKiB0aGUgY3VycmVudCBydW4gb2YgcGVyZm9ybUFwcENoYW5nZXMoKSwgYnV0IGFsc28gYWxsIG9mIHRoZSBxdWV1ZWQgZXZlbnQgbGlzdGVuZXJzLlxuICAgKiBXZSB3YW50IHRvIGNhbGwgdGhlIGxpc3RlbmVycyBpbiB0aGUgc2FtZSBvcmRlciBhcyBpZiB0aGV5IGhhZCBub3QgYmVlbiBkZWxheWVkIGJ5XG4gICAqIHNpbmdsZS1zcGEsIHdoaWNoIG1lYW5zIHF1ZXVlZCBvbmVzIGZpcnN0IGFuZCB0aGVuIHRoZSBtb3N0IHJlY2VudCBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWxsQWxsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLy8gRHVyaW5nIHNpbGVudCBuYXZpZ2F0aW9uICh3aGVuIG5hdmlnYXRpb24gd2FzIGNhbmNlbGVkIGFuZCB3ZSdyZSBnb2luZyBiYWNrIHRvIHRoZSBvbGQgVVJMKSxcbiAgICAvLyB3ZSBzaG91bGQgbm90IGZpcmUgYW55IHBvcHN0YXRlIC8gaGFzaGNoYW5nZSBldmVudHNcbiAgICBpZiAoIXNpbGVudE5hdmlnYXRpb24pIHtcbiAgICAgIHBlbmRpbmdQcm9taXNlcy5mb3JFYWNoKChwZW5kaW5nUHJvbWlzZSkgPT4ge1xuICAgICAgICBjYWxsQ2FwdHVyZWRFdmVudExpc3RlbmVycyhwZW5kaW5nUHJvbWlzZS5ldmVudEFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgICAgY2FsbENhcHR1cmVkRXZlbnRMaXN0ZW5lcnMoZXZlbnRBcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1c3RvbUV2ZW50RGV0YWlsKGlzQmVmb3JlQ2hhbmdlcyA9IGZhbHNlLCBleHRyYVByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBuZXdBcHBTdGF0dXNlcyA9IHt9O1xuICAgIGNvbnN0IGFwcHNCeU5ld1N0YXR1cyA9IHtcbiAgICAgIC8vIGZvciBhcHBzIHRoYXQgd2VyZSBtb3VudGVkXG4gICAgICBbTU9VTlRFRF06IFtdLFxuICAgICAgLy8gZm9yIGFwcHMgdGhhdCB3ZXJlIHVubW91bnRlZFxuICAgICAgW05PVF9NT1VOVEVEXTogW10sXG4gICAgICAvLyBhcHBzIHRoYXQgd2VyZSBmb3JjaWJseSB1bmxvYWRlZFxuICAgICAgW05PVF9MT0FERURdOiBbXSxcbiAgICAgIC8vIGFwcHMgdGhhdCBhdHRlbXB0ZWQgdG8gZG8gc29tZXRoaW5nIGJ1dCBhcmUgYnJva2VuIG5vd1xuICAgICAgW1NLSVBfQkVDQVVTRV9CUk9LRU5dOiBbXSxcbiAgICB9O1xuXG4gICAgaWYgKGlzQmVmb3JlQ2hhbmdlcykge1xuICAgICAgYXBwc1RvTG9hZC5jb25jYXQoYXBwc1RvTW91bnQpLmZvckVhY2goKGFwcCwgaW5kZXgpID0+IHtcbiAgICAgICAgYWRkQXBwKGFwcCwgTU9VTlRFRCk7XG4gICAgICB9KTtcbiAgICAgIGFwcHNUb1VubG9hZC5mb3JFYWNoKChhcHApID0+IHtcbiAgICAgICAgYWRkQXBwKGFwcCwgTk9UX0xPQURFRCk7XG4gICAgICB9KTtcbiAgICAgIGFwcHNUb1VubW91bnQuZm9yRWFjaCgoYXBwKSA9PiB7XG4gICAgICAgIGFkZEFwcChhcHAsIE5PVF9NT1VOVEVEKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBzVGhhdENoYW5nZWQuZm9yRWFjaCgoYXBwKSA9PiB7XG4gICAgICAgIGFkZEFwcChhcHApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIG5ld0FwcFN0YXR1c2VzLFxuICAgICAgICBhcHBzQnlOZXdTdGF0dXMsXG4gICAgICAgIHRvdGFsQXBwQ2hhbmdlczogYXBwc1RoYXRDaGFuZ2VkLmxlbmd0aCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRBcmd1bWVudHM/LlswXSxcbiAgICAgICAgb2xkVXJsLFxuICAgICAgICBuZXdVcmwsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpZiAoZXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ24ocmVzdWx0LmRldGFpbCwgZXh0cmFQcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gYWRkQXBwKGFwcCwgc3RhdHVzKSB7XG4gICAgICBjb25zdCBhcHBOYW1lID0gdG9OYW1lKGFwcCk7XG4gICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgZ2V0QXBwU3RhdHVzKGFwcE5hbWUpO1xuICAgICAgbmV3QXBwU3RhdHVzZXNbYXBwTmFtZV0gPSBzdGF0dXM7XG4gICAgICBjb25zdCBzdGF0dXNBcnIgPSAoYXBwc0J5TmV3U3RhdHVzW3N0YXR1c10gPVxuICAgICAgICBhcHBzQnlOZXdTdGF0dXNbc3RhdHVzXSB8fCBbXSk7XG4gICAgICBzdGF0dXNBcnIucHVzaChhcHBOYW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlU2luZ2xlU3BhRXZlbnQobmFtZSwgZXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgLy8gRHVyaW5nIHNpbGVudCBuYXZpZ2F0aW9uIChjYXVzZWQgYnkgbmF2aWdhdGlvbiBjYW5jZWxhdGlvbiksIHdlIHNob3VsZCBub3RcbiAgICAvLyBmaXJlIGFueSBzaW5nbGUtc3BhIGV2ZW50c1xuICAgIGlmICghc2lsZW50TmF2aWdhdGlvbikge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChgc2luZ2xlLXNwYToke25hbWV9YCwgZXZlbnRQcm9wZXJ0aWVzKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMZXQncyBpbWFnaW5lIHRoYXQgc29tZSBraW5kIG9mIGRlbGF5IG9jY3VycmVkIGR1cmluZyBhcHBsaWNhdGlvbiBsb2FkaW5nLlxuICogVGhlIHVzZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgYXBwbGljYXRpb24gdG8gbG9hZCBzd2l0Y2hlZCB0byBhbm90aGVyIHJvdXRlLFxuICogdGhpcyBtZWFucyB0aGF0IHdlIHNob3VsZG4ndCBib290c3RyYXAgYW5kIG1vdW50IHRoYXQgYXBwbGljYXRpb24sIHRodXMgd2UgY2hlY2tcbiAqIHR3aWNlIGlmIHRoYXQgYXBwbGljYXRpb24gc2hvdWxkIGJlIGFjdGl2ZSBiZWZvcmUgYm9vdHN0cmFwcGluZyBhbmQgbW91bnRpbmcuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhL2lzc3Vlcy81MjRcbiAqL1xuZnVuY3Rpb24gdHJ5VG9Cb290c3RyYXBBbmRNb3VudChhcHAsIHVubW91bnRBbGxQcm9taXNlKSB7XG4gIGlmIChzaG91bGRCZUFjdGl2ZShhcHApKSB7XG4gICAgcmV0dXJuIHRvQm9vdHN0cmFwUHJvbWlzZShhcHApLnRoZW4oKGFwcCkgPT5cbiAgICAgIHVubW91bnRBbGxQcm9taXNlLnRoZW4oKCkgPT5cbiAgICAgICAgc2hvdWxkQmVBY3RpdmUoYXBwKSA/IHRvTW91bnRQcm9taXNlKGFwcCkgOiBhcHBcbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bm1vdW50QWxsUHJvbWlzZS50aGVuKCgpID0+IGFwcCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHJlcm91dGUgfSBmcm9tIFwiLi9uYXZpZ2F0aW9uL3Jlcm91dGUuanNcIjtcbmltcG9ydCB7IHBhdGNoSGlzdG9yeUFwaSB9IGZyb20gXCIuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1ldmVudHMuanNcIjtcbmltcG9ydCB7IGlzSW5Ccm93c2VyIH0gZnJvbSBcIi4vdXRpbHMvcnVudGltZS1lbnZpcm9ubWVudC5qc1wiO1xuXG5sZXQgc3RhcnRlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQob3B0cykge1xuICBzdGFydGVkID0gdHJ1ZTtcbiAgaWYgKGlzSW5Ccm93c2VyKSB7XG4gICAgcGF0Y2hIaXN0b3J5QXBpKG9wdHMpO1xuICAgIHJlcm91dGUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFydGVkKCkge1xuICByZXR1cm4gc3RhcnRlZDtcbn1cbiIsImltcG9ydCB7IGdldFJhd0FwcERhdGEsIHVucmVnaXN0ZXJBcHBsaWNhdGlvbiB9IGZyb20gXCIuLi9hcHBsaWNhdGlvbnMvYXBwc1wiO1xuaW1wb3J0IHsgcmVyb3V0ZSB9IGZyb20gXCIuLi9uYXZpZ2F0aW9uL3Jlcm91dGVcIjtcbmltcG9ydCB7IE5PVF9MT0FERUQgfSBmcm9tIFwiLi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzXCI7XG5pbXBvcnQgeyB0b0xvYWRQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvbG9hZFwiO1xuaW1wb3J0IHsgdG9Cb290c3RyYXBQcm9taXNlIH0gZnJvbSBcIi4uL2xpZmVjeWNsZXMvYm9vdHN0cmFwXCI7XG5pbXBvcnQgeyBnZXRQcm9maWxlckRhdGEgfSBmcm9tIFwiLi9wcm9maWxlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldFJhd0FwcERhdGEsXG4gIHJlcm91dGUsXG4gIE5PVF9MT0FERUQsXG4gIHRvTG9hZFByb21pc2UsXG4gIHRvQm9vdHN0cmFwUHJvbWlzZSxcbiAgdW5yZWdpc3RlckFwcGxpY2F0aW9uLFxuICBnZXRQcm9maWxlckRhdGEsXG59O1xuIiwiZXhwb3J0IHsgc3RhcnQgfSBmcm9tIFwiLi9zdGFydC5qc1wiO1xuZXhwb3J0IHsgZW5zdXJlSlF1ZXJ5U3VwcG9ydCB9IGZyb20gXCIuL2pxdWVyeS1zdXBwb3J0LmpzXCI7XG5leHBvcnQge1xuICBzZXRCb290c3RyYXBNYXhUaW1lLFxuICBzZXRNb3VudE1heFRpbWUsXG4gIHNldFVubW91bnRNYXhUaW1lLFxuICBzZXRVbmxvYWRNYXhUaW1lLFxufSBmcm9tIFwiLi9hcHBsaWNhdGlvbnMvdGltZW91dHMuanNcIjtcbmV4cG9ydCB7XG4gIHJlZ2lzdGVyQXBwbGljYXRpb24sXG4gIHVucmVnaXN0ZXJBcHBsaWNhdGlvbixcbiAgZ2V0TW91bnRlZEFwcHMsXG4gIGdldEFwcFN0YXR1cyxcbiAgdW5sb2FkQXBwbGljYXRpb24sXG4gIGNoZWNrQWN0aXZpdHlGdW5jdGlvbnMsXG4gIGdldEFwcE5hbWVzLFxuICBwYXRoVG9BY3RpdmVXaGVuLFxufSBmcm9tIFwiLi9hcHBsaWNhdGlvbnMvYXBwcy5qc1wiO1xuZXhwb3J0IHtcbiAgbmF2aWdhdGVUb1VybCxcbiAgcGF0Y2hIaXN0b3J5QXBpLFxufSBmcm9tIFwiLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24tZXZlbnRzLmpzXCI7XG5leHBvcnQgeyB0cmlnZ2VyQXBwQ2hhbmdlIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9yZXJvdXRlLmpzXCI7XG5leHBvcnQge1xuICBhZGRFcnJvckhhbmRsZXIsXG4gIHJlbW92ZUVycm9ySGFuZGxlcixcbn0gZnJvbSBcIi4vYXBwbGljYXRpb25zL2FwcC1lcnJvcnMuanNcIjtcbmV4cG9ydCB7IG1vdW50Um9vdFBhcmNlbCB9IGZyb20gXCIuL3BhcmNlbHMvbW91bnQtcGFyY2VsLmpzXCI7XG5cbmV4cG9ydCB7XG4gIE5PVF9MT0FERUQsXG4gIExPQURJTkdfU09VUkNFX0NPREUsXG4gIE5PVF9CT09UU1RSQVBQRUQsXG4gIEJPT1RTVFJBUFBJTkcsXG4gIE5PVF9NT1VOVEVELFxuICBNT1VOVElORyxcbiAgVVBEQVRJTkcsXG4gIExPQURfRVJST1IsXG4gIE1PVU5URUQsXG4gIFVOTE9BRElORyxcbiAgVU5NT1VOVElORyxcbiAgU0tJUF9CRUNBVVNFX0JST0tFTixcbn0gZnJvbSBcIi4vYXBwbGljYXRpb25zL2FwcC5oZWxwZXJzLmpzXCI7XG5cbmltcG9ydCBkZXZ0b29scyBmcm9tIFwiLi9kZXZ0b29scy9kZXZ0b29sc1wiO1xuaW1wb3J0IHsgaXNJbkJyb3dzZXIgfSBmcm9tIFwiLi91dGlscy9ydW50aW1lLWVudmlyb25tZW50LmpzXCI7XG5cbmlmIChpc0luQnJvd3NlciAmJiB3aW5kb3cuX19TSU5HTEVfU1BBX0RFVlRPT0xTX18pIHtcbiAgd2luZG93Ll9fU0lOR0xFX1NQQV9ERVZUT09MU19fLmV4cG9zZWRNZXRob2RzID0gZGV2dG9vbHM7XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZXJyb3JIYW5kbGVycyIsImhhbmRsZUFwcEVycm9yIiwiZXJyIiwiYXBwIiwibmV3U3RhdHVzIiwidHJhbnNmb3JtZWRFcnIiLCJ0cmFuc2Zvcm1FcnIiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaGFuZGxlciIsInNldFRpbWVvdXQiLCJhZGRFcnJvckhhbmRsZXIiLCJFcnJvciIsImZvcm1hdEVycm9yTWVzc2FnZSIsInB1c2giLCJyZW1vdmVFcnJvckhhbmRsZXIiLCJyZW1vdmVkU29tZXRoaW5nIiwiZmlsdGVyIiwiaCIsImlzSGFuZGxlciIsImNvZGUiLCJtc2ciLCJhcmdzIiwiam9pbiIsIm9nRXJyIiwiYXBwT3JQYXJjZWwiLCJlcnJQcmVmaXgiLCJvYmplY3RUeXBlIiwidG9OYW1lIiwic3RhdHVzIiwicmVzdWx0IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiSlNPTiIsInN0cmluZ2lmeSIsImFwcE9yUGFyY2VsTmFtZSIsIk5PVF9MT0FERUQiLCJMT0FESU5HX1NPVVJDRV9DT0RFIiwiTk9UX0JPT1RTVFJBUFBFRCIsIkJPT1RTVFJBUFBJTkciLCJOT1RfTU9VTlRFRCIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVQREFUSU5HIiwiVU5NT1VOVElORyIsIlVOTE9BRElORyIsIkxPQURfRVJST1IiLCJTS0lQX0JFQ0FVU0VfQlJPS0VOIiwiaXNBY3RpdmUiLCJzaG91bGRCZUFjdGl2ZSIsImFjdGl2ZVdoZW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm5hbWUiLCJpc1BhcmNlbCIsIkJvb2xlYW4iLCJ1bm1vdW50VGhpc1BhcmNlbCIsImFzc2lnbiIsImkiLCJhcmd1bWVudHMiLCJrZXkiLCJmaW5kIiwiYXJyIiwiZnVuYyIsInZhbGlkTGlmZWN5Y2xlRm4iLCJmbiIsImlzQXJyYXlPZkZucyIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW0iLCJmbGF0dGVuRm5BcnJheSIsImxpZmVjeWNsZSIsImZucyIsIlByb21pc2UiLCJyZXNvbHZlIiwidHlwZSIsInByb3BzIiwicmVkdWNlIiwicmVzdWx0UHJvbWlzZSIsImluZGV4IiwidGhlbiIsInRoaXNQcm9taXNlIiwic21lbGxzTGlrZUFQcm9taXNlIiwicmVqZWN0IiwicHJvbWlzZSIsImNhdGNoIiwicHJvZmlsZUVudHJpZXMiLCJnZXRQcm9maWxlckRhdGEiLCJhZGRQcm9maWxlRW50cnkiLCJraW5kIiwic3RhcnQiLCJlbmQiLCJvcGVyYXRpb25TdWNjZWVkZWQiLCJ0b0Jvb3RzdHJhcFByb21pc2UiLCJoYXJkRmFpbCIsInN0YXJ0VGltZSIsInByb2ZpbGVFdmVudFR5cGUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImJvb3RzdHJhcCIsInN1Y2Nlc3NmdWxCb290c3RyYXAiLCJyZWFzb25hYmxlVGltZSIsInRvVW5tb3VudFByb21pc2UiLCJ1bm1vdW50Q2hpbGRyZW5QYXJjZWxzIiwiT2JqZWN0Iiwia2V5cyIsInBhcmNlbHMiLCJtYXAiLCJwYXJjZWxJZCIsImFsbCIsInVubW91bnRBcHBPclBhcmNlbCIsInBhcmNlbEVycm9yIiwicGFyZW50RXJyb3IiLCJiZWZvcmVGaXJzdE1vdW50RmlyZWQiLCJmaXJzdE1vdW50RmlyZWQiLCJ0b01vdW50UHJvbWlzZSIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInNldFNraXBCZWNhdXNlQnJva2VuIiwidG9VcGRhdGVQcm9taXNlIiwicGFyY2VsQ291bnQiLCJyb290UGFyY2VscyIsIm1vdW50Um9vdFBhcmNlbCIsIm1vdW50UGFyY2VsIiwiYXBwbHkiLCJjb25maWciLCJjdXN0b21Qcm9wcyIsIm93bmluZ0FwcE9yUGFyY2VsIiwiaWQiLCJkb21FbGVtZW50IiwicGFzc2VkQ29uZmlnTG9hZGluZ0Z1bmN0aW9uIiwiY29uZmlnTG9hZGluZ0Z1bmN0aW9uIiwicGFyY2VsIiwicGFyZW50TmFtZSIsIm1vdW50UHJvbWlzZSIsInZhbHVlIiwicmVzb2x2ZVVubW91bnQiLCJyZWplY3RVbm1vdW50IiwiZXh0ZXJuYWxSZXByZXNlbnRhdGlvbiIsImxvYWRQcm9taXNlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibW91bnQiLCJ1bm1vdW50IiwidXBkYXRlIiwidGltZW91dHMiLCJlbnN1cmVWYWxpZEFwcFRpbWVvdXRzIiwicHJvbWlzZVdpdGhvdXRSZXR1cm5WYWx1ZSIsImJvb3RzdHJhcFByb21pc2UiLCJ1bm1vdW50UHJvbWlzZSIsImdldFN0YXR1cyIsImdldFByb3BzIiwiYmluZCIsInNpbmdsZVNwYSIsInVubW91bnRTZWxmIiwiZGVmYXVsdFdhcm5pbmdNaWxsaXMiLCJnbG9iYWxUaW1lb3V0Q29uZmlnIiwibWlsbGlzIiwiZGllT25UaW1lb3V0Iiwid2FybmluZ01pbGxpcyIsInVubG9hZCIsInNldEJvb3RzdHJhcE1heFRpbWUiLCJ0aW1lIiwic2V0TW91bnRNYXhUaW1lIiwic2V0VW5tb3VudE1heFRpbWUiLCJzZXRVbmxvYWRNYXhUaW1lIiwidGltZW91dENvbmZpZyIsIndhcm5pbmdQZXJpb2QiLCJmaW5pc2hlZCIsImVycm9yZWQiLCJ2YWwiLCJtYXliZVRpbWluZ091dCIsImVyck1zZyIsInNob3VsZEVycm9yIiwiZXJyb3IiLCJudW1XYXJuaW5ncyIsIm51bU1pbGxpcyIsInRvTG9hZFByb21pc2UiLCJhcHBPcHRzIiwiaXNVc2VyRXJyIiwibG9hZEFwcCIsImxvYWRFcnJvclRpbWUiLCJ2YWxpZGF0aW9uRXJyTWVzc2FnZSIsInZhbGlkYXRpb25FcnJDb2RlIiwiYXBwT3B0c1N0ciIsImRldnRvb2xzIiwib3ZlcmxheXMiLCJEYXRlIiwiZ2V0VGltZSIsImlzSW5Ccm93c2VyIiwiY2FwdHVyZWRFdmVudExpc3RlbmVycyIsImhhc2hjaGFuZ2UiLCJwb3BzdGF0ZSIsInJvdXRpbmdFdmVudHNMaXN0ZW5pbmdUbyIsIm5hdmlnYXRlVG9VcmwiLCJvYmoiLCJ1cmwiLCJocmVmIiwiY3VycmVudFRhcmdldCIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudCIsInBhcnNlVXJpIiwiZGVzdGluYXRpb24iLCJpbmRleE9mIiwiaGFzaCIsImhvc3QiLCJwYXRobmFtZSIsInNlYXJjaCIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJjYWxsQ2FwdHVyZWRFdmVudExpc3RlbmVycyIsImV2ZW50QXJndW1lbnRzIiwiZXZlbnRUeXBlIiwibGlzdGVuZXIiLCJlIiwidXJsUmVyb3V0ZU9ubHkiLCJ1cmxSZXJvdXRlIiwicmVyb3V0ZSIsInBhdGNoZWRVcGRhdGVTdGF0ZSIsInVwZGF0ZVN0YXRlIiwibWV0aG9kTmFtZSIsInVybEJlZm9yZSIsInVybEFmdGVyIiwiY3JlYXRlUG9wU3RhdGVFdmVudCIsInN0YXRlIiwib3JpZ2luYWxNZXRob2ROYW1lIiwiZXZ0IiwiUG9wU3RhdGVFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0UG9wU3RhdGVFdmVudCIsInNpbmdsZVNwYVRyaWdnZXIiLCJvcmlnaW5hbFJlcGxhY2VTdGF0ZSIsImhpc3RvcnlBcGlJc1BhdGNoZWQiLCJwYXRjaEhpc3RvcnlBcGkiLCJvcHRzIiwicmVwbGFjZVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9yaWdpbmFsQWRkRXZlbnRMaXN0ZW5lciIsIm9yaWdpbmFsUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJsaXN0ZW5lckZuIiwic2luZ2xlU3BhTmF2aWdhdGUiLCJzdHIiLCJhbmNob3IiLCJjcmVhdGVFbGVtZW50IiwiaGFzSW5pdGlhbGl6ZWQiLCJlbnN1cmVKUXVlcnlTdXBwb3J0IiwialF1ZXJ5IiwiJCIsImpxdWVyeSIsIm9yaWdpbmFsSlF1ZXJ5T24iLCJvbiIsIm9yaWdpbmFsSlF1ZXJ5T2ZmIiwib2ZmIiwiZXZlbnRTdHJpbmciLCJjYXB0dXJlUm91dGluZ0V2ZW50cyIsIm9yaWdpbmFsSlF1ZXJ5RnVuY3Rpb24iLCJuYXRpdmVGdW5jdGlvblRvQ2FsbCIsIm9yaWdpbmFsQXJncyIsImV2ZW50TmFtZXMiLCJzcGxpdCIsInJlcGxhY2UiLCJ0cmltIiwiYXBwc1RvVW5sb2FkIiwidG9VbmxvYWRQcm9taXNlIiwidW5sb2FkSW5mbyIsImZpbmlzaFVubG9hZGluZ0FwcCIsInVubG9hZFByb21pc2UiLCJlcnJvclVubG9hZGluZ0FwcCIsImFkZEFwcFRvVW5sb2FkIiwicHJvbWlzZUdldHRlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZ2V0QXBwVW5sb2FkSW5mbyIsImFwcE5hbWUiLCJhcHBzIiwiZ2V0QXBwQ2hhbmdlcyIsImFwcHNUb1VubW91bnQiLCJhcHBzVG9Mb2FkIiwiYXBwc1RvTW91bnQiLCJjdXJyZW50VGltZSIsImFwcFNob3VsZEJlQWN0aXZlIiwiZ2V0TW91bnRlZEFwcHMiLCJnZXRBcHBOYW1lcyIsImdldFJhd0FwcERhdGEiLCJnZXRBcHBTdGF0dXMiLCJzdGFydFdhcm5pbmdJbml0aWFsaXplZCIsInJlZ2lzdGVyQXBwbGljYXRpb24iLCJhcHBOYW1lT3JDb25maWciLCJhcHBPckxvYWRBcHAiLCJyZWdpc3RyYXRpb24iLCJzYW5pdGl6ZUFyZ3VtZW50cyIsImlzU3RhcnRlZCIsIm9wdGlvbnMiLCJzZWxlY3RvcnMiLCJjaGVja0FjdGl2aXR5RnVuY3Rpb25zIiwidW5yZWdpc3RlckFwcGxpY2F0aW9uIiwidW5sb2FkQXBwbGljYXRpb24iLCJ3YWl0Rm9yVW5tb3VudCIsImFwcEluZGV4Iiwic3BsaWNlIiwiQXBwIiwiYXBwVW5sb2FkSW5mbyIsImltbWVkaWF0ZWx5VW5sb2FkQXBwIiwiYWN0aXZlQXBwIiwidHJpZ2dlckFwcENoYW5nZSIsInZhbGlkYXRlUmVnaXN0ZXJXaXRoQXJndW1lbnRzIiwidmFsaWRDdXN0b21Qcm9wcyIsInZhbGlkYXRlUmVnaXN0ZXJXaXRoQ29uZmlnIiwidmFsaWRLZXlzIiwiaW52YWxpZEtleXMiLCJwcm9wIiwiY29uY2F0IiwiYWxsb3dzU3RyaW5nQW5kRnVuY3Rpb24iLCJldmVyeSIsInVzaW5nT2JqZWN0QVBJIiwic2FuaXRpemVMb2FkQXBwIiwic2FuaXRpemVDdXN0b21Qcm9wcyIsInNhbml0aXplQWN0aXZlV2hlbiIsImFjdGl2ZVdoZW5BcnJheSIsImFjdGl2ZVdoZW5PclBhdGgiLCJwYXRoVG9BY3RpdmVXaGVuIiwic29tZSIsInBhdGgiLCJleGFjdE1hdGNoIiwicmVnZXgiLCJ0b0R5bmFtaWNQYXRoVmFsaWRhdG9yUmVnZXgiLCJvcmlnaW4iLCJwcm90b2NvbCIsInJvdXRlIiwidGVzdCIsImxhc3RJbmRleCIsImluRHluYW1pYyIsInJlZ2V4U3RyIiwiY2hhckluZGV4IiwiY2hhciIsInN0YXJ0T2ZEeW5hbWljIiwiZW5kT2ZEeW5hbWljIiwiYXBwZW5kVG9SZWdleCIsIlJlZ0V4cCIsImFueUNoYXJNYXliZVRyYWlsaW5nU2xhc2hSZWdleCIsImNvbW1vblN0cmluZ1N1YlBhdGgiLCJlc2NhcGVTdHJSZWdleCIsInNsaWNlIiwic3VmZml4IiwiY2hhckF0IiwiYXBwQ2hhbmdlVW5kZXJ3YXkiLCJwZW9wbGVXYWl0aW5nT25BcHBDaGFuZ2UiLCJjdXJyZW50VXJsIiwicGVuZGluZ1Byb21pc2VzIiwic2lsZW50TmF2aWdhdGlvbiIsInByb2ZpbGVyS2luZCIsImFwcHNUaGF0Q2hhbmdlZCIsImNhbmNlbFByb21pc2VzIiwib2xkVXJsIiwibmV3VXJsIiwicGVyZm9ybUFwcENoYW5nZXMiLCJsb2FkQXBwcyIsImNhbmNlbE5hdmlnYXRpb24iLCJsb2FkUHJvbWlzZXMiLCJzdWNjZWVkZWQiLCJjYWxsQWxsRXZlbnRMaXN0ZW5lcnMiLCJmaW5hbGx5IiwiZmlyZVNpbmdsZVNwYUV2ZW50IiwiZ2V0Q3VzdG9tRXZlbnREZXRhaWwiLCJjYW5jZWxWYWx1ZXMiLCJuYXZpZ2F0aW9uSXNDYW5jZWxlZCIsInYiLCJzdWJzdHJpbmciLCJ1bmxvYWRQcm9taXNlcyIsInVubW91bnRVbmxvYWRQcm9taXNlcyIsImFsbFVubW91bnRQcm9taXNlcyIsInVubW91bnRBbGxQcm9taXNlIiwidW5tb3VudEZpbmlzaGVkVGltZSIsImxvYWRUaGVuTW91bnRQcm9taXNlcyIsInRyeVRvQm9vdHN0cmFwQW5kTW91bnQiLCJtb3VudFByb21pc2VzIiwiYXBwVG9Nb3VudCIsImZpbmlzaFVwQW5kUmV0dXJuIiwicmV0dXJuVmFsdWUiLCJhcHBDaGFuZ2VFdmVudE5hbWUiLCJuZXh0UGVuZGluZ1Byb21pc2VzIiwicGVuZGluZ1Byb21pc2UiLCJpc0JlZm9yZUNoYW5nZXMiLCJleHRyYVByb3BlcnRpZXMiLCJuZXdBcHBTdGF0dXNlcyIsImFwcHNCeU5ld1N0YXR1cyIsImFkZEFwcCIsImRldGFpbCIsInRvdGFsQXBwQ2hhbmdlcyIsIm9yaWdpbmFsRXZlbnQiLCJzdGF0dXNBcnIiLCJldmVudFByb3BlcnRpZXMiLCJzdGFydGVkIiwiX19TSU5HTEVfU1BBX0RFVlRPT0xTX18iLCJleHBvc2VkTWV0aG9kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/single-spa/lib/es2015/esm/single-spa.dev.js\n");

/***/ })

}]);