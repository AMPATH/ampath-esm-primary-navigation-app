"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_openmrs_esm_app_shell"] = self["webpackChunk_openmrs_esm_app_shell"] || []).push([["vendors-node_modules_i18next_dist_esm_i18next_js"],{

/***/ "../../../node_modules/i18next/dist/esm/i18next.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/i18next/dist/esm/i18next.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   keyFromSelector: () => (/* binding */ keysFromSelector),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _assert_this_initialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _call_super(_this, derived, args) {\n    derived = _get_prototype_of(derived);\n    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _possible_constructor_return(self, call) {\n    if (call && (_type_of(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assert_this_initialized(self);\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_array(arr) {\n    return _array_with_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nvar isString = function(obj) {\n    return typeof obj === 'string';\n};\nvar defer = function() {\n    var res;\n    var rej;\n    var promise = new Promise(function(resolve, reject) {\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nvar makeString = function(object) {\n    if (object == null) return '';\n    return '' + object;\n};\nvar copy = function(a, s, t) {\n    a.forEach(function(m) {\n        if (s[m]) t[m] = s[m];\n    });\n};\nvar lastOfPathSeparatorRegExp = /###/g;\nvar cleanKey = function(key) {\n    return key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;\n};\nvar canNotTraverseDeeper = function(object) {\n    return !object || isString(object);\n};\nvar getLastOfPath = function(object, path, Empty) {\n    var stack = !isString(path) ? path : path.split('.');\n    var stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        var key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nvar setPath = function(object, path, newValue) {\n    var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    var e = path[path.length - 1];\n    var p = path.slice(0, path.length - 1);\n    var last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = \"\".concat(p[p.length - 1], \".\").concat(e);\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if ((last === null || last === void 0 ? void 0 : last.obj) && typeof last.obj[\"\".concat(last.k, \".\").concat(e)] !== 'undefined') {\n            last.obj = undefined;\n        }\n    }\n    last.obj[\"\".concat(last.k, \".\").concat(e)] = newValue;\n};\nvar pushPath = function(object, path, newValue, concat) {\n    var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nvar getPath = function(object, path) {\n    var _getLastOfPath = getLastOfPath(object, path), obj = _getLastOfPath.obj, k = _getLastOfPath.k;\n    if (!obj) return undefined;\n    if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n    return obj[k];\n};\nvar getPathWithDefaults = function(data, defaultData, key) {\n    var value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nvar deepExtend = function(target, source, overwrite) {\n    for(var prop in source){\n        if (prop !== '__proto__' && prop !== 'constructor') {\n            if (prop in target) {\n                if (isString(target[prop]) || _instanceof(target[prop], String) || isString(source[prop]) || _instanceof(source[prop], String)) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nvar regexEscape = function(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n};\nvar _entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;'\n};\nvar escape = function(data) {\n    if (isString(data)) {\n        return data.replace(/[&<>\"'\\/]/g, function(s) {\n            return _entityMap[s];\n        });\n    }\n    return data;\n};\nvar RegExpCache = /*#__PURE__*/ function() {\n    \"use strict\";\n    function RegExpCache(capacity) {\n        _class_call_check(this, RegExpCache);\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    _create_class(RegExpCache, [\n        {\n            key: \"getRegExp\",\n            value: function getRegExp(pattern) {\n                var regExpFromCache = this.regExpMap.get(pattern);\n                if (regExpFromCache !== undefined) {\n                    return regExpFromCache;\n                }\n                var regExpNew = new RegExp(pattern);\n                if (this.regExpQueue.length === this.capacity) {\n                    this.regExpMap.delete(this.regExpQueue.shift());\n                }\n                this.regExpMap.set(pattern, regExpNew);\n                this.regExpQueue.push(pattern);\n                return regExpNew;\n            }\n        }\n    ]);\n    return RegExpCache;\n}();\nvar chars = [\n    ' ',\n    ',',\n    '?',\n    '!',\n    ';'\n];\nvar looksLikeObjectPathRegExpCache = new RegExpCache(20);\nvar looksLikeObjectPath = function(key, nsSeparator, keySeparator) {\n    nsSeparator = nsSeparator || '';\n    keySeparator = keySeparator || '';\n    var possibleChars = chars.filter(function(c) {\n        return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;\n    });\n    if (possibleChars.length === 0) return true;\n    var r = looksLikeObjectPathRegExpCache.getRegExp(\"(\".concat(possibleChars.map(function(c) {\n        return c === '?' ? '\\\\?' : c;\n    }).join('|'), \")\"));\n    var matched = !r.test(key);\n    if (!matched) {\n        var ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nvar deepFind = function(obj, path) {\n    var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '.';\n    if (!obj) return undefined;\n    if (obj[path]) {\n        if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n        return obj[path];\n    }\n    var tokens = path.split(keySeparator);\n    var current = obj;\n    for(var i = 0; i < tokens.length;){\n        if (!current || (typeof current === \"undefined\" ? \"undefined\" : _type_of(current)) !== 'object') {\n            return undefined;\n        }\n        var next = void 0;\n        var nextPath = '';\n        for(var j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    'string',\n                    'number',\n                    'boolean'\n                ].indexOf(typeof next === \"undefined\" ? \"undefined\" : _type_of(next)) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nvar getCleanedCode = function(code) {\n    return code === null || code === void 0 ? void 0 : code.replace('_', '-');\n};\nvar consoleLogger = {\n    type: 'logger',\n    log: function log(args) {\n        this.output('log', args);\n    },\n    warn: function warn(args) {\n        this.output('warn', args);\n    },\n    error: function error(args) {\n        this.output('error', args);\n    },\n    output: function output(type, args) {\n        var _console_type_apply, _console_type, _console;\n        (_console = console) === null || _console === void 0 ? void 0 : (_console_type = _console[type]) === null || _console_type === void 0 ? void 0 : (_console_type_apply = _console_type.apply) === null || _console_type_apply === void 0 ? void 0 : _console_type_apply.call(_console_type, console, args);\n    }\n};\nvar Logger = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Logger(concreteLogger) {\n        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _class_call_check(this, Logger);\n        this.init(concreteLogger, options);\n    }\n    _create_class(Logger, [\n        {\n            key: \"init\",\n            value: function init(concreteLogger) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                this.prefix = options.prefix || 'i18next:';\n                this.logger = concreteLogger || consoleLogger;\n                this.options = options;\n                this.debug = options.debug;\n            }\n        },\n        {\n            key: \"log\",\n            value: function log() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return this.forward(args, 'log', '', true);\n            }\n        },\n        {\n            key: \"warn\",\n            value: function warn() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return this.forward(args, 'warn', '', true);\n            }\n        },\n        {\n            key: \"error\",\n            value: function error() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return this.forward(args, 'error', '');\n            }\n        },\n        {\n            key: \"deprecate\",\n            value: function deprecate() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n            }\n        },\n        {\n            key: \"forward\",\n            value: function forward(args, lvl, prefix, debugOnly) {\n                if (debugOnly && !this.debug) return null;\n                if (isString(args[0])) args[0] = \"\".concat(prefix).concat(this.prefix, \" \").concat(args[0]);\n                return this.logger[lvl](args);\n            }\n        },\n        {\n            key: \"create\",\n            value: function create(moduleName) {\n                return new Logger(this.logger, _object_spread({}, {\n                    prefix: \"\".concat(this.prefix, \":\").concat(moduleName, \":\")\n                }, this.options));\n            }\n        },\n        {\n            key: \"clone\",\n            value: function clone(options) {\n                options = options || this.options;\n                options.prefix = options.prefix || this.prefix;\n                return new Logger(this.logger, options);\n            }\n        }\n    ]);\n    return Logger;\n}();\nvar baseLogger = new Logger();\nvar EventEmitter = /*#__PURE__*/ function() {\n    \"use strict\";\n    function EventEmitter() {\n        _class_call_check(this, EventEmitter);\n        this.observers = {};\n    }\n    _create_class(EventEmitter, [\n        {\n            key: \"on\",\n            value: function on(events, listener) {\n                var _this = this;\n                events.split(' ').forEach(function(event) {\n                    if (!_this.observers[event]) _this.observers[event] = new Map();\n                    var numListeners = _this.observers[event].get(listener) || 0;\n                    _this.observers[event].set(listener, numListeners + 1);\n                });\n                return this;\n            }\n        },\n        {\n            key: \"off\",\n            value: function off(event, listener) {\n                if (!this.observers[event]) return;\n                if (!listener) {\n                    delete this.observers[event];\n                    return;\n                }\n                this.observers[event].delete(listener);\n            }\n        },\n        {\n            key: \"emit\",\n            value: function emit(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (this.observers[event]) {\n                    var cloned = Array.from(this.observers[event].entries());\n                    cloned.forEach(function(param) {\n                        var _param = _sliced_to_array(param, 2), observer = _param[0], numTimesAdded = _param[1];\n                        for(var i = 0; i < numTimesAdded; i++){\n                            observer.apply(void 0, _to_consumable_array(args));\n                        }\n                    });\n                }\n                if (this.observers['*']) {\n                    var cloned1 = Array.from(this.observers['*'].entries());\n                    cloned1.forEach(function(param) {\n                        var _param = _sliced_to_array(param, 2), observer = _param[0], numTimesAdded = _param[1];\n                        for(var i = 0; i < numTimesAdded; i++){\n                            observer.apply(observer, [\n                                event\n                            ].concat(_to_consumable_array(args)));\n                        }\n                    });\n                }\n            }\n        }\n    ]);\n    return EventEmitter;\n}();\nvar ResourceStore = /*#__PURE__*/ function(EventEmitter) {\n    \"use strict\";\n    _inherits(ResourceStore, EventEmitter);\n    function ResourceStore(data) {\n        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            ns: [\n                'translation'\n            ],\n            defaultNS: 'translation'\n        };\n        _class_call_check(this, ResourceStore);\n        var _this;\n        _this = _call_super(this, ResourceStore);\n        _this.data = data || {};\n        _this.options = options;\n        if (_this.options.keySeparator === undefined) {\n            _this.options.keySeparator = '.';\n        }\n        if (_this.options.ignoreJSONStructure === undefined) {\n            _this.options.ignoreJSONStructure = true;\n        }\n        return _this;\n    }\n    _create_class(ResourceStore, [\n        {\n            key: \"addNamespaces\",\n            value: function addNamespaces(ns) {\n                if (this.options.ns.indexOf(ns) < 0) {\n                    this.options.ns.push(ns);\n                }\n            }\n        },\n        {\n            key: \"removeNamespaces\",\n            value: function removeNamespaces(ns) {\n                var index = this.options.ns.indexOf(ns);\n                if (index > -1) {\n                    this.options.ns.splice(index, 1);\n                }\n            }\n        },\n        {\n            key: \"getResource\",\n            value: function getResource(lng, ns, key) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                var _this_data_lng, _this_data;\n                var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n                var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n                var path;\n                if (lng.indexOf('.') > -1) {\n                    path = lng.split('.');\n                } else {\n                    path = [\n                        lng,\n                        ns\n                    ];\n                    if (key) {\n                        if (Array.isArray(key)) {\n                            var _path;\n                            (_path = path).push.apply(_path, _to_consumable_array(key));\n                        } else if (isString(key) && keySeparator) {\n                            var _path1;\n                            (_path1 = path).push.apply(_path1, _to_consumable_array(key.split(keySeparator)));\n                        } else {\n                            path.push(key);\n                        }\n                    }\n                }\n                var result = getPath(this.data, path);\n                if (!result && !ns && !key && lng.indexOf('.') > -1) {\n                    lng = path[0];\n                    ns = path[1];\n                    key = path.slice(2).join('.');\n                }\n                if (result || !ignoreJSONStructure || !isString(key)) return result;\n                return deepFind((_this_data = this.data) === null || _this_data === void 0 ? void 0 : (_this_data_lng = _this_data[lng]) === null || _this_data_lng === void 0 ? void 0 : _this_data_lng[ns], key, keySeparator);\n            }\n        },\n        {\n            key: \"addResource\",\n            value: function addResource(lng, ns, key, value) {\n                var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n                    silent: false\n                };\n                var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n                var path = [\n                    lng,\n                    ns\n                ];\n                if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n                if (lng.indexOf('.') > -1) {\n                    path = lng.split('.');\n                    value = ns;\n                    ns = path[1];\n                }\n                this.addNamespaces(ns);\n                setPath(this.data, path, value);\n                if (!options.silent) this.emit('added', lng, ns, key, value);\n            }\n        },\n        {\n            key: \"addResources\",\n            value: function addResources(lng, ns, resources) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n                    silent: false\n                };\n                for(var m in resources){\n                    if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                        silent: true\n                    });\n                }\n                if (!options.silent) this.emit('added', lng, ns, resources);\n            }\n        },\n        {\n            key: \"addResourceBundle\",\n            value: function addResourceBundle(lng, ns, resources, deep, overwrite) {\n                var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {\n                    silent: false,\n                    skipCopy: false\n                };\n                var path = [\n                    lng,\n                    ns\n                ];\n                if (lng.indexOf('.') > -1) {\n                    path = lng.split('.');\n                    deep = resources;\n                    resources = ns;\n                    ns = path[1];\n                }\n                this.addNamespaces(ns);\n                var pack = getPath(this.data, path) || {};\n                if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n                if (deep) {\n                    deepExtend(pack, resources, overwrite);\n                } else {\n                    pack = _object_spread({}, pack, resources);\n                }\n                setPath(this.data, path, pack);\n                if (!options.silent) this.emit('added', lng, ns, resources);\n            }\n        },\n        {\n            key: \"removeResourceBundle\",\n            value: function removeResourceBundle(lng, ns) {\n                if (this.hasResourceBundle(lng, ns)) {\n                    delete this.data[lng][ns];\n                }\n                this.removeNamespaces(ns);\n                this.emit('removed', lng, ns);\n            }\n        },\n        {\n            key: \"hasResourceBundle\",\n            value: function hasResourceBundle(lng, ns) {\n                return this.getResource(lng, ns) !== undefined;\n            }\n        },\n        {\n            key: \"getResourceBundle\",\n            value: function getResourceBundle(lng, ns) {\n                if (!ns) ns = this.options.defaultNS;\n                return this.getResource(lng, ns);\n            }\n        },\n        {\n            key: \"getDataByLanguage\",\n            value: function getDataByLanguage(lng) {\n                return this.data[lng];\n            }\n        },\n        {\n            key: \"hasLanguageSomeTranslations\",\n            value: function hasLanguageSomeTranslations(lng) {\n                var data = this.getDataByLanguage(lng);\n                var n = data && Object.keys(data) || [];\n                return !!n.find(function(v) {\n                    return data[v] && Object.keys(data[v]).length > 0;\n                });\n            }\n        },\n        {\n            key: \"toJSON\",\n            value: function toJSON() {\n                return this.data;\n            }\n        }\n    ]);\n    return ResourceStore;\n}(EventEmitter);\nvar postProcessor = {\n    processors: {},\n    addPostProcessor: function addPostProcessor(module) {\n        this.processors[module.name] = module;\n    },\n    handle: function handle(processors, value, key, options, translator) {\n        var _this = this;\n        processors.forEach(function(processor) {\n            var _this_processors_processor;\n            var _this_processors_processor_process;\n            value = (_this_processors_processor_process = (_this_processors_processor = _this.processors[processor]) === null || _this_processors_processor === void 0 ? void 0 : _this_processors_processor.process(value, key, options, translator)) !== null && _this_processors_processor_process !== void 0 ? _this_processors_processor_process : value;\n        });\n        return value;\n    }\n};\nvar PATH_KEY = Symbol('i18next/PATH_KEY');\nfunction createProxy() {\n    var state = [];\n    var handler = Object.create(null);\n    var proxy;\n    handler.get = function(target, key) {\n        var _proxy_revoke;\n        proxy === null || proxy === void 0 ? void 0 : (_proxy_revoke = proxy.revoke) === null || _proxy_revoke === void 0 ? void 0 : _proxy_revoke.call(proxy);\n        if (key === PATH_KEY) return state;\n        state.push(key);\n        proxy = Proxy.revocable(target, handler);\n        return proxy.proxy;\n    };\n    return Proxy.revocable(Object.create(null), handler).proxy;\n}\nfunction keysFromSelector(selector, opts) {\n    var _selector = selector(createProxy()), path = _selector[PATH_KEY];\n    var _opts_keySeparator;\n    return path.join((_opts_keySeparator = opts === null || opts === void 0 ? void 0 : opts.keySeparator) !== null && _opts_keySeparator !== void 0 ? _opts_keySeparator : '.');\n}\nvar checkedLoadedFor = {};\nvar shouldHandleAsObject = function(res) {\n    return !isString(res) && typeof res !== 'boolean' && typeof res !== 'number';\n};\nvar Translator = /*#__PURE__*/ function(EventEmitter) {\n    \"use strict\";\n    _inherits(Translator, EventEmitter);\n    function Translator(services) {\n        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _class_call_check(this, Translator);\n        var _this;\n        _this = _call_super(this, Translator);\n        copy([\n            'resourceStore',\n            'languageUtils',\n            'pluralResolver',\n            'interpolator',\n            'backendConnector',\n            'i18nFormat',\n            'utils'\n        ], services, _this);\n        _this.options = options;\n        if (_this.options.keySeparator === undefined) {\n            _this.options.keySeparator = '.';\n        }\n        _this.logger = baseLogger.create('translator');\n        return _this;\n    }\n    _create_class(Translator, [\n        {\n            key: \"changeLanguage\",\n            value: function changeLanguage(lng) {\n                if (lng) this.language = lng;\n            }\n        },\n        {\n            key: \"exists\",\n            value: function exists(key) {\n                var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n                    interpolation: {}\n                };\n                var opt = _object_spread({}, o);\n                if (key == null) return false;\n                var resolved = this.resolve(key, opt);\n                return (resolved === null || resolved === void 0 ? void 0 : resolved.res) !== undefined;\n            }\n        },\n        {\n            key: \"extractFromKey\",\n            value: function extractFromKey(key, opt) {\n                var nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n                if (nsSeparator === undefined) nsSeparator = ':';\n                var keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n                var namespaces = opt.ns || this.options.defaultNS || [];\n                var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n                var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n                if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n                    var m = key.match(this.interpolator.nestingRegexp);\n                    if (m && m.length > 0) {\n                        return {\n                            key: key,\n                            namespaces: isString(namespaces) ? [\n                                namespaces\n                            ] : namespaces\n                        };\n                    }\n                    var parts = key.split(nsSeparator);\n                    if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n                    key = parts.join(keySeparator);\n                }\n                return {\n                    key: key,\n                    namespaces: isString(namespaces) ? [\n                        namespaces\n                    ] : namespaces\n                };\n            }\n        },\n        {\n            key: \"translate\",\n            value: function translate(keys, o, lastKey) {\n                var _this = this;\n                var opt = (typeof o === \"undefined\" ? \"undefined\" : _type_of(o)) === 'object' ? _object_spread({}, o) : o;\n                if ((typeof opt === \"undefined\" ? \"undefined\" : _type_of(opt)) !== 'object' && this.options.overloadTranslationOptionHandler) {\n                    opt = this.options.overloadTranslationOptionHandler(arguments);\n                }\n                if ((typeof opt === \"undefined\" ? \"undefined\" : _type_of(opt)) === 'object') opt = _object_spread({}, opt);\n                if (!opt) opt = {};\n                if (keys == null) return '';\n                if (typeof keys === 'function') keys = keysFromSelector(keys, _object_spread({}, this.options, opt));\n                if (!Array.isArray(keys)) keys = [\n                    String(keys)\n                ];\n                var returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;\n                var keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n                var _this_extractFromKey = this.extractFromKey(keys[keys.length - 1], opt), key = _this_extractFromKey.key, namespaces = _this_extractFromKey.namespaces;\n                var namespace = namespaces[namespaces.length - 1];\n                var nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n                if (nsSeparator === undefined) nsSeparator = ':';\n                var lng = opt.lng || this.language;\n                var appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n                if ((lng === null || lng === void 0 ? void 0 : lng.toLowerCase()) === 'cimode') {\n                    if (appendNamespaceToCIMode) {\n                        if (returnDetails) {\n                            return {\n                                res: \"\".concat(namespace).concat(nsSeparator).concat(key),\n                                usedKey: key,\n                                exactUsedKey: key,\n                                usedLng: lng,\n                                usedNS: namespace,\n                                usedParams: this.getUsedParamsDetails(opt)\n                            };\n                        }\n                        return \"\".concat(namespace).concat(nsSeparator).concat(key);\n                    }\n                    if (returnDetails) {\n                        return {\n                            res: key,\n                            usedKey: key,\n                            exactUsedKey: key,\n                            usedLng: lng,\n                            usedNS: namespace,\n                            usedParams: this.getUsedParamsDetails(opt)\n                        };\n                    }\n                    return key;\n                }\n                var resolved = this.resolve(keys, opt);\n                var res = resolved === null || resolved === void 0 ? void 0 : resolved.res;\n                var resUsedKey = (resolved === null || resolved === void 0 ? void 0 : resolved.usedKey) || key;\n                var resExactUsedKey = (resolved === null || resolved === void 0 ? void 0 : resolved.exactUsedKey) || key;\n                var noObject = [\n                    '[object Number]',\n                    '[object Function]',\n                    '[object RegExp]'\n                ];\n                var joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;\n                var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n                var needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n                var hasDefaultValue = Translator.hasDefaultValue(opt);\n                var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : '';\n                var defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {\n                    ordinal: false\n                }) : '';\n                var needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n                var defaultValue = needsZeroSuffixLookup && opt[\"defaultValue\".concat(this.options.pluralSeparator, \"zero\")] || opt[\"defaultValue\".concat(defaultValueSuffix)] || opt[\"defaultValue\".concat(defaultValueSuffixOrdinalFallback)] || opt.defaultValue;\n                var resForObjHndl = res;\n                if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n                    resForObjHndl = defaultValue;\n                }\n                var handleAsObject = shouldHandleAsObject(resForObjHndl);\n                var resType = Object.prototype.toString.apply(resForObjHndl);\n                if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n                    if (!opt.returnObjects && !this.options.returnObjects) {\n                        if (!this.options.returnedObjectHandler) {\n                            this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n                        }\n                        var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, _object_spread_props(_object_spread({}, opt), {\n                            ns: namespaces\n                        })) : \"key '\".concat(key, \" (\").concat(this.language, \")' returned an object instead of string.\");\n                        if (returnDetails) {\n                            resolved.res = r;\n                            resolved.usedParams = this.getUsedParamsDetails(opt);\n                            return resolved;\n                        }\n                        return r;\n                    }\n                    if (keySeparator) {\n                        var resTypeIsArray = Array.isArray(resForObjHndl);\n                        var copy = resTypeIsArray ? [] : {};\n                        var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                        for(var m in resForObjHndl){\n                            if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n                                var deepKey = \"\".concat(newKeyToUse).concat(keySeparator).concat(m);\n                                if (hasDefaultValue && !res) {\n                                    copy[m] = this.translate(deepKey, _object_spread(_object_spread_props(_object_spread({}, opt), {\n                                        defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined\n                                    }), {\n                                        joinArrays: false,\n                                        ns: namespaces\n                                    }));\n                                } else {\n                                    copy[m] = this.translate(deepKey, _object_spread({}, opt, {\n                                        joinArrays: false,\n                                        ns: namespaces\n                                    }));\n                                }\n                                if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n                            }\n                        }\n                        res = copy;\n                    }\n                } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n                    res = res.join(joinArrays);\n                    if (res) res = this.extendTranslation(res, keys, opt, lastKey);\n                } else {\n                    var usedDefault = false;\n                    var usedKey = false;\n                    if (!this.isValidLookup(res) && hasDefaultValue) {\n                        usedDefault = true;\n                        res = defaultValue;\n                    }\n                    if (!this.isValidLookup(res)) {\n                        usedKey = true;\n                        res = key;\n                    }\n                    var missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n                    var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n                    var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n                    if (usedKey || usedDefault || updateMissing) {\n                        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n                        if (keySeparator) {\n                            var fk = this.resolve(key, _object_spread_props(_object_spread({}, opt), {\n                                keySeparator: false\n                            }));\n                            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n                        }\n                        var lngs = [];\n                        var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);\n                        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n                            for(var i = 0; i < fallbackLngs.length; i++){\n                                lngs.push(fallbackLngs[i]);\n                            }\n                        } else if (this.options.saveMissingTo === 'all') {\n                            lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);\n                        } else {\n                            lngs.push(opt.lng || this.language);\n                        }\n                        var send = function(l, k, specificDefaultValue) {\n                            var _this_backendConnector;\n                            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                            if (_this.options.missingKeyHandler) {\n                                _this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);\n                            } else if ((_this_backendConnector = _this.backendConnector) === null || _this_backendConnector === void 0 ? void 0 : _this_backendConnector.saveMissing) {\n                                _this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);\n                            }\n                            _this.emit('missingKey', l, namespace, k, res);\n                        };\n                        if (this.options.saveMissing) {\n                            if (this.options.saveMissingPlurals && needsPluralHandling) {\n                                lngs.forEach(function(language) {\n                                    var suffixes = _this.pluralResolver.getSuffixes(language, opt);\n                                    if (needsZeroSuffixLookup && opt[\"defaultValue\".concat(_this.options.pluralSeparator, \"zero\")] && suffixes.indexOf(\"\".concat(_this.options.pluralSeparator, \"zero\")) < 0) {\n                                        suffixes.push(\"\".concat(_this.options.pluralSeparator, \"zero\"));\n                                    }\n                                    suffixes.forEach(function(suffix) {\n                                        send([\n                                            language\n                                        ], key + suffix, opt[\"defaultValue\".concat(suffix)] || defaultValue);\n                                    });\n                                });\n                            } else {\n                                send(lngs, key, defaultValue);\n                            }\n                        }\n                    }\n                    res = this.extendTranslation(res, keys, opt, resolved, lastKey);\n                    if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {\n                        res = \"\".concat(namespace).concat(nsSeparator).concat(key);\n                    }\n                    if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? \"\".concat(namespace).concat(nsSeparator).concat(key) : key, usedDefault ? res : undefined, opt);\n                    }\n                }\n                if (returnDetails) {\n                    resolved.res = res;\n                    resolved.usedParams = this.getUsedParamsDetails(opt);\n                    return resolved;\n                }\n                return res;\n            }\n        },\n        {\n            key: \"extendTranslation\",\n            value: function extendTranslation(res, key, opt, resolved, lastKey) {\n                var _this_i18nFormat;\n                if ((_this_i18nFormat = this.i18nFormat) === null || _this_i18nFormat === void 0 ? void 0 : _this_i18nFormat.parse) {\n                    res = this.i18nFormat.parse(res, _object_spread({}, this.options.interpolation.defaultVariables, opt), opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                        resolved: resolved\n                    });\n                } else if (!opt.skipInterpolation) {\n                    var _this = this;\n                    var _opt_interpolation;\n                    if (opt.interpolation) this.interpolator.init(_object_spread({}, opt, {\n                        interpolation: _object_spread({}, this.options.interpolation, opt.interpolation)\n                    }));\n                    var skipOnVariables = isString(res) && ((opt === null || opt === void 0 ? void 0 : (_opt_interpolation = opt.interpolation) === null || _opt_interpolation === void 0 ? void 0 : _opt_interpolation.skipOnVariables) !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n                    var nestBef;\n                    if (skipOnVariables) {\n                        var nb = res.match(this.interpolator.nestingRegexp);\n                        nestBef = nb && nb.length;\n                    }\n                    var data = opt.replace && !isString(opt.replace) ? opt.replace : opt;\n                    if (this.options.interpolation.defaultVariables) data = _object_spread({}, this.options.interpolation.defaultVariables, data);\n                    res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);\n                    if (skipOnVariables) {\n                        var na = res.match(this.interpolator.nestingRegexp);\n                        var nestAft = na && na.length;\n                        if (nestBef < nestAft) opt.nest = false;\n                    }\n                    if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;\n                    if (opt.nest !== false) res = this.interpolator.nest(res, function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        if ((lastKey === null || lastKey === void 0 ? void 0 : lastKey[0]) === args[0] && !opt.context) {\n                            _this.logger.warn(\"It seems you are nesting recursively key: \".concat(args[0], \" in key: \").concat(key[0]));\n                            return null;\n                        }\n                        return _this.translate.apply(_this, _to_consumable_array(args).concat([\n                            key\n                        ]));\n                    }, opt);\n                    if (opt.interpolation) this.interpolator.reset();\n                }\n                var postProcess = opt.postProcess || this.options.postProcess;\n                var postProcessorNames = isString(postProcess) ? [\n                    postProcess\n                ] : postProcess;\n                if (res != null && (postProcessorNames === null || postProcessorNames === void 0 ? void 0 : postProcessorNames.length) && opt.applyPostProcessor !== false) {\n                    res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _object_spread({\n                        i18nResolved: _object_spread_props(_object_spread({}, resolved), {\n                            usedParams: this.getUsedParamsDetails(opt)\n                        })\n                    }, opt) : opt, this);\n                }\n                return res;\n            }\n        },\n        {\n            key: \"resolve\",\n            value: function resolve(keys) {\n                var _this = this;\n                var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                var found;\n                var usedKey;\n                var exactUsedKey;\n                var usedLng;\n                var usedNS;\n                if (isString(keys)) keys = [\n                    keys\n                ];\n                keys.forEach(function(k) {\n                    if (_this.isValidLookup(found)) return;\n                    var extracted = _this.extractFromKey(k, opt);\n                    var key = extracted.key;\n                    usedKey = key;\n                    var namespaces = extracted.namespaces;\n                    if (_this.options.fallbackNS) namespaces = namespaces.concat(_this.options.fallbackNS);\n                    var needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n                    var needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n                    var needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === 'number') && opt.context !== '';\n                    var codes = opt.lngs ? opt.lngs : _this.languageUtils.toResolveHierarchy(opt.lng || _this.language, opt.fallbackLng);\n                    namespaces.forEach(function(ns) {\n                        var _this_utils, _this_utils1;\n                        if (_this.isValidLookup(found)) return;\n                        usedNS = ns;\n                        if (!checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] && ((_this_utils = _this.utils) === null || _this_utils === void 0 ? void 0 : _this_utils.hasLoadedNamespace) && !((_this_utils1 = _this.utils) === null || _this_utils1 === void 0 ? void 0 : _this_utils1.hasLoadedNamespace(usedNS))) {\n                            checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] = true;\n                            _this.logger.warn('key \"'.concat(usedKey, '\" for languages \"').concat(codes.join(', '), '\" won\\'t get resolved as namespace \"').concat(usedNS, '\" was not yet loaded'), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n                        }\n                        codes.forEach(function(code) {\n                            var _this_i18nFormat;\n                            if (_this.isValidLookup(found)) return;\n                            usedLng = code;\n                            var finalKeys = [\n                                key\n                            ];\n                            if ((_this_i18nFormat = _this.i18nFormat) === null || _this_i18nFormat === void 0 ? void 0 : _this_i18nFormat.addLookupKeys) {\n                                _this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);\n                            } else {\n                                var pluralSuffix;\n                                if (needsPluralHandling) pluralSuffix = _this.pluralResolver.getSuffix(code, opt.count, opt);\n                                var zeroSuffix = \"\".concat(_this.options.pluralSeparator, \"zero\");\n                                var ordinalPrefix = \"\".concat(_this.options.pluralSeparator, \"ordinal\").concat(_this.options.pluralSeparator);\n                                if (needsPluralHandling) {\n                                    if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                        finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, _this.options.pluralSeparator));\n                                    }\n                                    finalKeys.push(key + pluralSuffix);\n                                    if (needsZeroSuffixLookup) {\n                                        finalKeys.push(key + zeroSuffix);\n                                    }\n                                }\n                                if (needsContextHandling) {\n                                    var contextKey = \"\".concat(key).concat(_this.options.contextSeparator || '_').concat(opt.context);\n                                    finalKeys.push(contextKey);\n                                    if (needsPluralHandling) {\n                                        if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                            finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, _this.options.pluralSeparator));\n                                        }\n                                        finalKeys.push(contextKey + pluralSuffix);\n                                        if (needsZeroSuffixLookup) {\n                                            finalKeys.push(contextKey + zeroSuffix);\n                                        }\n                                    }\n                                }\n                            }\n                            var possibleKey;\n                            while(possibleKey = finalKeys.pop()){\n                                if (!_this.isValidLookup(found)) {\n                                    exactUsedKey = possibleKey;\n                                    found = _this.getResource(code, ns, possibleKey, opt);\n                                }\n                            }\n                        });\n                    });\n                });\n                return {\n                    res: found,\n                    usedKey: usedKey,\n                    exactUsedKey: exactUsedKey,\n                    usedLng: usedLng,\n                    usedNS: usedNS\n                };\n            }\n        },\n        {\n            key: \"isValidLookup\",\n            value: function isValidLookup(res) {\n                return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n            }\n        },\n        {\n            key: \"getResource\",\n            value: function getResource(code, ns, key) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                var _this_i18nFormat;\n                if ((_this_i18nFormat = this.i18nFormat) === null || _this_i18nFormat === void 0 ? void 0 : _this_i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n                return this.resourceStore.getResource(code, ns, key, options);\n            }\n        },\n        {\n            key: \"getUsedParamsDetails\",\n            value: function getUsedParamsDetails() {\n                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n                var optionsKeys = [\n                    'defaultValue',\n                    'ordinal',\n                    'context',\n                    'replace',\n                    'lng',\n                    'lngs',\n                    'fallbackLng',\n                    'ns',\n                    'keySeparator',\n                    'nsSeparator',\n                    'returnObjects',\n                    'returnDetails',\n                    'joinArrays',\n                    'postProcess',\n                    'interpolation'\n                ];\n                var useOptionsReplaceForData = options.replace && !isString(options.replace);\n                var data = useOptionsReplaceForData ? options.replace : options;\n                if (useOptionsReplaceForData && typeof options.count !== 'undefined') {\n                    data.count = options.count;\n                }\n                if (this.options.interpolation.defaultVariables) {\n                    data = _object_spread({}, this.options.interpolation.defaultVariables, data);\n                }\n                if (!useOptionsReplaceForData) {\n                    data = _object_spread({}, data);\n                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                    try {\n                        for(var _iterator = optionsKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                            var key = _step.value;\n                            delete data[key];\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                }\n                return data;\n            }\n        }\n    ], [\n        {\n            key: \"hasDefaultValue\",\n            value: function hasDefaultValue(options) {\n                var prefix = 'defaultValue';\n                for(var option in options){\n                    if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    ]);\n    return Translator;\n}(EventEmitter);\nvar LanguageUtil = /*#__PURE__*/ function() {\n    \"use strict\";\n    function LanguageUtil(options) {\n        _class_call_check(this, LanguageUtil);\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create('languageUtils');\n    }\n    _create_class(LanguageUtil, [\n        {\n            key: \"getScriptPartFromCode\",\n            value: function getScriptPartFromCode(code) {\n                code = getCleanedCode(code);\n                if (!code || code.indexOf('-') < 0) return null;\n                var p = code.split('-');\n                if (p.length === 2) return null;\n                p.pop();\n                if (p[p.length - 1].toLowerCase() === 'x') return null;\n                return this.formatLanguageCode(p.join('-'));\n            }\n        },\n        {\n            key: \"getLanguagePartFromCode\",\n            value: function getLanguagePartFromCode(code) {\n                code = getCleanedCode(code);\n                if (!code || code.indexOf('-') < 0) return code;\n                var p = code.split('-');\n                return this.formatLanguageCode(p[0]);\n            }\n        },\n        {\n            key: \"formatLanguageCode\",\n            value: function formatLanguageCode(code) {\n                if (isString(code) && code.indexOf('-') > -1) {\n                    var formattedCode;\n                    try {\n                        formattedCode = Intl.getCanonicalLocales(code)[0];\n                    } catch (e) {}\n                    if (formattedCode && this.options.lowerCaseLng) {\n                        formattedCode = formattedCode.toLowerCase();\n                    }\n                    if (formattedCode) return formattedCode;\n                    if (this.options.lowerCaseLng) {\n                        return code.toLowerCase();\n                    }\n                    return code;\n                }\n                return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n            }\n        },\n        {\n            key: \"isSupportedCode\",\n            value: function isSupportedCode(code) {\n                if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n                    code = this.getLanguagePartFromCode(code);\n                }\n                return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n            }\n        },\n        {\n            key: \"getBestMatchFromCodes\",\n            value: function getBestMatchFromCodes(codes) {\n                var _this = this;\n                if (!codes) return null;\n                var found;\n                codes.forEach(function(code) {\n                    if (found) return;\n                    var cleanedLng = _this.formatLanguageCode(code);\n                    if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;\n                });\n                if (!found && this.options.supportedLngs) {\n                    codes.forEach(function(code) {\n                        if (found) return;\n                        var lngScOnly = _this.getScriptPartFromCode(code);\n                        if (_this.isSupportedCode(lngScOnly)) return found = lngScOnly;\n                        var lngOnly = _this.getLanguagePartFromCode(code);\n                        if (_this.isSupportedCode(lngOnly)) return found = lngOnly;\n                        found = _this.options.supportedLngs.find(function(supportedLng) {\n                            if (supportedLng === lngOnly) return supportedLng;\n                            if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;\n                            if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;\n                            if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                        });\n                    });\n                }\n                if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n                return found;\n            }\n        },\n        {\n            key: \"getFallbackCodes\",\n            value: function getFallbackCodes(fallbacks, code) {\n                if (!fallbacks) return [];\n                if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n                if (isString(fallbacks)) fallbacks = [\n                    fallbacks\n                ];\n                if (Array.isArray(fallbacks)) return fallbacks;\n                if (!code) return fallbacks.default || [];\n                var found = fallbacks[code];\n                if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n                if (!found) found = fallbacks[this.formatLanguageCode(code)];\n                if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n                if (!found) found = fallbacks.default;\n                return found || [];\n            }\n        },\n        {\n            key: \"toResolveHierarchy\",\n            value: function toResolveHierarchy(code, fallbackCode) {\n                var _this = this;\n                var fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);\n                var codes = [];\n                var addCode = function(c) {\n                    if (!c) return;\n                    if (_this.isSupportedCode(c)) {\n                        codes.push(c);\n                    } else {\n                        _this.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(c));\n                    }\n                };\n                if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {\n                    if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n                    if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n                    if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n                } else if (isString(code)) {\n                    addCode(this.formatLanguageCode(code));\n                }\n                fallbackCodes.forEach(function(fc) {\n                    if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));\n                });\n                return codes;\n            }\n        }\n    ]);\n    return LanguageUtil;\n}();\nvar suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nvar dummyRule = {\n    select: function(count) {\n        return count === 1 ? 'one' : 'other';\n    },\n    resolvedOptions: function() {\n        return {\n            pluralCategories: [\n                'one',\n                'other'\n            ]\n        };\n    }\n};\nvar PluralResolver = /*#__PURE__*/ function() {\n    \"use strict\";\n    function PluralResolver(languageUtils) {\n        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _class_call_check(this, PluralResolver);\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create('pluralResolver');\n        this.pluralRulesCache = {};\n    }\n    _create_class(PluralResolver, [\n        {\n            key: \"addRule\",\n            value: function addRule(lng, obj) {\n                this.rules[lng] = obj;\n            }\n        },\n        {\n            key: \"clearCache\",\n            value: function clearCache() {\n                this.pluralRulesCache = {};\n            }\n        },\n        {\n            key: \"getRule\",\n            value: function getRule(code) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                var cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);\n                var type = options.ordinal ? 'ordinal' : 'cardinal';\n                var cacheKey = JSON.stringify({\n                    cleanedCode: cleanedCode,\n                    type: type\n                });\n                if (cacheKey in this.pluralRulesCache) {\n                    return this.pluralRulesCache[cacheKey];\n                }\n                var rule;\n                try {\n                    rule = new Intl.PluralRules(cleanedCode, {\n                        type: type\n                    });\n                } catch (err) {\n                    if (!Intl) {\n                        this.logger.error('No Intl support, please use an Intl polyfill!');\n                        return dummyRule;\n                    }\n                    if (!code.match(/-|_/)) return dummyRule;\n                    var lngPart = this.languageUtils.getLanguagePartFromCode(code);\n                    rule = this.getRule(lngPart, options);\n                }\n                this.pluralRulesCache[cacheKey] = rule;\n                return rule;\n            }\n        },\n        {\n            key: \"needsPlural\",\n            value: function needsPlural(code) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                var rule = this.getRule(code, options);\n                if (!rule) rule = this.getRule('dev', options);\n                return (rule === null || rule === void 0 ? void 0 : rule.resolvedOptions().pluralCategories.length) > 1;\n            }\n        },\n        {\n            key: \"getPluralFormsOfKey\",\n            value: function getPluralFormsOfKey(code, key) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                return this.getSuffixes(code, options).map(function(suffix) {\n                    return \"\".concat(key).concat(suffix);\n                });\n            }\n        },\n        {\n            key: \"getSuffixes\",\n            value: function getSuffixes(code) {\n                var _this = this;\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                var rule = this.getRule(code, options);\n                if (!rule) rule = this.getRule('dev', options);\n                if (!rule) return [];\n                return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {\n                    return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];\n                }).map(function(pluralCategory) {\n                    return \"\".concat(_this.options.prepend).concat(options.ordinal ? \"ordinal\".concat(_this.options.prepend) : '').concat(pluralCategory);\n                });\n            }\n        },\n        {\n            key: \"getSuffix\",\n            value: function getSuffix(code, count) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var rule = this.getRule(code, options);\n                if (rule) {\n                    return \"\".concat(this.options.prepend).concat(options.ordinal ? \"ordinal\".concat(this.options.prepend) : '').concat(rule.select(count));\n                }\n                this.logger.warn(\"no plural rule found for: \".concat(code));\n                return this.getSuffix('dev', count, options);\n            }\n        }\n    ]);\n    return PluralResolver;\n}();\nvar deepFindWithDefaults = function(data, defaultData, key) {\n    var keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : '.', ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    var path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && isString(key)) {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nvar regexSafe = function(val) {\n    return val.replace(/\\$/g, '$$$$');\n};\nvar Interpolator = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Interpolator() {\n        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        _class_call_check(this, Interpolator);\n        var _options_interpolation;\n        this.logger = baseLogger.create('interpolator');\n        this.options = options;\n        this.format = (options === null || options === void 0 ? void 0 : (_options_interpolation = options.interpolation) === null || _options_interpolation === void 0 ? void 0 : _options_interpolation.format) || function(value) {\n            return value;\n        };\n        this.init(options);\n    }\n    _create_class(Interpolator, [\n        {\n            key: \"init\",\n            value: function init() {\n                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n                if (!options.interpolation) options.interpolation = {\n                    escapeValue: true\n                };\n                var _options_interpolation = options.interpolation, escape$1 = _options_interpolation.escape, escapeValue = _options_interpolation.escapeValue, useRawValueToEscape = _options_interpolation.useRawValueToEscape, prefix = _options_interpolation.prefix, prefixEscaped = _options_interpolation.prefixEscaped, suffix = _options_interpolation.suffix, suffixEscaped = _options_interpolation.suffixEscaped, formatSeparator = _options_interpolation.formatSeparator, unescapeSuffix = _options_interpolation.unescapeSuffix, unescapePrefix = _options_interpolation.unescapePrefix, nestingPrefix = _options_interpolation.nestingPrefix, nestingPrefixEscaped = _options_interpolation.nestingPrefixEscaped, nestingSuffix = _options_interpolation.nestingSuffix, nestingSuffixEscaped = _options_interpolation.nestingSuffixEscaped, nestingOptionsSeparator = _options_interpolation.nestingOptionsSeparator, maxReplaces = _options_interpolation.maxReplaces, alwaysFormat = _options_interpolation.alwaysFormat;\n                this.escape = escape$1 !== undefined ? escape$1 : escape;\n                this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n                this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n                this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';\n                this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';\n                this.formatSeparator = formatSeparator || ',';\n                this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';\n                this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';\n                this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');\n                this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');\n                this.nestingOptionsSeparator = nestingOptionsSeparator || ',';\n                this.maxReplaces = maxReplaces || 1000;\n                this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n                this.resetRegExp();\n            }\n        },\n        {\n            key: \"reset\",\n            value: function reset() {\n                if (this.options) this.init(this.options);\n            }\n        },\n        {\n            key: \"resetRegExp\",\n            value: function resetRegExp() {\n                var getOrResetRegExp = function(existingRegExp, pattern) {\n                    if ((existingRegExp === null || existingRegExp === void 0 ? void 0 : existingRegExp.source) === pattern) {\n                        existingRegExp.lastIndex = 0;\n                        return existingRegExp;\n                    }\n                    return new RegExp(pattern, 'g');\n                };\n                this.regexp = getOrResetRegExp(this.regexp, \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix));\n                this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix));\n                this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, \"\".concat(this.nestingPrefix, \"((?:[^()\\\"']+|\\\"[^\\\"]*\\\"|'[^']*'|\\\\((?:[^()]|\\\"[^\\\"]*\\\"|'[^']*')*\\\\))*?)\").concat(this.nestingSuffix));\n            }\n        },\n        {\n            key: \"interpolate\",\n            value: function interpolate(str, data, lng, options) {\n                var _this = this;\n                var _options_interpolation;\n                var match;\n                var value;\n                var replaces;\n                var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n                var handleFormat = function(key) {\n                    if (key.indexOf(_this.formatSeparator) < 0) {\n                        var path = deepFindWithDefaults(data, defaultData, key, _this.options.keySeparator, _this.options.ignoreJSONStructure);\n                        return _this.alwaysFormat ? _this.format(path, undefined, lng, _object_spread_props(_object_spread({}, options, data), {\n                            interpolationkey: key\n                        })) : path;\n                    }\n                    var p = key.split(_this.formatSeparator);\n                    var k = p.shift().trim();\n                    var f = p.join(_this.formatSeparator).trim();\n                    return _this.format(deepFindWithDefaults(data, defaultData, k, _this.options.keySeparator, _this.options.ignoreJSONStructure), f, lng, _object_spread_props(_object_spread({}, options, data), {\n                        interpolationkey: k\n                    }));\n                };\n                this.resetRegExp();\n                var missingInterpolationHandler = (options === null || options === void 0 ? void 0 : options.missingInterpolationHandler) || this.options.missingInterpolationHandler;\n                var skipOnVariables = (options === null || options === void 0 ? void 0 : (_options_interpolation = options.interpolation) === null || _options_interpolation === void 0 ? void 0 : _options_interpolation.skipOnVariables) !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n                var todos = [\n                    {\n                        regex: this.regexpUnescape,\n                        safeValue: function(val) {\n                            return regexSafe(val);\n                        }\n                    },\n                    {\n                        regex: this.regexp,\n                        safeValue: function(val) {\n                            return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);\n                        }\n                    }\n                ];\n                todos.forEach(function(todo) {\n                    replaces = 0;\n                    while(match = todo.regex.exec(str)){\n                        var matchedVar = match[1].trim();\n                        value = handleFormat(matchedVar);\n                        if (value === undefined) {\n                            if (typeof missingInterpolationHandler === 'function') {\n                                var temp = missingInterpolationHandler(str, match, options);\n                                value = isString(temp) ? temp : '';\n                            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                                value = '';\n                            } else if (skipOnVariables) {\n                                value = match[0];\n                                continue;\n                            } else {\n                                _this.logger.warn(\"missed to pass in variable \".concat(matchedVar, \" for interpolating \").concat(str));\n                                value = '';\n                            }\n                        } else if (!isString(value) && !_this.useRawValueToEscape) {\n                            value = makeString(value);\n                        }\n                        var safeValue = todo.safeValue(value);\n                        str = str.replace(match[0], safeValue);\n                        if (skipOnVariables) {\n                            todo.regex.lastIndex += value.length;\n                            todo.regex.lastIndex -= match[0].length;\n                        } else {\n                            todo.regex.lastIndex = 0;\n                        }\n                        replaces++;\n                        if (replaces >= _this.maxReplaces) {\n                            break;\n                        }\n                    }\n                });\n                return str;\n            }\n        },\n        {\n            key: \"nest\",\n            value: function nest(str, fc) {\n                var _this = this;\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var match;\n                var value;\n                var clonedOptions;\n                var handleHasOptions = function(key, inheritedOptions) {\n                    var sep = _this.nestingOptionsSeparator;\n                    if (key.indexOf(sep) < 0) return key;\n                    var c = key.split(new RegExp(\"\".concat(sep, \"[ ]*{\")));\n                    var optionsString = \"{\".concat(c[1]);\n                    key = c[0];\n                    optionsString = _this.interpolate(optionsString, clonedOptions);\n                    var matchedSingleQuotes = optionsString.match(/'/g);\n                    var matchedDoubleQuotes = optionsString.match(/\"/g);\n                    var _matchedSingleQuotes_length;\n                    if (((_matchedSingleQuotes_length = matchedSingleQuotes === null || matchedSingleQuotes === void 0 ? void 0 : matchedSingleQuotes.length) !== null && _matchedSingleQuotes_length !== void 0 ? _matchedSingleQuotes_length : 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                        optionsString = optionsString.replace(/'/g, '\"');\n                    }\n                    try {\n                        clonedOptions = JSON.parse(optionsString);\n                        if (inheritedOptions) clonedOptions = _object_spread({}, inheritedOptions, clonedOptions);\n                    } catch (e) {\n                        _this.logger.warn(\"failed parsing options string in nesting for key \".concat(key), e);\n                        return \"\".concat(key).concat(sep).concat(optionsString);\n                    }\n                    if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(_this.prefix) > -1) delete clonedOptions.defaultValue;\n                    return key;\n                };\n                while(match = this.nestingRegexp.exec(str)){\n                    var formatters = [];\n                    clonedOptions = _object_spread({}, options);\n                    clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n                    clonedOptions.applyPostProcessor = false;\n                    delete clonedOptions.defaultValue;\n                    var keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf('}') + 1 : match[1].indexOf(this.formatSeparator);\n                    if (keyEndIndex !== -1) {\n                        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map(function(elem) {\n                            return elem.trim();\n                        }).filter(Boolean);\n                        match[1] = match[1].slice(0, keyEndIndex);\n                    }\n                    value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n                    if (value && match[0] === str && !isString(value)) return value;\n                    if (!isString(value)) value = makeString(value);\n                    if (!value) {\n                        this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n                        value = '';\n                    }\n                    if (formatters.length) {\n                        value = formatters.reduce(function(v, f) {\n                            return _this.format(v, f, options.lng, _object_spread_props(_object_spread({}, options), {\n                                interpolationkey: match[1].trim()\n                            }));\n                        }, value.trim());\n                    }\n                    str = str.replace(match[0], value);\n                    this.regexp.lastIndex = 0;\n                }\n                return str;\n            }\n        }\n    ]);\n    return Interpolator;\n}();\nvar parseFormatStr = function(formatStr) {\n    var formatName = formatStr.toLowerCase().trim();\n    var formatOptions = {};\n    if (formatStr.indexOf('(') > -1) {\n        var p = formatStr.split('(');\n        formatName = p[0].toLowerCase().trim();\n        var optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            var opts = optStr.split(';');\n            opts.forEach(function(opt) {\n                if (opt) {\n                    var _opt_split = _to_array(opt.split(':')), key = _opt_split[0], rest = _opt_split.slice(1);\n                    var val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n                    var trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === 'false') formatOptions[trimmedKey] = false;\n                    if (val === 'true') formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName: formatName,\n        formatOptions: formatOptions\n    };\n};\nvar createCachedFormatter = function(fn) {\n    var cache = {};\n    return function(v, l, o) {\n        var optForCache = o;\n        if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {\n            optForCache = _object_spread_props(_object_spread({}, optForCache), _define_property({}, o.interpolationkey, undefined));\n        }\n        var key = l + JSON.stringify(optForCache);\n        var frm = cache[key];\n        if (!frm) {\n            frm = fn(getCleanedCode(l), o);\n            cache[key] = frm;\n        }\n        return frm(v);\n    };\n};\nvar createNonCachedFormatter = function(fn) {\n    return function(v, l, o) {\n        return fn(getCleanedCode(l), o)(v);\n    };\n};\nvar Formatter = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Formatter() {\n        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        _class_call_check(this, Formatter);\n        this.logger = baseLogger.create('formatter');\n        this.options = options;\n        this.init(options);\n    }\n    _create_class(Formatter, [\n        {\n            key: \"init\",\n            value: function init(services) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n                    interpolation: {}\n                };\n                this.formatSeparator = options.interpolation.formatSeparator || ',';\n                var cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;\n                this.formats = {\n                    number: cf(function(lng, opt) {\n                        var formatter = new Intl.NumberFormat(lng, _object_spread({}, opt));\n                        return function(val) {\n                            return formatter.format(val);\n                        };\n                    }),\n                    currency: cf(function(lng, opt) {\n                        var formatter = new Intl.NumberFormat(lng, _object_spread_props(_object_spread({}, opt), {\n                            style: 'currency'\n                        }));\n                        return function(val) {\n                            return formatter.format(val);\n                        };\n                    }),\n                    datetime: cf(function(lng, opt) {\n                        var formatter = new Intl.DateTimeFormat(lng, _object_spread({}, opt));\n                        return function(val) {\n                            return formatter.format(val);\n                        };\n                    }),\n                    relativetime: cf(function(lng, opt) {\n                        var formatter = new Intl.RelativeTimeFormat(lng, _object_spread({}, opt));\n                        return function(val) {\n                            return formatter.format(val, opt.range || 'day');\n                        };\n                    }),\n                    list: cf(function(lng, opt) {\n                        var formatter = new Intl.ListFormat(lng, _object_spread({}, opt));\n                        return function(val) {\n                            return formatter.format(val);\n                        };\n                    })\n                };\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(name, fc) {\n                this.formats[name.toLowerCase().trim()] = fc;\n            }\n        },\n        {\n            key: \"addCached\",\n            value: function addCached(name, fc) {\n                this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n            }\n        },\n        {\n            key: \"format\",\n            value: function format(value, format, lng) {\n                var _this = this;\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                var formats = format.split(this.formatSeparator);\n                if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(function(f) {\n                    return f.indexOf(')') > -1;\n                })) {\n                    var lastIndex = formats.findIndex(function(f) {\n                        return f.indexOf(')') > -1;\n                    });\n                    formats[0] = [\n                        formats[0]\n                    ].concat(_to_consumable_array(formats.splice(1, lastIndex))).join(this.formatSeparator);\n                }\n                var result = formats.reduce(function(mem, f) {\n                    var _parseFormatStr = parseFormatStr(f), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;\n                    if (_this.formats[formatName]) {\n                        var formatted = mem;\n                        try {\n                            var _options_formatParams;\n                            var valOptions = (options === null || options === void 0 ? void 0 : (_options_formatParams = options.formatParams) === null || _options_formatParams === void 0 ? void 0 : _options_formatParams[options.interpolationkey]) || {};\n                            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                            formatted = _this.formats[formatName](mem, l, _object_spread({}, formatOptions, options, valOptions));\n                        } catch (error) {\n                            _this.logger.warn(error);\n                        }\n                        return formatted;\n                    } else {\n                        _this.logger.warn(\"there was no format function for \".concat(formatName));\n                    }\n                    return mem;\n                }, value);\n                return result;\n            }\n        }\n    ]);\n    return Formatter;\n}();\nvar removePending = function(q, name) {\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nvar Connector = /*#__PURE__*/ function(EventEmitter) {\n    \"use strict\";\n    _inherits(Connector, EventEmitter);\n    function Connector(backend, store, services) {\n        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        _class_call_check(this, Connector);\n        var _this;\n        var _this_backend_init, _this_backend;\n        _this = _call_super(this, Connector);\n        _this.backend = backend;\n        _this.store = store;\n        _this.services = services;\n        _this.languageUtils = services.languageUtils;\n        _this.options = options;\n        _this.logger = baseLogger.create('backendConnector');\n        _this.waitingReads = [];\n        _this.maxParallelReads = options.maxParallelReads || 10;\n        _this.readingCalls = 0;\n        _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        _this.state = {};\n        _this.queue = [];\n        (_this_backend = _this.backend) === null || _this_backend === void 0 ? void 0 : (_this_backend_init = _this_backend.init) === null || _this_backend_init === void 0 ? void 0 : _this_backend_init.call(_this_backend, services, options.backend, options);\n        return _this;\n    }\n    _create_class(Connector, [\n        {\n            key: \"queueLoad\",\n            value: function queueLoad(languages, namespaces, options, callback) {\n                var _this = this;\n                var toLoad = {};\n                var pending = {};\n                var toLoadLanguages = {};\n                var toLoadNamespaces = {};\n                languages.forEach(function(lng) {\n                    var hasAllNamespaces = true;\n                    namespaces.forEach(function(ns) {\n                        var name = \"\".concat(lng, \"|\").concat(ns);\n                        if (!options.reload && _this.store.hasResourceBundle(lng, ns)) {\n                            _this.state[name] = 2;\n                        } else if (_this.state[name] < 0) ;\n                        else if (_this.state[name] === 1) {\n                            if (pending[name] === undefined) pending[name] = true;\n                        } else {\n                            _this.state[name] = 1;\n                            hasAllNamespaces = false;\n                            if (pending[name] === undefined) pending[name] = true;\n                            if (toLoad[name] === undefined) toLoad[name] = true;\n                            if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                        }\n                    });\n                    if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n                });\n                if (Object.keys(toLoad).length || Object.keys(pending).length) {\n                    this.queue.push({\n                        pending: pending,\n                        pendingCount: Object.keys(pending).length,\n                        loaded: {},\n                        errors: [],\n                        callback: callback\n                    });\n                }\n                return {\n                    toLoad: Object.keys(toLoad),\n                    pending: Object.keys(pending),\n                    toLoadLanguages: Object.keys(toLoadLanguages),\n                    toLoadNamespaces: Object.keys(toLoadNamespaces)\n                };\n            }\n        },\n        {\n            key: \"loaded\",\n            value: function loaded(name, err, data) {\n                var s = name.split('|');\n                var lng = s[0];\n                var ns = s[1];\n                if (err) this.emit('failedLoading', lng, ns, err);\n                if (!err && data) {\n                    this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                        skipCopy: true\n                    });\n                }\n                this.state[name] = err ? -1 : 2;\n                if (err && data) this.state[name] = 0;\n                var loaded = {};\n                this.queue.forEach(function(q) {\n                    pushPath(q.loaded, [\n                        lng\n                    ], ns);\n                    removePending(q, name);\n                    if (err) q.errors.push(err);\n                    if (q.pendingCount === 0 && !q.done) {\n                        Object.keys(q.loaded).forEach(function(l) {\n                            if (!loaded[l]) loaded[l] = {};\n                            var loadedKeys = q.loaded[l];\n                            if (loadedKeys.length) {\n                                loadedKeys.forEach(function(n) {\n                                    if (loaded[l][n] === undefined) loaded[l][n] = true;\n                                });\n                            }\n                        });\n                        q.done = true;\n                        if (q.errors.length) {\n                            q.callback(q.errors);\n                        } else {\n                            q.callback();\n                        }\n                    }\n                });\n                this.emit('loaded', loaded);\n                this.queue = this.queue.filter(function(q) {\n                    return !q.done;\n                });\n            }\n        },\n        {\n            key: \"read\",\n            value: function read(lng, ns, fcName) {\n                var _this = this;\n                var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, callback = arguments.length > 5 ? arguments[5] : void 0;\n                if (!lng.length) return callback(null, {});\n                if (this.readingCalls >= this.maxParallelReads) {\n                    this.waitingReads.push({\n                        lng: lng,\n                        ns: ns,\n                        fcName: fcName,\n                        tried: tried,\n                        wait: wait,\n                        callback: callback\n                    });\n                    return;\n                }\n                this.readingCalls++;\n                var resolver = function(err, data) {\n                    _this.readingCalls--;\n                    if (_this.waitingReads.length > 0) {\n                        var next = _this.waitingReads.shift();\n                        _this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n                    }\n                    if (err && data && tried < _this.maxRetries) {\n                        setTimeout(function() {\n                            _this.read.call(_this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                        }, wait);\n                        return;\n                    }\n                    callback(err, data);\n                };\n                var fc = this.backend[fcName].bind(this.backend);\n                if (fc.length === 2) {\n                    try {\n                        var r = fc(lng, ns);\n                        if (r && typeof r.then === 'function') {\n                            r.then(function(data) {\n                                return resolver(null, data);\n                            }).catch(resolver);\n                        } else {\n                            resolver(null, r);\n                        }\n                    } catch (err) {\n                        resolver(err);\n                    }\n                    return;\n                }\n                return fc(lng, ns, resolver);\n            }\n        },\n        {\n            key: \"prepareLoading\",\n            value: function prepareLoading(languages, namespaces) {\n                var _this = this;\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback = arguments.length > 3 ? arguments[3] : void 0;\n                if (!this.backend) {\n                    this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n                    return callback && callback();\n                }\n                if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n                if (isString(namespaces)) namespaces = [\n                    namespaces\n                ];\n                var toLoad = this.queueLoad(languages, namespaces, options, callback);\n                if (!toLoad.toLoad.length) {\n                    if (!toLoad.pending.length) callback();\n                    return null;\n                }\n                toLoad.toLoad.forEach(function(name) {\n                    _this.loadOne(name);\n                });\n            }\n        },\n        {\n            key: \"load\",\n            value: function load(languages, namespaces, callback) {\n                this.prepareLoading(languages, namespaces, {}, callback);\n            }\n        },\n        {\n            key: \"reload\",\n            value: function reload(languages, namespaces, callback) {\n                this.prepareLoading(languages, namespaces, {\n                    reload: true\n                }, callback);\n            }\n        },\n        {\n            key: \"loadOne\",\n            value: function loadOne(name) {\n                var _this = this;\n                var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '';\n                var s = name.split('|');\n                var lng = s[0];\n                var ns = s[1];\n                this.read(lng, ns, 'read', undefined, undefined, function(err, data) {\n                    if (err) _this.logger.warn(\"\".concat(prefix, \"loading namespace \").concat(ns, \" for language \").concat(lng, \" failed\"), err);\n                    if (!err && data) _this.logger.log(\"\".concat(prefix, \"loaded namespace \").concat(ns, \" for language \").concat(lng), data);\n                    _this.loaded(name, err, data);\n                });\n            }\n        },\n        {\n            key: \"saveMissing\",\n            value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n                var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {};\n                var _this_services_utils, _this_services, _this_services_utils1, _this_services1, _this_backend;\n                if (((_this_services = this.services) === null || _this_services === void 0 ? void 0 : (_this_services_utils = _this_services.utils) === null || _this_services_utils === void 0 ? void 0 : _this_services_utils.hasLoadedNamespace) && !((_this_services1 = this.services) === null || _this_services1 === void 0 ? void 0 : (_this_services_utils1 = _this_services1.utils) === null || _this_services_utils1 === void 0 ? void 0 : _this_services_utils1.hasLoadedNamespace(namespace))) {\n                    this.logger.warn('did not save key \"'.concat(key, '\" as the namespace \"').concat(namespace, '\" was not yet loaded'), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n                    return;\n                }\n                if (key === undefined || key === null || key === '') return;\n                if ((_this_backend = this.backend) === null || _this_backend === void 0 ? void 0 : _this_backend.create) {\n                    var opts = _object_spread_props(_object_spread({}, options), {\n                        isUpdate: isUpdate\n                    });\n                    var fc = this.backend.create.bind(this.backend);\n                    if (fc.length < 6) {\n                        try {\n                            var r;\n                            if (fc.length === 5) {\n                                r = fc(languages, namespace, key, fallbackValue, opts);\n                            } else {\n                                r = fc(languages, namespace, key, fallbackValue);\n                            }\n                            if (r && typeof r.then === 'function') {\n                                r.then(function(data) {\n                                    return clb(null, data);\n                                }).catch(clb);\n                            } else {\n                                clb(null, r);\n                            }\n                        } catch (err) {\n                            clb(err);\n                        }\n                    } else {\n                        fc(languages, namespace, key, fallbackValue, clb, opts);\n                    }\n                }\n                if (!languages || !languages[0]) return;\n                this.store.addResource(languages[0], namespace, key, fallbackValue);\n            }\n        }\n    ]);\n    return Connector;\n}(EventEmitter);\nvar get = function() {\n    return {\n        debug: false,\n        initAsync: true,\n        ns: [\n            'translation'\n        ],\n        defaultNS: [\n            'translation'\n        ],\n        fallbackLng: [\n            'dev'\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: 'all',\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: '.',\n        nsSeparator: ':',\n        pluralSeparator: '_',\n        contextSeparator: '_',\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: 'fallback',\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: function(args) {\n            var ret = {};\n            if (_type_of(args[1]) === 'object') ret = args[1];\n            if (isString(args[1])) ret.defaultValue = args[1];\n            if (isString(args[2])) ret.tDescription = args[2];\n            if (_type_of(args[2]) === 'object' || _type_of(args[3]) === 'object') {\n                var options = args[3] || args[2];\n                Object.keys(options).forEach(function(key) {\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: function(value) {\n                return value;\n            },\n            prefix: '{{',\n            suffix: '}}',\n            formatSeparator: ',',\n            unescapePrefix: '-',\n            nestingPrefix: '$t(',\n            nestingSuffix: ')',\n            nestingOptionsSeparator: ',',\n            maxReplaces: 1000,\n            skipOnVariables: true\n        },\n        cacheInBuiltFormats: true\n    };\n};\nvar transformOptions = function(options) {\n    var _options_supportedLngs_indexOf, _options_supportedLngs;\n    if (isString(options.ns)) options.ns = [\n        options.ns\n    ];\n    if (isString(options.fallbackLng)) options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (isString(options.fallbackNS)) options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (((_options_supportedLngs = options.supportedLngs) === null || _options_supportedLngs === void 0 ? void 0 : (_options_supportedLngs_indexOf = _options_supportedLngs.indexOf) === null || _options_supportedLngs_indexOf === void 0 ? void 0 : _options_supportedLngs_indexOf.call(_options_supportedLngs, 'cimode')) < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            'cimode'\n        ]);\n    }\n    if (typeof options.initImmediate === 'boolean') options.initAsync = options.initImmediate;\n    return options;\n};\nvar noop = function() {};\nvar bindMemberFunctions = function(inst) {\n    var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach(function(mem) {\n        if (typeof inst[mem] === 'function') {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nvar I18n = /*#__PURE__*/ function(EventEmitter) {\n    \"use strict\";\n    _inherits(I18n, EventEmitter);\n    function I18n() {\n        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;\n        _class_call_check(this, I18n);\n        var _this;\n        _this = _call_super(this, I18n);\n        _this.options = transformOptions(options);\n        _this.services = {};\n        _this.logger = baseLogger;\n        _this.modules = {\n            external: []\n        };\n        bindMemberFunctions(_this);\n        if (callback && !_this.isInitialized && !options.isClone) {\n            if (!_this.options.initAsync) {\n                _this.init(options, callback);\n                return _possible_constructor_return(_this, _this);\n            }\n            setTimeout(function() {\n                _this.init(options, callback);\n            }, 0);\n        }\n        return _this;\n    }\n    _create_class(I18n, [\n        {\n            key: \"init\",\n            value: function init() {\n                var _this = this;\n                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;\n                this.isInitializing = true;\n                if (typeof options === 'function') {\n                    callback = options;\n                    options = {};\n                }\n                if (options.defaultNS == null && options.ns) {\n                    if (isString(options.ns)) {\n                        options.defaultNS = options.ns;\n                    } else if (options.ns.indexOf('translation') < 0) {\n                        options.defaultNS = options.ns[0];\n                    }\n                }\n                var defOpts = get();\n                this.options = _object_spread({}, defOpts, this.options, transformOptions(options));\n                this.options.interpolation = _object_spread({}, defOpts.interpolation, this.options.interpolation);\n                if (options.keySeparator !== undefined) {\n                    this.options.userDefinedKeySeparator = options.keySeparator;\n                }\n                if (options.nsSeparator !== undefined) {\n                    this.options.userDefinedNsSeparator = options.nsSeparator;\n                }\n                var createClassOnDemand = function(ClassOrObject) {\n                    if (!ClassOrObject) return null;\n                    if (typeof ClassOrObject === 'function') return new ClassOrObject();\n                    return ClassOrObject;\n                };\n                if (!this.options.isClone) {\n                    var _this1 = this;\n                    if (this.modules.logger) {\n                        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n                    } else {\n                        baseLogger.init(null, this.options);\n                    }\n                    var formatter;\n                    if (this.modules.formatter) {\n                        formatter = this.modules.formatter;\n                    } else {\n                        formatter = Formatter;\n                    }\n                    var lu = new LanguageUtil(this.options);\n                    this.store = new ResourceStore(this.options.resources, this.options);\n                    var s = this.services;\n                    s.logger = baseLogger;\n                    s.resourceStore = this.store;\n                    s.languageUtils = lu;\n                    s.pluralResolver = new PluralResolver(lu, {\n                        prepend: this.options.pluralSeparator,\n                        simplifyPluralSuffix: this.options.simplifyPluralSuffix\n                    });\n                    var usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;\n                    if (usingLegacyFormatFunction) {\n                        this.logger.deprecate(\"init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting\");\n                    }\n                    if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                        s.formatter = createClassOnDemand(formatter);\n                        if (s.formatter.init) s.formatter.init(s, this.options);\n                        this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n                    }\n                    s.interpolator = new Interpolator(this.options);\n                    s.utils = {\n                        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n                    };\n                    s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n                    s.backendConnector.on('*', function(event) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        _this1.emit.apply(_this1, [\n                            event\n                        ].concat(_to_consumable_array(args)));\n                    });\n                    if (this.modules.languageDetector) {\n                        s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n                    }\n                    if (this.modules.i18nFormat) {\n                        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                        if (s.i18nFormat.init) s.i18nFormat.init(this);\n                    }\n                    this.translator = new Translator(this.services, this.options);\n                    this.translator.on('*', function(event) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        _this1.emit.apply(_this1, [\n                            event\n                        ].concat(_to_consumable_array(args)));\n                    });\n                    this.modules.external.forEach(function(m) {\n                        if (m.init) m.init(_this);\n                    });\n                }\n                this.format = this.options.interpolation.format;\n                if (!callback) callback = noop;\n                if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n                    var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                    if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n                }\n                if (!this.services.languageDetector && !this.options.lng) {\n                    this.logger.warn('init: no languageDetector is used and no lng is defined');\n                }\n                var storeApi = [\n                    'getResource',\n                    'hasResourceBundle',\n                    'getResourceBundle',\n                    'getDataByLanguage'\n                ];\n                storeApi.forEach(function(fcName) {\n                    var _this1 = _this;\n                    var _this_store;\n                    _this[fcName] = function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        return (_this_store = _this1.store)[fcName].apply(_this_store, _to_consumable_array(args));\n                    };\n                });\n                var storeApiChained = [\n                    'addResource',\n                    'addResources',\n                    'addResourceBundle',\n                    'removeResourceBundle'\n                ];\n                storeApiChained.forEach(function(fcName) {\n                    var _this1 = _this;\n                    _this[fcName] = function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _this_store;\n                        (_this_store = _this1.store)[fcName].apply(_this_store, _to_consumable_array(args));\n                        return _this1;\n                    };\n                });\n                var deferred = defer();\n                var load = function() {\n                    var finish = function(err, t) {\n                        _this.isInitializing = false;\n                        if (_this.isInitialized && !_this.initializedStoreOnce) _this.logger.warn('init: i18next is already initialized. You should call init just once!');\n                        _this.isInitialized = true;\n                        if (!_this.options.isClone) _this.logger.log('initialized', _this.options);\n                        _this.emit('initialized', _this.options);\n                        deferred.resolve(t);\n                        callback(err, t);\n                    };\n                    if (_this.languages && !_this.isInitialized) return finish(null, _this.t.bind(_this));\n                    _this.changeLanguage(_this.options.lng, finish);\n                };\n                if (this.options.resources || !this.options.initAsync) {\n                    load();\n                } else {\n                    setTimeout(load, 0);\n                }\n                return deferred;\n            }\n        },\n        {\n            key: \"loadResources\",\n            value: function loadResources(language) {\n                var _this = this;\n                var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;\n                var usedCallback = callback;\n                var usedLng = isString(language) ? language : this.language;\n                if (typeof language === 'function') usedCallback = language;\n                if (!this.options.resources || this.options.partialBundledLanguages) {\n                    var _this_options_preload_forEach, _this_options_preload;\n                    if ((usedLng === null || usedLng === void 0 ? void 0 : usedLng.toLowerCase()) === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n                    var toLoad = [];\n                    var append = function(lng) {\n                        if (!lng) return;\n                        if (lng === 'cimode') return;\n                        var lngs = _this.services.languageUtils.toResolveHierarchy(lng);\n                        lngs.forEach(function(l) {\n                            if (l === 'cimode') return;\n                            if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                        });\n                    };\n                    if (!usedLng) {\n                        var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                        fallbacks.forEach(function(l) {\n                            return append(l);\n                        });\n                    } else {\n                        append(usedLng);\n                    }\n                    (_this_options_preload = this.options.preload) === null || _this_options_preload === void 0 ? void 0 : (_this_options_preload_forEach = _this_options_preload.forEach) === null || _this_options_preload_forEach === void 0 ? void 0 : _this_options_preload_forEach.call(_this_options_preload, function(l) {\n                        return append(l);\n                    });\n                    this.services.backendConnector.load(toLoad, this.options.ns, function(e) {\n                        if (!e && !_this.resolvedLanguage && _this.language) _this.setResolvedLanguage(_this.language);\n                        usedCallback(e);\n                    });\n                } else {\n                    usedCallback(null);\n                }\n            }\n        },\n        {\n            key: \"reloadResources\",\n            value: function reloadResources(lngs, ns, callback) {\n                var deferred = defer();\n                if (typeof lngs === 'function') {\n                    callback = lngs;\n                    lngs = undefined;\n                }\n                if (typeof ns === 'function') {\n                    callback = ns;\n                    ns = undefined;\n                }\n                if (!lngs) lngs = this.languages;\n                if (!ns) ns = this.options.ns;\n                if (!callback) callback = noop;\n                this.services.backendConnector.reload(lngs, ns, function(err) {\n                    deferred.resolve();\n                    callback(err);\n                });\n                return deferred;\n            }\n        },\n        {\n            key: \"use\",\n            value: function use(module) {\n                if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n                if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n                if (module.type === 'backend') {\n                    this.modules.backend = module;\n                }\n                if (module.type === 'logger' || module.log && module.warn && module.error) {\n                    this.modules.logger = module;\n                }\n                if (module.type === 'languageDetector') {\n                    this.modules.languageDetector = module;\n                }\n                if (module.type === 'i18nFormat') {\n                    this.modules.i18nFormat = module;\n                }\n                if (module.type === 'postProcessor') {\n                    postProcessor.addPostProcessor(module);\n                }\n                if (module.type === 'formatter') {\n                    this.modules.formatter = module;\n                }\n                if (module.type === '3rdParty') {\n                    this.modules.external.push(module);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setResolvedLanguage\",\n            value: function setResolvedLanguage(l) {\n                if (!l || !this.languages) return;\n                if ([\n                    'cimode',\n                    'dev'\n                ].indexOf(l) > -1) return;\n                for(var li = 0; li < this.languages.length; li++){\n                    var lngInLngs = this.languages[li];\n                    if ([\n                        'cimode',\n                        'dev'\n                    ].indexOf(lngInLngs) > -1) continue;\n                    if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                        this.resolvedLanguage = lngInLngs;\n                        break;\n                    }\n                }\n                if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {\n                    this.resolvedLanguage = l;\n                    this.languages.unshift(l);\n                }\n            }\n        },\n        {\n            key: \"changeLanguage\",\n            value: function changeLanguage(lng, callback) {\n                var _this = this;\n                this.isLanguageChangingTo = lng;\n                var deferred = defer();\n                this.emit('languageChanging', lng);\n                var setLngProps = function(l) {\n                    _this.language = l;\n                    _this.languages = _this.services.languageUtils.toResolveHierarchy(l);\n                    _this.resolvedLanguage = undefined;\n                    _this.setResolvedLanguage(l);\n                };\n                var done = function(err, l) {\n                    var _this1 = _this;\n                    if (l) {\n                        if (_this.isLanguageChangingTo === lng) {\n                            setLngProps(l);\n                            _this.translator.changeLanguage(l);\n                            _this.isLanguageChangingTo = undefined;\n                            _this.emit('languageChanged', l);\n                            _this.logger.log('languageChanged', l);\n                        }\n                    } else {\n                        _this.isLanguageChangingTo = undefined;\n                    }\n                    deferred.resolve(function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        return _this1.t.apply(_this1, _to_consumable_array(args));\n                    });\n                    if (callback) callback(err, function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        return _this1.t.apply(_this1, _to_consumable_array(args));\n                    });\n                };\n                var setLng = function(lngs) {\n                    if (!lng && !lngs && _this.services.languageDetector) lngs = [];\n                    var fl = isString(lngs) ? lngs : lngs && lngs[0];\n                    var l = _this.store.hasLanguageSomeTranslations(fl) ? fl : _this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [\n                        lngs\n                    ] : lngs);\n                    if (l) {\n                        var _this_services_languageDetector_cacheUserLanguage, _this_services_languageDetector;\n                        if (!_this.language) {\n                            setLngProps(l);\n                        }\n                        if (!_this.translator.language) _this.translator.changeLanguage(l);\n                        (_this_services_languageDetector = _this.services.languageDetector) === null || _this_services_languageDetector === void 0 ? void 0 : (_this_services_languageDetector_cacheUserLanguage = _this_services_languageDetector.cacheUserLanguage) === null || _this_services_languageDetector_cacheUserLanguage === void 0 ? void 0 : _this_services_languageDetector_cacheUserLanguage.call(_this_services_languageDetector, l);\n                    }\n                    _this.loadResources(l, function(err) {\n                        done(err, l);\n                    });\n                };\n                if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n                    setLng(this.services.languageDetector.detect());\n                } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n                    if (this.services.languageDetector.detect.length === 0) {\n                        this.services.languageDetector.detect().then(setLng);\n                    } else {\n                        this.services.languageDetector.detect(setLng);\n                    }\n                } else {\n                    setLng(lng);\n                }\n                return deferred;\n            }\n        },\n        {\n            key: \"getFixedT\",\n            value: function getFixedT(lng, ns, keyPrefix) {\n                var _this = this;\n                var fixedT = function(key, opts) {\n                    for(var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                        rest[_key - 2] = arguments[_key];\n                    }\n                    var o;\n                    if ((typeof opts === \"undefined\" ? \"undefined\" : _type_of(opts)) !== 'object') {\n                        o = _this.options.overloadTranslationOptionHandler([\n                            key,\n                            opts\n                        ].concat(rest));\n                    } else {\n                        o = _object_spread({}, opts);\n                    }\n                    o.lng = o.lng || fixedT.lng;\n                    o.lngs = o.lngs || fixedT.lngs;\n                    o.ns = o.ns || fixedT.ns;\n                    if (o.keyPrefix !== '') o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;\n                    var keySeparator = _this.options.keySeparator || '.';\n                    var resultKey;\n                    if (o.keyPrefix && Array.isArray(key)) {\n                        resultKey = key.map(function(k) {\n                            if (typeof k === 'function') k = keysFromSelector(k, _object_spread({}, _this.options, opts));\n                            return \"\".concat(o.keyPrefix).concat(keySeparator).concat(k);\n                        });\n                    } else {\n                        if (typeof key === 'function') key = keysFromSelector(key, _object_spread({}, _this.options, opts));\n                        resultKey = o.keyPrefix ? \"\".concat(o.keyPrefix).concat(keySeparator).concat(key) : key;\n                    }\n                    return _this.t(resultKey, o);\n                };\n                if (isString(lng)) {\n                    fixedT.lng = lng;\n                } else {\n                    fixedT.lngs = lng;\n                }\n                fixedT.ns = ns;\n                fixedT.keyPrefix = keyPrefix;\n                return fixedT;\n            }\n        },\n        {\n            key: \"t\",\n            value: function t() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                var _this_translator;\n                var _this_translator1;\n                return (_this_translator1 = this.translator) === null || _this_translator1 === void 0 ? void 0 : (_this_translator = _this_translator1).translate.apply(_this_translator, _to_consumable_array(args));\n            }\n        },\n        {\n            key: \"exists\",\n            value: function exists() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                var _this_translator;\n                var _this_translator1;\n                return (_this_translator1 = this.translator) === null || _this_translator1 === void 0 ? void 0 : (_this_translator = _this_translator1).exists.apply(_this_translator, _to_consumable_array(args));\n            }\n        },\n        {\n            key: \"setDefaultNamespace\",\n            value: function setDefaultNamespace(ns) {\n                this.options.defaultNS = ns;\n            }\n        },\n        {\n            key: \"hasLoadedNamespace\",\n            value: function hasLoadedNamespace(ns) {\n                var _this = this;\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (!this.isInitialized) {\n                    this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n                    return false;\n                }\n                if (!this.languages || !this.languages.length) {\n                    this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n                    return false;\n                }\n                var lng = options.lng || this.resolvedLanguage || this.languages[0];\n                var fallbackLng = this.options ? this.options.fallbackLng : false;\n                var lastLng = this.languages[this.languages.length - 1];\n                if (lng.toLowerCase() === 'cimode') return true;\n                var loadNotPending = function(l, n) {\n                    var loadState = _this.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n                    return loadState === -1 || loadState === 0 || loadState === 2;\n                };\n                if (options.precheck) {\n                    var preResult = options.precheck(this, loadNotPending);\n                    if (preResult !== undefined) return preResult;\n                }\n                if (this.hasResourceBundle(lng, ns)) return true;\n                if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n                if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n                return false;\n            }\n        },\n        {\n            key: \"loadNamespaces\",\n            value: function loadNamespaces(ns, callback) {\n                var _this = this;\n                var deferred = defer();\n                if (!this.options.ns) {\n                    if (callback) callback();\n                    return Promise.resolve();\n                }\n                if (isString(ns)) ns = [\n                    ns\n                ];\n                ns.forEach(function(n) {\n                    if (_this.options.ns.indexOf(n) < 0) _this.options.ns.push(n);\n                });\n                this.loadResources(function(err) {\n                    deferred.resolve();\n                    if (callback) callback(err);\n                });\n                return deferred;\n            }\n        },\n        {\n            key: \"loadLanguages\",\n            value: function loadLanguages(lngs, callback) {\n                var _this = this;\n                var deferred = defer();\n                if (isString(lngs)) lngs = [\n                    lngs\n                ];\n                var preloaded = this.options.preload || [];\n                var newLngs = lngs.filter(function(lng) {\n                    return preloaded.indexOf(lng) < 0 && _this.services.languageUtils.isSupportedCode(lng);\n                });\n                if (!newLngs.length) {\n                    if (callback) callback();\n                    return Promise.resolve();\n                }\n                this.options.preload = preloaded.concat(newLngs);\n                this.loadResources(function(err) {\n                    deferred.resolve();\n                    if (callback) callback(err);\n                });\n                return deferred;\n            }\n        },\n        {\n            key: \"dir\",\n            value: function dir(lng) {\n                var _this_languages, _this_services;\n                if (!lng) lng = this.resolvedLanguage || (((_this_languages = this.languages) === null || _this_languages === void 0 ? void 0 : _this_languages.length) > 0 ? this.languages[0] : this.language);\n                if (!lng) return 'rtl';\n                try {\n                    var l = new Intl.Locale(lng);\n                    if (l && l.getTextInfo) {\n                        var ti = l.getTextInfo();\n                        if (ti && ti.direction) return ti.direction;\n                    }\n                } catch (e) {}\n                var rtlLngs = [\n                    'ar',\n                    'shu',\n                    'sqr',\n                    'ssh',\n                    'xaa',\n                    'yhd',\n                    'yud',\n                    'aao',\n                    'abh',\n                    'abv',\n                    'acm',\n                    'acq',\n                    'acw',\n                    'acx',\n                    'acy',\n                    'adf',\n                    'ads',\n                    'aeb',\n                    'aec',\n                    'afb',\n                    'ajp',\n                    'apc',\n                    'apd',\n                    'arb',\n                    'arq',\n                    'ars',\n                    'ary',\n                    'arz',\n                    'auz',\n                    'avl',\n                    'ayh',\n                    'ayl',\n                    'ayn',\n                    'ayp',\n                    'bbz',\n                    'pga',\n                    'he',\n                    'iw',\n                    'ps',\n                    'pbt',\n                    'pbu',\n                    'pst',\n                    'prp',\n                    'prd',\n                    'ug',\n                    'ur',\n                    'ydd',\n                    'yds',\n                    'yih',\n                    'ji',\n                    'yi',\n                    'hbo',\n                    'men',\n                    'xmn',\n                    'fa',\n                    'jpr',\n                    'peo',\n                    'pes',\n                    'prs',\n                    'dv',\n                    'sam',\n                    'ckb'\n                ];\n                var languageUtils = ((_this_services = this.services) === null || _this_services === void 0 ? void 0 : _this_services.languageUtils) || new LanguageUtil(get());\n                if (lng.toLowerCase().indexOf('-latn') > 1) return 'ltr';\n                return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n            }\n        },\n        {\n            key: \"cloneInstance\",\n            value: function cloneInstance() {\n                var _this = this;\n                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;\n                var forkResourceStore = options.forkResourceStore;\n                if (forkResourceStore) delete options.forkResourceStore;\n                var mergedOptions = _object_spread({}, this.options, options, {\n                    isClone: true\n                });\n                var clone = new I18n(mergedOptions);\n                if (options.debug !== undefined || options.prefix !== undefined) {\n                    clone.logger = clone.logger.clone(options);\n                }\n                var membersToCopy = [\n                    'store',\n                    'services',\n                    'language'\n                ];\n                membersToCopy.forEach(function(m) {\n                    clone[m] = _this[m];\n                });\n                clone.services = _object_spread({}, this.services);\n                clone.services.utils = {\n                    hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n                };\n                if (forkResourceStore) {\n                    var clonedData = Object.keys(this.store.data).reduce(function(prev, l) {\n                        prev[l] = _object_spread({}, _this.store.data[l]);\n                        prev[l] = Object.keys(prev[l]).reduce(function(acc, n) {\n                            acc[n] = _object_spread({}, prev[l][n]);\n                            return acc;\n                        }, prev[l]);\n                        return prev;\n                    }, {});\n                    clone.store = new ResourceStore(clonedData, mergedOptions);\n                    clone.services.resourceStore = clone.store;\n                }\n                clone.translator = new Translator(clone.services, mergedOptions);\n                clone.translator.on('*', function(event) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var _clone;\n                    (_clone = clone).emit.apply(_clone, [\n                        event\n                    ].concat(_to_consumable_array(args)));\n                });\n                clone.init(mergedOptions, callback);\n                clone.translator.options = mergedOptions;\n                clone.translator.backendConnector.services.utils = {\n                    hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n                };\n                return clone;\n            }\n        },\n        {\n            key: \"toJSON\",\n            value: function toJSON() {\n                return {\n                    options: this.options,\n                    store: this.store,\n                    language: this.language,\n                    languages: this.languages,\n                    resolvedLanguage: this.resolvedLanguage\n                };\n            }\n        }\n    ], [\n        {\n            key: \"createInstance\",\n            value: function createInstance() {\n                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;\n                return new I18n(options, callback);\n            }\n        }\n    ]);\n    return I18n;\n}(EventEmitter);\nvar instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nvar createInstance = instance.createInstance;\nvar dir = instance.dir;\nvar init = instance.init;\nvar loadResources = instance.loadResources;\nvar reloadResources = instance.reloadResources;\nvar use = instance.use;\nvar changeLanguage = instance.changeLanguage;\nvar getFixedT = instance.getFixedT;\nvar t = instance.t;\nvar exists = instance.exists;\nvar setDefaultNamespace = instance.setDefaultNamespace;\nvar hasLoadedNamespace = instance.hasLoadedNamespace;\nvar loadNamespaces = instance.loadNamespaces;\nvar loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9lc20vaTE4bmV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQU1BLFdBQVdDLFNBQUFBO1dBQU8sT0FBT0EsUUFBUTs7QUFDdkMsSUFBTUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFNQyxVQUFVLElBQUlDLFFBQVEsU0FBQ0MsU0FBU0M7UUFDcENMLE1BQU1JO1FBQ05ILE1BQU1JO0lBQ1I7SUFDQUgsUUFBUUUsT0FBTyxHQUFHSjtJQUNsQkUsUUFBUUcsTUFBTSxHQUFHSjtJQUNqQixPQUFPQztBQUNUO0FBQ0EsSUFBTUksYUFBYUMsU0FBQUE7SUFDakIsSUFBSUEsVUFBVSxNQUFNLE9BQU87SUFDM0IsT0FBTyxLQUFLQTtBQUNkO0FBQ0EsSUFBTUMsT0FBTyxTQUFDQyxHQUFHQyxHQUFHQztJQUNsQkYsRUFBRUcsT0FBTyxDQUFDQyxTQUFBQTtRQUNSLElBQUlILENBQUMsQ0FBQ0csRUFBRSxFQUFFRixDQUFDLENBQUNFLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ3ZCO0FBQ0Y7QUFDQSxJQUFNQyw0QkFBNEI7QUFDbEMsSUFBTUMsV0FBV0MsU0FBQUE7V0FBT0EsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJRCxJQUFJRSxPQUFPLENBQUNKLDJCQUEyQixPQUFPRTs7QUFDdkcsSUFBTUcsdUJBQXVCWixTQUFBQTtXQUFVLENBQUNBLFVBQVVWLFNBQVNVOztBQUMzRCxJ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Z1g7WUFDM0I7OztXQXJhSXNDO0VBQWF6WTtBQW1lbkIsSUFBTXljLFdBQVdoRSxLQUFLK0QsY0FBYztBQUNwQ0MsU0FBU0QsY0FBYyxHQUFHL0QsS0FBSytELGNBQWM7QUFFN0MsSUFBTUEsaUJBQWlCQyxTQUFTRCxjQUFjO0FBQzlDLElBQU1iLE1BQU1jLFNBQVNkLEdBQUc7QUFDeEIsSUFBTXZjLE9BQU9xZCxTQUFTcmQsSUFBSTtBQUMxQixJQUFNdWEsZ0JBQWdCOEMsU0FBUzlDLGFBQWE7QUFDNUMsSUFBTUssa0JBQWtCeUMsU0FBU3pDLGVBQWU7QUFDaEQsSUFBTUMsTUFBTXdDLFNBQVN4QyxHQUFHO0FBQ3hCLElBQU14VixpQkFBaUJnWSxTQUFTaFksY0FBYztBQUM5QyxJQUFNb1csWUFBWTRCLFNBQVM1QixTQUFTO0FBQ3BDLElBQU16aEIsSUFBSXFqQixTQUFTcmpCLENBQUM7QUFDcEIsSUFBTXVMLFNBQVM4WCxTQUFTOVgsTUFBTTtBQUM5QixJQUFNc1csc0JBQXNCd0IsU0FBU3hCLG1CQUFtQjtBQUN4RCxJQUFNOVAscUJBQXFCc1IsU0FBU3RSLGtCQUFrQjtBQUN0RCxJQUFNb1EsaUJBQWlCa0IsU0FBU2xCLGNBQWM7QUFDOUMsSUFBTUMsZ0JBQWdCaUIsU0FBU2pCLGFBQWE7QUFFc00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanM/ZTQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1N0cmluZyA9IG9iaiA9PiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcbmNvbnN0IGRlZmVyID0gKCkgPT4ge1xuICBsZXQgcmVzO1xuICBsZXQgcmVqO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmU7XG4gICAgcmVqID0gcmVqZWN0O1xuICB9KTtcbiAgcHJvbWlzZS5yZXNvbHZlID0gcmVzO1xuICBwcm9taXNlLnJlamVjdCA9IHJlajtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuY29uc3QgbWFrZVN0cmluZyA9IG9iamVjdCA9PiB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICcnO1xuICByZXR1cm4gJycgKyBvYmplY3Q7XG59O1xuY29uc3QgY29weSA9IChhLCBzLCB0KSA9PiB7XG4gIGEuZm9yRWFjaChtID0+IHtcbiAgICBpZiAoc1ttXSkgdFttXSA9IHNbbV07XG4gIH0pO1xufTtcbmNvbnN0IGxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAgPSAvIyMjL2c7XG5jb25zdCBjbGVhbktleSA9IGtleSA9PiBrZXkgJiYga2V5LmluZGV4T2YoJyMjIycpID4gLTEgPyBrZXkucmVwbGFjZShsYXN0T2ZQYXRoU2VwYXJhdG9yUmVnRXhwLCAnLicpIDoga2V5O1xuY29uc3QgY2FuTm90VHJhdmVyc2VEZWVwZXIgPSBvYmplY3QgPT4gIW9iamVjdCB8fCBpc1N0cmluZyhvYmplY3QpO1xuY29uc3QgZ2V0TGFzdE9mUGF0aCA9IChvYmplY3QsIHBhdGgsIEVtcHR5KSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gIWlzU3RyaW5nKHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IHN0YWNrSW5kZXggPSAwO1xuICB3aGlsZSAoc3RhY2tJbmRleCA8IHN0YWNrLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoY2FuTm90VHJhdmVyc2VEZWVwZXIob2JqZWN0KSkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGtleSA9IGNsZWFuS2V5KHN0YWNrW3N0YWNrSW5kZXhdKTtcbiAgICBpZiAoIW9iamVjdFtrZXldICYmIEVtcHR5KSBvYmplY3Rba2V5XSA9IG5ldyBFbXB0eSgpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0ID0ge307XG4gICAgfVxuICAgICsrc3RhY2tJbmRleDtcbiAgfVxuICBpZiAoY2FuTm90VHJhdmVyc2VEZWVwZXIob2JqZWN0KSkgcmV0dXJuIHt9O1xuICByZXR1cm4ge1xuICAgIG9iajogb2JqZWN0LFxuICAgIGs6IGNsZWFuS2V5KHN0YWNrW3N0YWNrSW5kZXhdKVxuICB9O1xufTtcbmNvbnN0IHNldFBhdGggPSAob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSkgPT4ge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBPYmplY3QpO1xuICBpZiAob2JqICE9PSB1bmRlZmluZWQgfHwgcGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBvYmpba10gPSBuZXdWYWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGxldCBwID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICBsZXQgbGFzdCA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwLCBPYmplY3QpO1xuICB3aGlsZSAobGFzdC5vYmogPT09IHVuZGVmaW5lZCAmJiBwLmxlbmd0aCkge1xuICAgIGUgPSBgJHtwW3AubGVuZ3RoIC0gMV19LiR7ZX1gO1xuICAgIHAgPSBwLnNsaWNlKDAsIHAubGVuZ3RoIC0gMSk7XG4gICAgbGFzdCA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwLCBPYmplY3QpO1xuICAgIGlmIChsYXN0Py5vYmogJiYgdHlwZW9mIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbGFzdC5vYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdID0gbmV3VmFsdWU7XG59O1xuY29uc3QgcHVzaFBhdGggPSAob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSwgY29uY2F0KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG9ialtrXSB8fCBbXTtcbiAgb2JqW2tdLnB1c2gobmV3VmFsdWUpO1xufTtcbmNvbnN0IGdldFBhdGggPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn07XG5jb25zdCBnZXRQYXRoV2l0aERlZmF1bHRzID0gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBnZXRQYXRoKGRhdGEsIGtleSk7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRQYXRoKGRlZmF1bHREYXRhLCBrZXkpO1xufTtcbmNvbnN0IGRlZXBFeHRlbmQgPSAodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkgPT4ge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgaWYgKHByb3AgIT09ICdfX3Byb3RvX18nICYmIHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0W3Byb3BdKSB8fCB0YXJnZXRbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcgfHwgaXNTdHJpbmcoc291cmNlW3Byb3BdKSB8fCBzb3VyY2VbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBpZiAob3ZlcndyaXRlKSB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IHJlZ2V4RXNjYXBlID0gc3RyID0+IHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xudmFyIF9lbnRpdHlNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICcvJzogJyYjeDJGOydcbn07XG5jb25zdCBlc2NhcGUgPSBkYXRhID0+IHtcbiAgaWYgKGlzU3RyaW5nKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgcyA9PiBfZW50aXR5TWFwW3NdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5jbGFzcyBSZWdFeHBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMucmVnRXhwTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVnRXhwUXVldWUgPSBbXTtcbiAgfVxuICBnZXRSZWdFeHAocGF0dGVybikge1xuICAgIGNvbnN0IHJlZ0V4cEZyb21DYWNoZSA9IHRoaXMucmVnRXhwTWFwLmdldChwYXR0ZXJuKTtcbiAgICBpZiAocmVnRXhwRnJvbUNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZWdFeHBGcm9tQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHJlZ0V4cE5ldyA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgaWYgKHRoaXMucmVnRXhwUXVldWUubGVuZ3RoID09PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICB0aGlzLnJlZ0V4cE1hcC5kZWxldGUodGhpcy5yZWdFeHBRdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gICAgdGhpcy5yZWdFeHBNYXAuc2V0KHBhdHRlcm4sIHJlZ0V4cE5ldyk7XG4gICAgdGhpcy5yZWdFeHBRdWV1ZS5wdXNoKHBhdHRlcm4pO1xuICAgIHJldHVybiByZWdFeHBOZXc7XG4gIH1cbn1cbmNvbnN0IGNoYXJzID0gWycgJywgJywnLCAnPycsICchJywgJzsnXTtcbmNvbnN0IGxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSA9IG5ldyBSZWdFeHBDYWNoZSgyMCk7XG5jb25zdCBsb29rc0xpa2VPYmplY3RQYXRoID0gKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcikgPT4ge1xuICBuc1NlcGFyYXRvciA9IG5zU2VwYXJhdG9yIHx8ICcnO1xuICBrZXlTZXBhcmF0b3IgPSBrZXlTZXBhcmF0b3IgfHwgJyc7XG4gIGNvbnN0IHBvc3NpYmxlQ2hhcnMgPSBjaGFycy5maWx0ZXIoYyA9PiBuc1NlcGFyYXRvci5pbmRleE9mKGMpIDwgMCAmJiBrZXlTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDApO1xuICBpZiAocG9zc2libGVDaGFycy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBjb25zdCByID0gbG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlLmdldFJlZ0V4cChgKCR7cG9zc2libGVDaGFycy5tYXAoYyA9PiBjID09PSAnPycgPyAnXFxcXD8nIDogYykuam9pbignfCcpfSlgKTtcbiAgbGV0IG1hdGNoZWQgPSAhci50ZXN0KGtleSk7XG4gIGlmICghbWF0Y2hlZCkge1xuICAgIGNvbnN0IGtpID0ga2V5LmluZGV4T2Yoa2V5U2VwYXJhdG9yKTtcbiAgICBpZiAoa2kgPiAwICYmICFyLnRlc3Qoa2V5LnN1YnN0cmluZygwLCBraSkpKSB7XG4gICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZWQ7XG59O1xuY29uc3QgZGVlcEZpbmQgPSAob2JqLCBwYXRoLCBrZXlTZXBhcmF0b3IgPSAnLicpID0+IHtcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChvYmpbcGF0aF0pIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHBhdGgpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBvYmpbcGF0aF07XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gcGF0aC5zcGxpdChrZXlTZXBhcmF0b3IpO1xuICBsZXQgY3VycmVudCA9IG9iajtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOykge1xuICAgIGlmICghY3VycmVudCB8fCB0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBuZXh0O1xuICAgIGxldCBuZXh0UGF0aCA9ICcnO1xuICAgIGZvciAobGV0IGogPSBpOyBqIDwgdG9rZW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaiAhPT0gaSkge1xuICAgICAgICBuZXh0UGF0aCArPSBrZXlTZXBhcmF0b3I7XG4gICAgICB9XG4gICAgICBuZXh0UGF0aCArPSB0b2tlbnNbal07XG4gICAgICBuZXh0ID0gY3VycmVudFtuZXh0UGF0aF07XG4gICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLmluZGV4T2YodHlwZW9mIG5leHQpID4gLTEgJiYgaiA8IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSBqIC0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50ID0gbmV4dDtcbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn07XG5jb25zdCBnZXRDbGVhbmVkQ29kZSA9IGNvZGUgPT4gY29kZT8ucmVwbGFjZSgnXycsICctJyk7XG5cbmNvbnN0IGNvbnNvbGVMb2dnZXIgPSB7XG4gIHR5cGU6ICdsb2dnZXInLFxuICBsb2coYXJncykge1xuICAgIHRoaXMub3V0cHV0KCdsb2cnLCBhcmdzKTtcbiAgfSxcbiAgd2FybihhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ3dhcm4nLCBhcmdzKTtcbiAgfSxcbiAgZXJyb3IoYXJncykge1xuICAgIHRoaXMub3V0cHV0KCdlcnJvcicsIGFyZ3MpO1xuICB9LFxuICBvdXRwdXQodHlwZSwgYXJncykge1xuICAgIGNvbnNvbGU/Llt0eXBlXT8uYXBwbHk/Lihjb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmluaXQoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMpO1xuICB9XG4gIGluaXQoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2kxOG5leHQ6JztcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmNyZXRlTG9nZ2VyIHx8IGNvbnNvbGVMb2dnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgfVxuICBsb2coLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2xvZycsICcnLCB0cnVlKTtcbiAgfVxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJycsIHRydWUpO1xuICB9XG4gIGVycm9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdlcnJvcicsICcnKTtcbiAgfVxuICBkZXByZWNhdGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnV0FSTklORyBERVBSRUNBVEVEOiAnLCB0cnVlKTtcbiAgfVxuICBmb3J3YXJkKGFyZ3MsIGx2bCwgcHJlZml4LCBkZWJ1Z09ubHkpIHtcbiAgICBpZiAoZGVidWdPbmx5ICYmICF0aGlzLmRlYnVnKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNTdHJpbmcoYXJnc1swXSkpIGFyZ3NbMF0gPSBgJHtwcmVmaXh9JHt0aGlzLnByZWZpeH0gJHthcmdzWzBdfWA7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyW2x2bF0oYXJncyk7XG4gIH1cbiAgY3JlYXRlKG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwge1xuICAgICAgLi4ue1xuICAgICAgICBwcmVmaXg6IGAke3RoaXMucHJlZml4fToke21vZHVsZU5hbWV9OmBcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjbG9uZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zO1xuICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgdGhpcy5wcmVmaXg7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICB9XG59XG52YXIgYmFzZUxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSB7fTtcbiAgfVxuICBvbihldmVudHMsIGxpc3RlbmVyKSB7XG4gICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkgdGhpcy5vYnNlcnZlcnNbZXZlbnRdID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbnVtTGlzdGVuZXJzID0gdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmdldChsaXN0ZW5lcikgfHwgMDtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5zZXQobGlzdGVuZXIsIG51bUxpc3RlbmVycyArIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkgcmV0dXJuO1xuICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tldmVudF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5lbnRyaWVzKCkpO1xuICAgICAgY2xvbmVkLmZvckVhY2goKFtvYnNlcnZlciwgbnVtVGltZXNBZGRlZF0pID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzWycqJ10uZW50cmllcygpKTtcbiAgICAgIGNsb25lZC5mb3JFYWNoKChbb2JzZXJ2ZXIsIG51bVRpbWVzQWRkZWRdKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXNBZGRlZDsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuYXBwbHkob2JzZXJ2ZXIsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVzb3VyY2VTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7XG4gICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICBkZWZhdWx0TlM6ICd0cmFuc2xhdGlvbidcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPSAnLic7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGFkZE5hbWVzcGFjZXMobnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpIDwgMCkge1xuICAgICAgdGhpcy5vcHRpb25zLm5zLnB1c2gobnMpO1xuICAgIH1cbiAgfVxuICByZW1vdmVOYW1lc3BhY2VzKG5zKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucyk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBnZXRSZXNvdXJjZShsbmcsIG5zLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3QgaWdub3JlSlNPTlN0cnVjdHVyZSA9IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlIDogdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gW2xuZywgbnNdO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoa2V5KSAmJiBrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBwYXRoLnB1c2goLi4ua2V5LnNwbGl0KGtleVNlcGFyYXRvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKTtcbiAgICBpZiAoIXJlc3VsdCAmJiAhbnMgJiYgIWtleSAmJiBsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIGxuZyA9IHBhdGhbMF07XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgICBrZXkgPSBwYXRoLnNsaWNlKDIpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCB8fCAhaWdub3JlSlNPTlN0cnVjdHVyZSB8fCAhaXNTdHJpbmcoa2V5KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gZGVlcEZpbmQodGhpcy5kYXRhPy5bbG5nXT8uW25zXSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIGFkZFJlc291cmNlKGxuZywgbnMsIGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7XG4gICAgc2lsZW50OiBmYWxzZVxuICB9KSB7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAoa2V5KSBwYXRoID0gcGF0aC5jb25jYXQoa2V5U2VwYXJhdG9yID8ga2V5LnNwbGl0KGtleVNlcGFyYXRvcikgOiBrZXkpO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIHZhbHVlID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywga2V5LCB2YWx1ZSk7XG4gIH1cbiAgYWRkUmVzb3VyY2VzKGxuZywgbnMsIHJlc291cmNlcywgb3B0aW9ucyA9IHtcbiAgICBzaWxlbnQ6IGZhbHNlXG4gIH0pIHtcbiAgICBmb3IgKGNvbnN0IG0gaW4gcmVzb3VyY2VzKSB7XG4gICAgICBpZiAoaXNTdHJpbmcocmVzb3VyY2VzW21dKSB8fCBBcnJheS5pc0FycmF5KHJlc291cmNlc1ttXSkpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIGFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIHJlc291cmNlcywgZGVlcCwgb3ZlcndyaXRlLCBvcHRpb25zID0ge1xuICAgIHNpbGVudDogZmFsc2UsXG4gICAgc2tpcENvcHk6IGZhbHNlXG4gIH0pIHtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICBkZWVwID0gcmVzb3VyY2VzO1xuICAgICAgcmVzb3VyY2VzID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgbGV0IHBhY2sgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCkgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnNraXBDb3B5KSByZXNvdXJjZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc291cmNlcykpO1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBkZWVwRXh0ZW5kKHBhY2ssIHJlc291cmNlcywgb3ZlcndyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjayA9IHtcbiAgICAgICAgLi4ucGFjayxcbiAgICAgICAgLi4ucmVzb3VyY2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgcGFjayk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgcmVtb3ZlUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSB7XG4gICAgICBkZWxldGUgdGhpcy5kYXRhW2xuZ11bbnNdO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZU5hbWVzcGFjZXMobnMpO1xuICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIGxuZywgbnMpO1xuICB9XG4gIGhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKSAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0TlM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucyk7XG4gIH1cbiAgZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsbmddO1xuICB9XG4gIGhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmcpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhQnlMYW5ndWFnZShsbmcpO1xuICAgIGNvbnN0IG4gPSBkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpIHx8IFtdO1xuICAgIHJldHVybiAhIW4uZmluZCh2ID0+IGRhdGFbdl0gJiYgT2JqZWN0LmtleXMoZGF0YVt2XSkubGVuZ3RoID4gMCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxudmFyIHBvc3RQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NvcnM6IHt9LFxuICBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZShwcm9jZXNzb3JzLCB2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSB7XG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKHByb2Nlc3NvciA9PiB7XG4gICAgICB2YWx1ZSA9IHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdPy5wcm9jZXNzKHZhbHVlLCBrZXksIG9wdGlvbnMsIHRyYW5zbGF0b3IpID8/IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuY29uc3QgUEFUSF9LRVkgPSBTeW1ib2woJ2kxOG5leHQvUEFUSF9LRVknKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KCkge1xuICBjb25zdCBzdGF0ZSA9IFtdO1xuICBjb25zdCBoYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHByb3h5O1xuICBoYW5kbGVyLmdldCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHByb3h5Py5yZXZva2U/LigpO1xuICAgIGlmIChrZXkgPT09IFBBVEhfS0VZKSByZXR1cm4gc3RhdGU7XG4gICAgc3RhdGUucHVzaChrZXkpO1xuICAgIHByb3h5ID0gUHJveHkucmV2b2NhYmxlKHRhcmdldCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHByb3h5LnByb3h5O1xuICB9O1xuICByZXR1cm4gUHJveHkucmV2b2NhYmxlKE9iamVjdC5jcmVhdGUobnVsbCksIGhhbmRsZXIpLnByb3h5O1xufVxuZnVuY3Rpb24ga2V5c0Zyb21TZWxlY3RvcihzZWxlY3Rvciwgb3B0cykge1xuICBjb25zdCB7XG4gICAgW1BBVEhfS0VZXTogcGF0aFxuICB9ID0gc2VsZWN0b3IoY3JlYXRlUHJveHkoKSk7XG4gIHJldHVybiBwYXRoLmpvaW4ob3B0cz8ua2V5U2VwYXJhdG9yID8/ICcuJyk7XG59XG5cbmNvbnN0IGNoZWNrZWRMb2FkZWRGb3IgPSB7fTtcbmNvbnN0IHNob3VsZEhhbmRsZUFzT2JqZWN0ID0gcmVzID0+ICFpc1N0cmluZyhyZXMpICYmIHR5cGVvZiByZXMgIT09ICdib29sZWFuJyAmJiB0eXBlb2YgcmVzICE9PSAnbnVtYmVyJztcbmNsYXNzIFRyYW5zbGF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2aWNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb3B5KFsncmVzb3VyY2VTdG9yZScsICdsYW5ndWFnZVV0aWxzJywgJ3BsdXJhbFJlc29sdmVyJywgJ2ludGVycG9sYXRvcicsICdiYWNrZW5kQ29ubmVjdG9yJywgJ2kxOG5Gb3JtYXQnLCAndXRpbHMnXSwgc2VydmljZXMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgndHJhbnNsYXRvcicpO1xuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZykge1xuICAgIGlmIChsbmcpIHRoaXMubGFuZ3VhZ2UgPSBsbmc7XG4gIH1cbiAgZXhpc3RzKGtleSwgbyA9IHtcbiAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICB9KSB7XG4gICAgY29uc3Qgb3B0ID0ge1xuICAgICAgLi4ub1xuICAgIH07XG4gICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5LCBvcHQpO1xuICAgIHJldHVybiByZXNvbHZlZD8ucmVzICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZXh0cmFjdEZyb21LZXkoa2V5LCBvcHQpIHtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHQubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0LmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0LmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IG5hbWVzcGFjZXMgPSBvcHQubnMgfHwgdGhpcy5vcHRpb25zLmRlZmF1bHROUyB8fCBbXTtcbiAgICBjb25zdCB3b3VsZENoZWNrRm9yTnNJbktleSA9IG5zU2VwYXJhdG9yICYmIGtleS5pbmRleE9mKG5zU2VwYXJhdG9yKSA+IC0xO1xuICAgIGNvbnN0IHNlZW1zTmF0dXJhbExhbmd1YWdlID0gIXRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciAmJiAhb3B0LmtleVNlcGFyYXRvciAmJiAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgJiYgIW9wdC5uc1NlcGFyYXRvciAmJiAhbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmICh3b3VsZENoZWNrRm9yTnNJbktleSAmJiAhc2VlbXNOYXR1cmFsTGFuZ3VhZ2UpIHtcbiAgICAgIGNvbnN0IG0gPSBrZXkubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlczogaXNTdHJpbmcobmFtZXNwYWNlcykgPyBbbmFtZXNwYWNlc10gOiBuYW1lc3BhY2VzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdChuc1NlcGFyYXRvcik7XG4gICAgICBpZiAobnNTZXBhcmF0b3IgIT09IGtleVNlcGFyYXRvciB8fCBuc1NlcGFyYXRvciA9PT0ga2V5U2VwYXJhdG9yICYmIHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKHBhcnRzWzBdKSA+IC0xKSBuYW1lc3BhY2VzID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGtleSA9IHBhcnRzLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXM6IGlzU3RyaW5nKG5hbWVzcGFjZXMpID8gW25hbWVzcGFjZXNdIDogbmFtZXNwYWNlc1xuICAgIH07XG4gIH1cbiAgdHJhbnNsYXRlKGtleXMsIG8sIGxhc3RLZXkpIHtcbiAgICBsZXQgb3B0ID0gdHlwZW9mIG8gPT09ICdvYmplY3QnID8ge1xuICAgICAgLi4ub1xuICAgIH0gOiBvO1xuICAgIGlmICh0eXBlb2Ygb3B0ICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdCA9IHRoaXMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ29iamVjdCcpIG9wdCA9IHtcbiAgICAgIC4uLm9wdFxuICAgIH07XG4gICAgaWYgKCFvcHQpIG9wdCA9IHt9O1xuICAgIGlmIChrZXlzID09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdmdW5jdGlvbicpIGtleXMgPSBrZXlzRnJvbVNlbGVjdG9yKGtleXMsIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdFxuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHQucmV0dXJuRGV0YWlscyAhPT0gdW5kZWZpbmVkID8gb3B0LnJldHVybkRldGFpbHMgOiB0aGlzLm9wdGlvbnMucmV0dXJuRGV0YWlscztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHQua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHQua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfSA9IHRoaXMuZXh0cmFjdEZyb21LZXkoa2V5c1trZXlzLmxlbmd0aCAtIDFdLCBvcHQpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHQubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3QgbG5nID0gb3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIGNvbnN0IGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlID0gb3B0LmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nPy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgfVxuICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXM6IGtleSxcbiAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgZXhhY3RVc2VkS2V5OiBrZXksXG4gICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5cywgb3B0KTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQ/LnJlcztcbiAgICBjb25zdCByZXNVc2VkS2V5ID0gcmVzb2x2ZWQ/LnVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc0V4YWN0VXNlZEtleSA9IHJlc29sdmVkPy5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgY29uc3Qgam9pbkFycmF5cyA9IG9wdC5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHQuam9pbkFycmF5cyA6IHRoaXMub3B0aW9ucy5qb2luQXJyYXlzO1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ID0gIXRoaXMuaTE4bkZvcm1hdCB8fCB0aGlzLmkxOG5Gb3JtYXQuaGFuZGxlQXNPYmplY3Q7XG4gICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdC5jb3VudCAhPT0gdW5kZWZpbmVkICYmICFpc1N0cmluZyhvcHQuY291bnQpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IFRyYW5zbGF0b3IuaGFzRGVmYXVsdFZhbHVlKG9wdCk7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4ID0gbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCBvcHQpIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0Lm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCB7XG4gICAgICBvcmRpbmFsOiBmYWxzZVxuICAgIH0pIDogJyc7XG4gICAgY29uc3QgbmVlZHNaZXJvU3VmZml4TG9va3VwID0gbmVlZHNQbHVyYWxIYW5kbGluZyAmJiAhb3B0Lm9yZGluYWwgJiYgb3B0LmNvdW50ID09PSAwO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCAmJiBvcHRbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gfHwgb3B0W2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeH1gXSB8fCBvcHRbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdC5kZWZhdWx0VmFsdWU7XG4gICAgbGV0IHJlc0Zvck9iakhuZGwgPSByZXM7XG4gICAgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmICFyZXMgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXNGb3JPYmpIbmRsID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVBc09iamVjdCA9IHNob3VsZEhhbmRsZUFzT2JqZWN0KHJlc0Zvck9iakhuZGwpO1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc0Zvck9iakhuZGwpO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXNGb3JPYmpIbmRsICYmIGhhbmRsZUFzT2JqZWN0ICYmIG5vT2JqZWN0LmluZGV4T2YocmVzVHlwZSkgPCAwICYmICEoaXNTdHJpbmcoam9pbkFycmF5cykgJiYgQXJyYXkuaXNBcnJheShyZXNGb3JPYmpIbmRsKSkpIHtcbiAgICAgIGlmICghb3B0LnJldHVybk9iamVjdHMgJiYgIXRoaXMub3B0aW9ucy5yZXR1cm5PYmplY3RzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FjY2Vzc2luZyBhbiBvYmplY3QgLSBidXQgcmV0dXJuT2JqZWN0cyBvcHRpb25zIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcihyZXNVc2VkS2V5LCByZXNGb3JPYmpIbmRsLCB7XG4gICAgICAgICAgLi4ub3B0LFxuICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgIH0pIDogYGtleSAnJHtrZXl9ICgke3RoaXMubGFuZ3VhZ2V9KScgcmV0dXJuZWQgYW4gb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nLmA7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmVzb2x2ZWQucmVzID0gcjtcbiAgICAgICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzVHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlc0Zvck9iakhuZGwpO1xuICAgICAgICBjb25zdCBjb3B5ID0gcmVzVHlwZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBjb25zdCBuZXdLZXlUb1VzZSA9IHJlc1R5cGVJc0FycmF5ID8gcmVzRXhhY3RVc2VkS2V5IDogcmVzVXNlZEtleTtcbiAgICAgICAgZm9yIChjb25zdCBtIGluIHJlc0Zvck9iakhuZGwpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc0Zvck9iakhuZGwsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdFZhbHVlICYmICFyZXMpIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzaG91bGRIYW5kbGVBc09iamVjdChkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW21dIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc0Zvck9iakhuZGxbbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGNvcHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiBpc1N0cmluZyhqb2luQXJyYXlzKSAmJiBBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHJlcyA9IHJlcy5qb2luKGpvaW5BcnJheXMpO1xuICAgICAgaWYgKHJlcykgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleXMsIG9wdCwgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHVzZWREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSkge1xuICAgICAgICB1c2VkS2V5ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0ga2V5O1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5ID0gb3B0Lm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICAgIGtleVNlcGFyYXRvcjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZmsgJiYgZmsucmVzKSB0aGlzLmxvZ2dlci53YXJuKCdTZWVtcyB0aGUgbG9hZGVkIHRyYW5zbGF0aW9ucyB3ZXJlIGluIGZsYXQgSlNPTiBmb3JtYXQgaW5zdGVhZCBvZiBuZXN0ZWQuIEVpdGhlciBzZXQga2V5U2VwYXJhdG9yOiBmYWxzZSBvbiBpbml0IG9yIG1ha2Ugc3VyZSB5b3VyIHRyYW5zbGF0aW9ucyBhcmUgcHVibGlzaGVkIGluIG5lc3RlZCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxuZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tMbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nLCBvcHQubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgZmFsbGJhY2tMbmdzICYmIGZhbGxiYWNrTG5nc1swXSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFsbGJhY2tMbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsbmdzLnB1c2goZmFsbGJhY2tMbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gKGwsIGssIHNwZWNpZmljRGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEZvck1pc3NpbmcgPSBoYXNEZWZhdWx0VmFsdWUgJiYgc3BlY2lmaWNEZWZhdWx0VmFsdWUgIT09IHJlcyA/IHNwZWNpZmljRGVmYXVsdFZhbHVlIDogcmVzRm9yTWlzc2luZztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWlzc2luZ0tleUhhbmRsZXIobCwgbmFtZXNwYWNlLCBrLCBkZWZhdWx0Rm9yTWlzc2luZywgdXBkYXRlTWlzc2luZywgb3B0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYmFja2VuZENvbm5lY3Rvcj8uc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZyhsLCBuYW1lc3BhY2UsIGssIGRlZmF1bHRGb3JNaXNzaW5nLCB1cGRhdGVNaXNzaW5nLCBvcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdCk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXAgJiYgb3B0W2BkZWZhdWx0VmFsdWUke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2BdICYmIHN1ZmZpeGVzLmluZGV4T2YoYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ZXMucHVzaChgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWZmaXhlcy5mb3JFYWNoKHN1ZmZpeCA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZChbbGFuZ3VhZ2VdLCBrZXkgKyBzdWZmaXgsIG9wdFtgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0LCByZXNvbHZlZCwgbGFzdEtleSk7XG4gICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSB7XG4gICAgICAgIHJlcyA9IGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICB9XG4gICAgICBpZiAoKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQpICYmIHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkgPyBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCwgb3B0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgIHJlc29sdmVkLnJlcyA9IHJlcztcbiAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdCwgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5wYXJzZSkge1xuICAgICAgcmVzID0gdGhpcy5pMThuRm9ybWF0LnBhcnNlKHJlcywge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5vcHRcbiAgICAgIH0sIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCByZXNvbHZlZC51c2VkTlMsIHJlc29sdmVkLnVzZWRLZXksIHtcbiAgICAgICAgcmVzb2x2ZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW9wdC5za2lwSW50ZXJwb2xhdGlvbikge1xuICAgICAgaWYgKG9wdC5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0LFxuICAgICAgICAuLi57XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAuLi5vcHQuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBpc1N0cmluZyhyZXMpICYmIChvcHQ/LmludGVycG9sYXRpb24/LnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0LmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0LnJlcGxhY2UgJiYgIWlzU3RyaW5nKG9wdC5yZXBsYWNlKSA/IG9wdC5yZXBsYWNlIDogb3B0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShyZXMsIGRhdGEsIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCBvcHQpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHQubmVzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHQubG5nICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0LmxuZyA9IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZztcbiAgICAgIGlmIChvcHQubmVzdCAhPT0gZmFsc2UpIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLm5lc3QocmVzLCAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAobGFzdEtleT8uWzBdID09PSBhcmdzWzBdICYmICFvcHQuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEl0IHNlZW1zIHlvdSBhcmUgbmVzdGluZyByZWN1cnNpdmVseSBrZXk6ICR7YXJnc1swXX0gaW4ga2V5OiAke2tleVswXX1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdCk7XG4gICAgICBpZiAob3B0LmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLnJlc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gb3B0LnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSBpc1N0cmluZyhwb3N0UHJvY2VzcykgPyBbcG9zdFByb2Nlc3NdIDogcG9zdFByb2Nlc3M7XG4gICAgaWYgKHJlcyAhPSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcz8ubGVuZ3RoICYmIG9wdC5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0XG4gICAgICB9IDogb3B0LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMsIG9wdCA9IHt9KSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAoaXNTdHJpbmcoa2V5cykpIGtleXMgPSBba2V5c107XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuZXh0cmFjdEZyb21LZXkoaywgb3B0KTtcbiAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RlZC5rZXk7XG4gICAgICB1c2VkS2V5ID0ga2V5O1xuICAgICAgbGV0IG5hbWVzcGFjZXMgPSBleHRyYWN0ZWQubmFtZXNwYWNlcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tOUykgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMuY29uY2F0KHRoaXMub3B0aW9ucy5mYWxsYmFja05TKTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHQuY291bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNTdHJpbmcob3B0LmNvdW50KTtcbiAgICAgIGNvbnN0IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgIW9wdC5vcmRpbmFsICYmIG9wdC5jb3VudCA9PT0gMDtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0LmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiAoaXNTdHJpbmcob3B0LmNvbnRleHQpIHx8IHR5cGVvZiBvcHQuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdC5jb250ZXh0ICE9PSAnJztcbiAgICAgIGNvbnN0IGNvZGVzID0gb3B0LmxuZ3MgPyBvcHQubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlLCBvcHQuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzPy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMudXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdD8uYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdC5jb3VudCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdC5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvciB8fCAnXyd9JHtvcHQuY29udGV4dH1gO1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lm9yZGluYWwgJiYgcGx1cmFsU3VmZml4LmluZGV4T2Yob3JkaW5hbFByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgucmVwbGFjZShvcmRpbmFsUHJlZml4LCB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBvc3NpYmxlS2V5O1xuICAgICAgICAgIHdoaWxlIChwb3NzaWJsZUtleSA9IGZpbmFsS2V5cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSB7XG4gICAgICAgICAgICAgIGV4YWN0VXNlZEtleSA9IHBvc3NpYmxlS2V5O1xuICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIHBvc3NpYmxlS2V5LCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzOiBmb3VuZCxcbiAgICAgIHVzZWRLZXksXG4gICAgICBleGFjdFVzZWRLZXksXG4gICAgICB1c2VkTG5nLFxuICAgICAgdXNlZE5TXG4gICAgfTtcbiAgfVxuICBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfVxuICBnZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5nZXRSZXNvdXJjZSkgcmV0dXJuIHRoaXMuaTE4bkZvcm1hdC5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZVN0b3JlLmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICB9XG4gIGdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gWydkZWZhdWx0VmFsdWUnLCAnb3JkaW5hbCcsICdjb250ZXh0JywgJ3JlcGxhY2UnLCAnbG5nJywgJ2xuZ3MnLCAnZmFsbGJhY2tMbmcnLCAnbnMnLCAna2V5U2VwYXJhdG9yJywgJ25zU2VwYXJhdG9yJywgJ3JldHVybk9iamVjdHMnLCAncmV0dXJuRGV0YWlscycsICdqb2luQXJyYXlzJywgJ3Bvc3RQcm9jZXNzJywgJ2ludGVycG9sYXRpb24nXTtcbiAgICBjb25zdCB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgIWlzU3RyaW5nKG9wdGlvbnMucmVwbGFjZSk7XG4gICAgbGV0IGRhdGEgPSB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgIGlmICh1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgc3RhdGljIGhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ2RlZmF1bHRWYWx1ZSc7XG4gICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIHByZWZpeCA9PT0gb3B0aW9uLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAmJiB1bmRlZmluZWQgIT09IG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmNsYXNzIExhbmd1YWdlVXRpbCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3VwcG9ydGVkTG5ncyA9IHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzIHx8IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2xhbmd1YWdlVXRpbHMnKTtcbiAgfVxuICBnZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIGlmIChwLmxlbmd0aCA9PT0gMikgcmV0dXJuIG51bGw7XG4gICAgcC5wb3AoKTtcbiAgICBpZiAocFtwLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKHAuam9pbignLScpKTtcbiAgfVxuICBnZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgY29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUpO1xuICAgIGlmICghY29kZSB8fCBjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBjb2RlO1xuICAgIGNvbnN0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKHBbMF0pO1xuICB9XG4gIGZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvZGUpICYmIGNvZGUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGxldCBmb3JtYXR0ZWRDb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9ybWF0dGVkQ29kZSA9IEludGwuZ2V0Q2Fub25pY2FsTG9jYWxlcyhjb2RlKVswXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoZm9ybWF0dGVkQ29kZSAmJiB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIGZvcm1hdHRlZENvZGUgPSBmb3JtYXR0ZWRDb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0dGVkQ29kZSkgcmV0dXJuIGZvcm1hdHRlZENvZGU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZykge1xuICAgICAgICByZXR1cm4gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW5Db2RlIHx8IHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcgPyBjb2RlLnRvTG93ZXJDYXNlKCkgOiBjb2RlO1xuICB9XG4gIGlzU3VwcG9ydGVkQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkID09PSAnbGFuZ3VhZ2VPbmx5JyB8fCB0aGlzLm9wdGlvbnMubm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2RlID0gdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLnN1cHBvcnRlZExuZ3MgfHwgIXRoaXMuc3VwcG9ydGVkTG5ncy5sZW5ndGggfHwgdGhpcy5zdXBwb3J0ZWRMbmdzLmluZGV4T2YoY29kZSkgPiAtMTtcbiAgfVxuICBnZXRCZXN0TWF0Y2hGcm9tQ29kZXMoY29kZXMpIHtcbiAgICBpZiAoIWNvZGVzKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQ7XG4gICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgICAgY29uc3QgY2xlYW5lZExuZyA9IHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCB0aGlzLmlzU3VwcG9ydGVkQ29kZShjbGVhbmVkTG5nKSkgZm91bmQgPSBjbGVhbmVkTG5nO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQgJiYgdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MpIHtcbiAgICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBsbmdTY09ubHkgPSB0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGxuZ1NjT25seSkpIHJldHVybiBmb3VuZCA9IGxuZ1NjT25seTtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPiAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCAmJiBzdXBwb3J0ZWRMbmcuc3Vic3RyaW5nKDAsIHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykpID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCAmJiBsbmdPbmx5Lmxlbmd0aCA+IDEpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZm91bmQpIGZvdW5kID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZylbMF07XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tzLCBjb2RlKSB7XG4gICAgaWYgKCFmYWxsYmFja3MpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgZmFsbGJhY2tzID0gZmFsbGJhY2tzKGNvZGUpO1xuICAgIGlmIChpc1N0cmluZyhmYWxsYmFja3MpKSBmYWxsYmFja3MgPSBbZmFsbGJhY2tzXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSByZXR1cm4gZmFsbGJhY2tzO1xuICAgIGlmICghY29kZSkgcmV0dXJuIGZhbGxiYWNrcy5kZWZhdWx0IHx8IFtdO1xuICAgIGxldCBmb3VuZCA9IGZhbGxiYWNrc1tjb2RlXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGZvdW5kIHx8IFtdO1xuICB9XG4gIHRvUmVzb2x2ZUhpZXJhcmNoeShjb2RlLCBmYWxsYmFja0NvZGUpIHtcbiAgICBjb25zdCBmYWxsYmFja0NvZGVzID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKChmYWxsYmFja0NvZGUgPT09IGZhbHNlID8gW10gOiBmYWxsYmFja0NvZGUpIHx8IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyB8fCBbXSwgY29kZSk7XG4gICAgY29uc3QgY29kZXMgPSBbXTtcbiAgICBjb25zdCBhZGRDb2RlID0gYyA9PiB7XG4gICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShjKSkge1xuICAgICAgICBjb2Rlcy5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcmVqZWN0aW5nIGxhbmd1YWdlIGNvZGUgbm90IGZvdW5kIGluIHN1cHBvcnRlZExuZ3M6ICR7Y31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc1N0cmluZyhjb2RlKSAmJiAoY29kZS5pbmRleE9mKCctJykgPiAtMSB8fCBjb2RlLmluZGV4T2YoJ18nKSA+IC0xKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JykgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknICYmIHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvZGUpKSB7XG4gICAgICBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICB9XG4gICAgZmFsbGJhY2tDb2Rlcy5mb3JFYWNoKGZjID0+IHtcbiAgICAgIGlmIChjb2Rlcy5pbmRleE9mKGZjKSA8IDApIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoZmMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZXM7XG4gIH1cbn1cblxuY29uc3Qgc3VmZml4ZXNPcmRlciA9IHtcbiAgemVybzogMCxcbiAgb25lOiAxLFxuICB0d286IDIsXG4gIGZldzogMyxcbiAgbWFueTogNCxcbiAgb3RoZXI6IDVcbn07XG5jb25zdCBkdW1teVJ1bGUgPSB7XG4gIHNlbGVjdDogY291bnQgPT4gY291bnQgPT09IDEgPyAnb25lJyA6ICdvdGhlcicsXG4gIHJlc29sdmVkT3B0aW9uczogKCkgPT4gKHtcbiAgICBwbHVyYWxDYXRlZ29yaWVzOiBbJ29uZScsICdvdGhlciddXG4gIH0pXG59O1xuY2xhc3MgUGx1cmFsUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZVV0aWxzLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBsYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgncGx1cmFsUmVzb2x2ZXInKTtcbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGUgPSB7fTtcbiAgfVxuICBhZGRSdWxlKGxuZywgb2JqKSB7XG4gICAgdGhpcy5ydWxlc1tsbmddID0gb2JqO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlID0ge307XG4gIH1cbiAgZ2V0UnVsZShjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjbGVhbmVkQ29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUgPT09ICdkZXYnID8gJ2VuJyA6IGNvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLm9yZGluYWwgPyAnb3JkaW5hbCcgOiAnY2FyZGluYWwnO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY2xlYW5lZENvZGUsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgaWYgKGNhY2hlS2V5IGluIHRoaXMucGx1cmFsUnVsZXNDYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGxldCBydWxlO1xuICAgIHRyeSB7XG4gICAgICBydWxlID0gbmV3IEludGwuUGx1cmFsUnVsZXMoY2xlYW5lZENvZGUsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIUludGwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ05vIEludGwgc3VwcG9ydCwgcGxlYXNlIHVzZSBhbiBJbnRsIHBvbHlmaWxsIScpO1xuICAgICAgICByZXR1cm4gZHVtbXlSdWxlO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2RlLm1hdGNoKC8tfF8vKSkgcmV0dXJuIGR1bW15UnVsZTtcbiAgICAgIGNvbnN0IGxuZ1BhcnQgPSB0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICBydWxlID0gdGhpcy5nZXRSdWxlKGxuZ1BhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGVbY2FjaGVLZXldID0gcnVsZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJ1bGUgPSB0aGlzLmdldFJ1bGUoJ2RldicsIG9wdGlvbnMpO1xuICAgIHJldHVybiBydWxlPy5yZXNvbHZlZE9wdGlvbnMoKS5wbHVyYWxDYXRlZ29yaWVzLmxlbmd0aCA+IDE7XG4gIH1cbiAgZ2V0UGx1cmFsRm9ybXNPZktleShjb2RlLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeGVzKGNvZGUsIG9wdGlvbnMpLm1hcChzdWZmaXggPT4gYCR7a2V5fSR7c3VmZml4fWApO1xuICB9XG4gIGdldFN1ZmZpeGVzKGNvZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMuZ2V0UnVsZSgnZGV2Jywgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5zb3J0KChwbHVyYWxDYXRlZ29yeTEsIHBsdXJhbENhdGVnb3J5MikgPT4gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTFdIC0gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTJdKS5tYXAocGx1cmFsQ2F0ZWdvcnkgPT4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cGx1cmFsQ2F0ZWdvcnl9YCk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cnVsZS5zZWxlY3QoY291bnQpfWA7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYG5vIHBsdXJhbCBydWxlIGZvdW5kIGZvcjogJHtjb2RlfWApO1xuICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeCgnZGV2JywgY291bnQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IGRlZXBGaW5kV2l0aERlZmF1bHRzID0gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXksIGtleVNlcGFyYXRvciA9ICcuJywgaWdub3JlSlNPTlN0cnVjdHVyZSA9IHRydWUpID0+IHtcbiAgbGV0IHBhdGggPSBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpO1xuICBpZiAoIXBhdGggJiYgaWdub3JlSlNPTlN0cnVjdHVyZSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgcGF0aCA9IGRlZXBGaW5kKGRhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gZGVlcEZpbmQoZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5jb25zdCByZWdleFNhZmUgPSB2YWwgPT4gdmFsLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuY2xhc3MgSW50ZXJwb2xhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnaW50ZXJwb2xhdG9yJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnM/LmludGVycG9sYXRpb24/LmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5pbnRlcnBvbGF0aW9uKSBvcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICBlc2NhcGVWYWx1ZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZXNjYXBlOiBlc2NhcGUkMSxcbiAgICAgIGVzY2FwZVZhbHVlLFxuICAgICAgdXNlUmF3VmFsdWVUb0VzY2FwZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHByZWZpeEVzY2FwZWQsXG4gICAgICBzdWZmaXgsXG4gICAgICBzdWZmaXhFc2NhcGVkLFxuICAgICAgZm9ybWF0U2VwYXJhdG9yLFxuICAgICAgdW5lc2NhcGVTdWZmaXgsXG4gICAgICB1bmVzY2FwZVByZWZpeCxcbiAgICAgIG5lc3RpbmdQcmVmaXgsXG4gICAgICBuZXN0aW5nUHJlZml4RXNjYXBlZCxcbiAgICAgIG5lc3RpbmdTdWZmaXgsXG4gICAgICBuZXN0aW5nU3VmZml4RXNjYXBlZCxcbiAgICAgIG5lc3RpbmdPcHRpb25zU2VwYXJhdG9yLFxuICAgICAgbWF4UmVwbGFjZXMsXG4gICAgICBhbHdheXNGb3JtYXRcbiAgICB9ID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuZXNjYXBlID0gZXNjYXBlJDEgIT09IHVuZGVmaW5lZCA/IGVzY2FwZSQxIDogZXNjYXBlO1xuICAgIHRoaXMuZXNjYXBlVmFsdWUgPSBlc2NhcGVWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZXNjYXBlVmFsdWUgOiB0cnVlO1xuICAgIHRoaXMudXNlUmF3VmFsdWVUb0VzY2FwZSA9IHVzZVJhd1ZhbHVlVG9Fc2NhcGUgIT09IHVuZGVmaW5lZCA/IHVzZVJhd1ZhbHVlVG9Fc2NhcGUgOiBmYWxzZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeCA/IHJlZ2V4RXNjYXBlKHByZWZpeCkgOiBwcmVmaXhFc2NhcGVkIHx8ICd7eyc7XG4gICAgdGhpcy5zdWZmaXggPSBzdWZmaXggPyByZWdleEVzY2FwZShzdWZmaXgpIDogc3VmZml4RXNjYXBlZCB8fCAnfX0nO1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gZm9ybWF0U2VwYXJhdG9yIHx8ICcsJztcbiAgICB0aGlzLnVuZXNjYXBlUHJlZml4ID0gdW5lc2NhcGVTdWZmaXggPyAnJyA6IHVuZXNjYXBlUHJlZml4IHx8ICctJztcbiAgICB0aGlzLnVuZXNjYXBlU3VmZml4ID0gdGhpcy51bmVzY2FwZVByZWZpeCA/ICcnIDogdW5lc2NhcGVTdWZmaXggfHwgJyc7XG4gICAgdGhpcy5uZXN0aW5nUHJlZml4ID0gbmVzdGluZ1ByZWZpeCA/IHJlZ2V4RXNjYXBlKG5lc3RpbmdQcmVmaXgpIDogbmVzdGluZ1ByZWZpeEVzY2FwZWQgfHwgcmVnZXhFc2NhcGUoJyR0KCcpO1xuICAgIHRoaXMubmVzdGluZ1N1ZmZpeCA9IG5lc3RpbmdTdWZmaXggPyByZWdleEVzY2FwZShuZXN0aW5nU3VmZml4KSA6IG5lc3RpbmdTdWZmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCcpJyk7XG4gICAgdGhpcy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvciA9IG5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIHx8ICcsJztcbiAgICB0aGlzLm1heFJlcGxhY2VzID0gbWF4UmVwbGFjZXMgfHwgMTAwMDtcbiAgICB0aGlzLmFsd2F5c0Zvcm1hdCA9IGFsd2F5c0Zvcm1hdCAhPT0gdW5kZWZpbmVkID8gYWx3YXlzRm9ybWF0IDogZmFsc2U7XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHJlc2V0UmVnRXhwKCkge1xuICAgIGNvbnN0IGdldE9yUmVzZXRSZWdFeHAgPSAoZXhpc3RpbmdSZWdFeHAsIHBhdHRlcm4pID0+IHtcbiAgICAgIGlmIChleGlzdGluZ1JlZ0V4cD8uc291cmNlID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIGV4aXN0aW5nUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JlZ0V4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG4gICAgfTtcbiAgICB0aGlzLnJlZ2V4cCA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHAsIGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLnJlZ2V4cFVuZXNjYXBlLCBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLm5lc3RpbmdSZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMubmVzdGluZ1JlZ2V4cCwgYCR7dGhpcy5uZXN0aW5nUHJlZml4fSgoPzpbXigpXCInXSt8XCJbXlwiXSpcInwnW14nXSonfFxcXFwoKD86W14oKV18XCJbXlwiXSpcInwnW14nXSonKSpcXFxcKSkqPykke3RoaXMubmVzdGluZ1N1ZmZpeH1gKTtcbiAgfVxuICBpbnRlcnBvbGF0ZShzdHIsIGRhdGEsIGxuZywgb3B0aW9ucykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IHJlcGxhY2VzO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMgfHwge307XG4gICAgY29uc3QgaGFuZGxlRm9ybWF0ID0ga2V5ID0+IHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5LCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsd2F5c0Zvcm1hdCA/IHRoaXMuZm9ybWF0KHBhdGgsIHVuZGVmaW5lZCwgbG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IGtleVxuICAgICAgICB9KSA6IHBhdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0ga2V5LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIGNvbnN0IGsgPSBwLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgY29uc3QgZiA9IHAuam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrLCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSksIGYsIGxuZywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgICBjb25zdCBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPSBvcHRpb25zPy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgfHwgdGhpcy5vcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjtcbiAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBvcHRpb25zPy5pbnRlcnBvbGF0aW9uPy5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gaXNTdHJpbmcodGVtcCkgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjbG9uZWRPcHRpb25zO1xuICAgIGNvbnN0IGhhbmRsZUhhc09wdGlvbnMgPSAoa2V5LCBpbmhlcml0ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzZXAgPSB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yO1xuICAgICAgaWYgKGtleS5pbmRleE9mKHNlcCkgPCAwKSByZXR1cm4ga2V5O1xuICAgICAgY29uc3QgYyA9IGtleS5zcGxpdChuZXcgUmVnRXhwKGAke3NlcH1bIF0qe2ApKTtcbiAgICAgIGxldCBvcHRpb25zU3RyaW5nID0gYHske2NbMV19YDtcbiAgICAgIGtleSA9IGNbMF07XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTaW5nbGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC8nL2cpO1xuICAgICAgY29uc3QgbWF0Y2hlZERvdWJsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goL1wiL2cpO1xuICAgICAgaWYgKChtYXRjaGVkU2luZ2xlUXVvdGVzPy5sZW5ndGggPz8gMCkgJSAyID09PSAwICYmICFtYXRjaGVkRG91YmxlUXVvdGVzIHx8IG1hdGNoZWREb3VibGVRdW90ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBvcHRpb25zU3RyaW5nID0gb3B0aW9uc1N0cmluZy5yZXBsYWNlKC8nL2csICdcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvbmVkT3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9uc1N0cmluZyk7XG4gICAgICAgIGlmIChpbmhlcml0ZWRPcHRpb25zKSBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmluaGVyaXRlZE9wdGlvbnMsXG4gICAgICAgICAgLi4uY2xvbmVkT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBmYWlsZWQgcGFyc2luZyBvcHRpb25zIHN0cmluZyBpbiBuZXN0aW5nIGZvciBrZXkgJHtrZXl9YCwgZSk7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHtzZXB9JHtvcHRpb25zU3RyaW5nfWA7XG4gICAgICB9XG4gICAgICBpZiAoY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUgJiYgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUuaW5kZXhPZih0aGlzLnByZWZpeCkgPiAtMSkgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcoY2xvbmVkT3B0aW9ucy5yZXBsYWNlKSA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgY29uc3Qga2V5RW5kSW5kZXggPSAvey4qfS8udGVzdChtYXRjaFsxXSkgPyBtYXRjaFsxXS5sYXN0SW5kZXhPZignfScpICsgMSA6IG1hdGNoWzFdLmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgaWYgKGtleUVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBmb3JtYXR0ZXJzID0gbWF0Y2hbMV0uc2xpY2Uoa2V5RW5kSW5kZXgpLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnNsaWNlKDAsIGtleUVuZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSwgY2xvbmVkT3B0aW9ucyksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlICYmIG1hdGNoWzBdID09PSBzdHIgJiYgIWlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byByZXNvbHZlICR7bWF0Y2hbMV19IGZvciBuZXN0aW5nICR7c3RyfWApO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVycy5yZWR1Y2UoKHYsIGYpID0+IHRoaXMuZm9ybWF0KHYsIGYsIG9wdGlvbnMubG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBtYXRjaFsxXS50cmltKClcbiAgICAgICAgfSksIHZhbHVlLnRyaW0oKSk7XG4gICAgICB9XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5jb25zdCBwYXJzZUZvcm1hdFN0ciA9IGZvcm1hdFN0ciA9PiB7XG4gIGxldCBmb3JtYXROYW1lID0gZm9ybWF0U3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBmb3JtYXRPcHRpb25zID0ge307XG4gIGlmIChmb3JtYXRTdHIuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICBjb25zdCBwID0gZm9ybWF0U3RyLnNwbGl0KCcoJyk7XG4gICAgZm9ybWF0TmFtZSA9IHBbMF0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3Qgb3B0U3RyID0gcFsxXS5zdWJzdHJpbmcoMCwgcFsxXS5sZW5ndGggLSAxKTtcbiAgICBpZiAoZm9ybWF0TmFtZSA9PT0gJ2N1cnJlbmN5JyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLmN1cnJlbmN5KSBmb3JtYXRPcHRpb25zLmN1cnJlbmN5ID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE5hbWUgPT09ICdyZWxhdGl2ZXRpbWUnICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMucmFuZ2UpIGZvcm1hdE9wdGlvbnMucmFuZ2UgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRzID0gb3B0U3RyLnNwbGl0KCc7Jyk7XG4gICAgICBvcHRzLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgY29uc3QgdmFsID0gcmVzdC5qb2luKCc6JykudHJpbSgpLnJlcGxhY2UoL14nK3wnKyQvZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRLZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICAgIGlmICghZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSkgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ3RydWUnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59O1xuY29uc3QgY3JlYXRlQ2FjaGVkRm9ybWF0dGVyID0gZm4gPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuICByZXR1cm4gKHYsIGwsIG8pID0+IHtcbiAgICBsZXQgb3B0Rm9yQ2FjaGUgPSBvO1xuICAgIGlmIChvICYmIG8uaW50ZXJwb2xhdGlvbmtleSAmJiBvLmZvcm1hdFBhcmFtcyAmJiBvLmZvcm1hdFBhcmFtc1tvLmludGVycG9sYXRpb25rZXldICYmIG9bby5pbnRlcnBvbGF0aW9ua2V5XSkge1xuICAgICAgb3B0Rm9yQ2FjaGUgPSB7XG4gICAgICAgIC4uLm9wdEZvckNhY2hlLFxuICAgICAgICBbby5pbnRlcnBvbGF0aW9ua2V5XTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBsICsgSlNPTi5zdHJpbmdpZnkob3B0Rm9yQ2FjaGUpO1xuICAgIGxldCBmcm0gPSBjYWNoZVtrZXldO1xuICAgIGlmICghZnJtKSB7XG4gICAgICBmcm0gPSBmbihnZXRDbGVhbmVkQ29kZShsKSwgbyk7XG4gICAgICBjYWNoZVtrZXldID0gZnJtO1xuICAgIH1cbiAgICByZXR1cm4gZnJtKHYpO1xuICB9O1xufTtcbmNvbnN0IGNyZWF0ZU5vbkNhY2hlZEZvcm1hdHRlciA9IGZuID0+ICh2LCBsLCBvKSA9PiBmbihnZXRDbGVhbmVkQ29kZShsKSwgbykodik7XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KHNlcnZpY2VzLCBvcHRpb25zID0ge1xuICAgIGludGVycG9sYXRpb246IHt9XG4gIH0pIHtcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIGNvbnN0IGNmID0gb3B0aW9ucy5jYWNoZUluQnVpbHRGb3JtYXRzID8gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIDogY3JlYXRlTm9uQ2FjaGVkRm9ybWF0dGVyO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBjdXJyZW5jeTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwsIG9wdC5yYW5nZSB8fCAnZGF5Jyk7XG4gICAgICB9KSxcbiAgICAgIGxpc3Q6IGNmKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgYWRkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gZmM7XG4gIH1cbiAgYWRkQ2FjaGVkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZjKTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZvcm1hdCwgbG5nLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBpZiAoZm9ybWF0cy5sZW5ndGggPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKCcpID4gMSAmJiBmb3JtYXRzWzBdLmluZGV4T2YoJyknKSA8IDAgJiYgZm9ybWF0cy5maW5kKGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcm1hdHMuZmluZEluZGV4KGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSk7XG4gICAgICBmb3JtYXRzWzBdID0gW2Zvcm1hdHNbMF0sIC4uLmZvcm1hdHMuc3BsaWNlKDEsIGxhc3RJbmRleCldLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucz8uZm9ybWF0UGFyYW1zPy5bb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBsID0gdmFsT3B0aW9ucy5sb2NhbGUgfHwgdmFsT3B0aW9ucy5sbmcgfHwgb3B0aW9ucy5sb2NhbGUgfHwgb3B0aW9ucy5sbmcgfHwgbG5nO1xuICAgICAgICAgIGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXShtZW0sIGwsIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4udmFsT3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGB0aGVyZSB3YXMgbm8gZm9ybWF0IGZ1bmN0aW9uIGZvciAke2Zvcm1hdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtO1xuICAgIH0sIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmNvbnN0IHJlbW92ZVBlbmRpbmcgPSAocSwgbmFtZSkgPT4ge1xuICBpZiAocS5wZW5kaW5nW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcS5wZW5kaW5nW25hbWVdO1xuICAgIHEucGVuZGluZ0NvdW50LS07XG4gIH1cbn07XG5jbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihiYWNrZW5kLCBzdG9yZSwgc2VydmljZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IHNlcnZpY2VzLmxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdiYWNrZW5kQ29ubmVjdG9yJyk7XG4gICAgdGhpcy53YWl0aW5nUmVhZHMgPSBbXTtcbiAgICB0aGlzLm1heFBhcmFsbGVsUmVhZHMgPSBvcHRpb25zLm1heFBhcmFsbGVsUmVhZHMgfHwgMTA7XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMgPSAwO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA+PSAwID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogNTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ID49IDEgPyBvcHRpb25zLnJldHJ5VGltZW91dCA6IDM1MDtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuYmFja2VuZD8uaW5pdD8uKHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICB9XG4gIHF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdG9Mb2FkID0ge307XG4gICAgY29uc3QgcGVuZGluZyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZExhbmd1YWdlcyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZE5hbWVzcGFjZXMgPSB7fTtcbiAgICBsYW5ndWFnZXMuZm9yRWFjaChsbmcgPT4ge1xuICAgICAgbGV0IGhhc0FsbE5hbWVzcGFjZXMgPSB0cnVlO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke2xuZ318JHtuc31gO1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsb2FkICYmIHRoaXMuc3RvcmUuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdIDwgMCkgOyBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDE7XG4gICAgICAgICAgaGFzQWxsTmFtZXNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWRbbmFtZV0gPT09IHVuZGVmaW5lZCkgdG9Mb2FkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkTmFtZXNwYWNlc1tuc10gPT09IHVuZGVmaW5lZCkgdG9Mb2FkTmFtZXNwYWNlc1tuc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzQWxsTmFtZXNwYWNlcykgdG9Mb2FkTGFuZ3VhZ2VzW2xuZ10gPSB0cnVlO1xuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh0b0xvYWQpLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIHBlbmRpbmcsXG4gICAgICAgIHBlbmRpbmdDb3VudDogT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoLFxuICAgICAgICBsb2FkZWQ6IHt9LFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b0xvYWQ6IE9iamVjdC5rZXlzKHRvTG9hZCksXG4gICAgICBwZW5kaW5nOiBPYmplY3Qua2V5cyhwZW5kaW5nKSxcbiAgICAgIHRvTG9hZExhbmd1YWdlczogT2JqZWN0LmtleXModG9Mb2FkTGFuZ3VhZ2VzKSxcbiAgICAgIHRvTG9hZE5hbWVzcGFjZXM6IE9iamVjdC5rZXlzKHRvTG9hZE5hbWVzcGFjZXMpXG4gICAgfTtcbiAgfVxuICBsb2FkZWQobmFtZSwgZXJyLCBkYXRhKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2ZhaWxlZExvYWRpbmcnLCBsbmcsIG5zLCBlcnIpO1xuICAgIGlmICghZXJyICYmIGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgc2tpcENvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlW25hbWVdID0gZXJyID8gLTEgOiAyO1xuICAgIGlmIChlcnIgJiYgZGF0YSkgdGhpcy5zdGF0ZVtuYW1lXSA9IDA7XG4gICAgY29uc3QgbG9hZGVkID0ge307XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHEgPT4ge1xuICAgICAgcHVzaFBhdGgocS5sb2FkZWQsIFtsbmddLCBucyk7XG4gICAgICByZW1vdmVQZW5kaW5nKHEsIG5hbWUpO1xuICAgICAgaWYgKGVycikgcS5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgaWYgKHEucGVuZGluZ0NvdW50ID09PSAwICYmICFxLmRvbmUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocS5sb2FkZWQpLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWRbbF0pIGxvYWRlZFtsXSA9IHt9O1xuICAgICAgICAgIGNvbnN0IGxvYWRlZEtleXMgPSBxLmxvYWRlZFtsXTtcbiAgICAgICAgICBpZiAobG9hZGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvYWRlZEtleXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRlZFtsXVtuXSA9PT0gdW5kZWZpbmVkKSBsb2FkZWRbbF1bbl0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcS5kb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKHEuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHEuY2FsbGJhY2socS5lcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgbG9hZGVkKTtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIocSA9PiAhcS5kb25lKTtcbiAgfVxuICByZWFkKGxuZywgbnMsIGZjTmFtZSwgdHJpZWQgPSAwLCB3YWl0ID0gdGhpcy5yZXRyeVRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFsbmcubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgIGlmICh0aGlzLnJlYWRpbmdDYWxscyA+PSB0aGlzLm1heFBhcmFsbGVsUmVhZHMpIHtcbiAgICAgIHRoaXMud2FpdGluZ1JlYWRzLnB1c2goe1xuICAgICAgICBsbmcsXG4gICAgICAgIG5zLFxuICAgICAgICBmY05hbWUsXG4gICAgICAgIHRyaWVkLFxuICAgICAgICB3YWl0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZGluZ0NhbGxzKys7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICB0aGlzLnJlYWRpbmdDYWxscy0tO1xuICAgICAgaWYgKHRoaXMud2FpdGluZ1JlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMud2FpdGluZ1JlYWRzLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucmVhZChuZXh0LmxuZywgbmV4dC5ucywgbmV4dC5mY05hbWUsIG5leHQudHJpZWQsIG5leHQud2FpdCwgbmV4dC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyICYmIGRhdGEgJiYgdHJpZWQgPCB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFkLmNhbGwodGhpcywgbG5nLCBucywgZmNOYW1lLCB0cmllZCArIDEsIHdhaXQgKiAyLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgIH07XG4gICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmRbZmNOYW1lXS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgaWYgKGZjLmxlbmd0aCA9PT0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IGZjKGxuZywgbnMpO1xuICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgci50aGVuKGRhdGEgPT4gcmVzb2x2ZXIobnVsbCwgZGF0YSkpLmNhdGNoKHJlc29sdmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcihudWxsLCByKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmVyKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmYyhsbmcsIG5zLCByZXNvbHZlcik7XG4gIH1cbiAgcHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGxhbmd1YWdlcykpIGxhbmd1YWdlcyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAoaXNTdHJpbmcobmFtZXNwYWNlcykpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgY29uc3QgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Mb2FkLnRvTG9hZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5sb2FkT25lKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7fSwgY2FsbGJhY2spO1xuICB9XG4gIHJlbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHtcbiAgICAgIHJlbG9hZDogdHJ1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBsb2FkT25lKG5hbWUsIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICB0aGlzLnJlYWQobG5nLCBucywgJ3JlYWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgdGhpcy5sb2dnZXIud2FybihgJHtwcmVmaXh9bG9hZGluZyBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfSBmYWlsZWRgLCBlcnIpO1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YSkgdGhpcy5sb2dnZXIubG9nKGAke3ByZWZpeH1sb2FkZWQgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ31gLCBkYXRhKTtcbiAgICAgIHRoaXMubG9hZGVkKG5hbWUsIGVyciwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgc2F2ZU1pc3NpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgaXNVcGRhdGUsIG9wdGlvbnMgPSB7fSwgY2xiID0gKCkgPT4ge30pIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZD8uY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoKSA9PiAoe1xuICBkZWJ1ZzogZmFsc2UsXG4gIGluaXRBc3luYzogdHJ1ZSxcbiAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgZGVmYXVsdE5TOiBbJ3RyYW5zbGF0aW9uJ10sXG4gIGZhbGxiYWNrTG5nOiBbJ2RldiddLFxuICBmYWxsYmFja05TOiBmYWxzZSxcbiAgc3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIG5vbkV4cGxpY2l0U3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIGxvYWQ6ICdhbGwnLFxuICBwcmVsb2FkOiBmYWxzZSxcbiAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRydWUsXG4gIGtleVNlcGFyYXRvcjogJy4nLFxuICBuc1NlcGFyYXRvcjogJzonLFxuICBwbHVyYWxTZXBhcmF0b3I6ICdfJyxcbiAgY29udGV4dFNlcGFyYXRvcjogJ18nLFxuICBwYXJ0aWFsQnVuZGxlZExhbmd1YWdlczogZmFsc2UsXG4gIHNhdmVNaXNzaW5nOiBmYWxzZSxcbiAgdXBkYXRlTWlzc2luZzogZmFsc2UsXG4gIHNhdmVNaXNzaW5nVG86ICdmYWxsYmFjaycsXG4gIHNhdmVNaXNzaW5nUGx1cmFsczogdHJ1ZSxcbiAgbWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI6IGZhbHNlLFxuICBwb3N0UHJvY2VzczogZmFsc2UsXG4gIHBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkOiBmYWxzZSxcbiAgcmV0dXJuTnVsbDogZmFsc2UsXG4gIHJldHVybkVtcHR5U3RyaW5nOiB0cnVlLFxuICByZXR1cm5PYmplY3RzOiBmYWxzZSxcbiAgam9pbkFycmF5czogZmFsc2UsXG4gIHJldHVybmVkT2JqZWN0SGFuZGxlcjogZmFsc2UsXG4gIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXk6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZTogZmFsc2UsXG4gIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBhcmdzID0+IHtcbiAgICBsZXQgcmV0ID0ge307XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JykgcmV0ID0gYXJnc1sxXTtcbiAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHJldC5kZWZhdWx0VmFsdWUgPSBhcmdzWzFdO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzJdKSkgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYXJnc1szXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzNdIHx8IGFyZ3NbMl07XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHJldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGludGVycG9sYXRpb246IHtcbiAgICBlc2NhcGVWYWx1ZTogdHJ1ZSxcbiAgICBmb3JtYXQ6IHZhbHVlID0+IHZhbHVlLFxuICAgIHByZWZpeDogJ3t7JyxcbiAgICBzdWZmaXg6ICd9fScsXG4gICAgZm9ybWF0U2VwYXJhdG9yOiAnLCcsXG4gICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICBuZXN0aW5nUHJlZml4OiAnJHQoJyxcbiAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICBtYXhSZXBsYWNlczogMTAwMCxcbiAgICBza2lwT25WYXJpYWJsZXM6IHRydWVcbiAgfSxcbiAgY2FjaGVJbkJ1aWx0Rm9ybWF0czogdHJ1ZVxufSk7XG5jb25zdCB0cmFuc2Zvcm1PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmIChpc1N0cmluZyhvcHRpb25zLm5zKSkgb3B0aW9ucy5ucyA9IFtvcHRpb25zLm5zXTtcbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMuZmFsbGJhY2tMbmcpKSBvcHRpb25zLmZhbGxiYWNrTG5nID0gW29wdGlvbnMuZmFsbGJhY2tMbmddO1xuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5mYWxsYmFja05TKSkgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3M/LmluZGV4T2Y/LignY2ltb2RlJykgPCAwKSB7XG4gICAgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzID0gb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmNvbmNhdChbJ2NpbW9kZSddKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5pdEltbWVkaWF0ZSA9PT0gJ2Jvb2xlYW4nKSBvcHRpb25zLmluaXRBc3luYyA9IG9wdGlvbnMuaW5pdEltbWVkaWF0ZTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBiaW5kTWVtYmVyRnVuY3Rpb25zID0gaW5zdCA9PiB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn07XG5jbGFzcyBJMThuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgIHRoaXMubW9kdWxlcyA9IHtcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgYmluZE1lbWJlckZ1bmN0aW9ucyh0aGlzKTtcbiAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMuaXNJbml0aWFsaXplZCAmJiAhb3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0QXN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdE5TID09IG51bGwgJiYgb3B0aW9ucy5ucykge1xuICAgICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubnMpKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ucy5pbmRleE9mKCd0cmFuc2xhdGlvbicpIDwgMCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZk9wdHMgPSBnZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZPcHRzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICAuLi5kZWZPcHRzLmludGVycG9sYXRpb24sXG4gICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZUNsYXNzT25EZW1hbmQgPSBDbGFzc09yT2JqZWN0ID0+IHtcbiAgICAgIGlmICghQ2xhc3NPck9iamVjdCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIENsYXNzT3JPYmplY3QgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgQ2xhc3NPck9iamVjdCgpO1xuICAgICAgcmV0dXJuIENsYXNzT3JPYmplY3Q7XG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxvZ2dlcikge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubG9nZ2VyKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlcjtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IHRoaXMubW9kdWxlcy5mb3JtYXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBsdSA9IG5ldyBMYW5ndWFnZVV0aWwodGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLm9wdGlvbnMucmVzb3VyY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2VydmljZXM7XG4gICAgICBzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgICBzLnJlc291cmNlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgcy5sYW5ndWFnZVV0aWxzID0gbHU7XG4gICAgICBzLnBsdXJhbFJlc29sdmVyID0gbmV3IFBsdXJhbFJlc29sdmVyKGx1LCB7XG4gICAgICAgIHByZXBlbmQ6IHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IsXG4gICAgICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgIT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgICBpZiAodXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZXByZWNhdGUoYGluaXQ6IHlvdSBhcmUgc3RpbGwgdXNpbmcgdGhlIGxlZ2FjeSBmb3JtYXQgZnVuY3Rpb24sIHBsZWFzZSB1c2UgdGhlIG5ldyBhcHByb2FjaDogaHR0cHM6Ly93d3cuaTE4bmV4dC5jb20vdHJhbnNsYXRpb24tZnVuY3Rpb24vZm9ybWF0dGluZ2ApO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdHRlciAmJiAoIXRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQpKSB7XG4gICAgICAgIHMuZm9ybWF0dGVyID0gY3JlYXRlQ2xhc3NPbkRlbWFuZChmb3JtYXR0ZXIpO1xuICAgICAgICBpZiAocy5mb3JtYXR0ZXIuaW5pdCkgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpIHtcbiAgICAgICAgcy5sYW5ndWFnZURldGVjdG9yID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcik7XG4gICAgICAgIGlmIChzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdCkgcy5sYW5ndWFnZURldGVjdG9yLmluaXQocywgdGhpcy5vcHRpb25zLmRldGVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCkge1xuICAgICAgICBzLmkxOG5Gb3JtYXQgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KTtcbiAgICAgICAgaWYgKHMuaTE4bkZvcm1hdC5pbml0KSBzLmkxOG5Gb3JtYXQuaW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHRoaXMuc2VydmljZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnRyYW5zbGF0b3Iub24oJyonLCAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLmZvckVhY2gobSA9PiB7XG4gICAgICAgIGlmIChtLmluaXQpIG0uaW5pdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdDtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICBjb25zdCBjb2RlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBpZiAoY29kZXMubGVuZ3RoID4gMCAmJiBjb2Rlc1swXSAhPT0gJ2RldicpIHRoaXMub3B0aW9ucy5sbmcgPSBjb2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMub3B0aW9ucy5sbmcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IG5vIGxhbmd1YWdlRGV0ZWN0b3IgaXMgdXNlZCBhbmQgbm8gbG5nIGlzIGRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVBcGkgPSBbJ2dldFJlc291cmNlJywgJ2hhc1Jlc291cmNlQnVuZGxlJywgJ2dldFJlc291cmNlQnVuZGxlJywgJ2dldERhdGFCeUxhbmd1YWdlJ107XG4gICAgc3RvcmVBcGkuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMuc3RvcmVbZmNOYW1lXSguLi5hcmdzKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdG9yZUFwaUNoYWluZWQgPSBbJ2FkZFJlc291cmNlJywgJ2FkZFJlc291cmNlcycsICdhZGRSZXNvdXJjZUJ1bmRsZScsICdyZW1vdmVSZXNvdXJjZUJ1bmRsZSddO1xuICAgIHN0b3JlQXBpQ2hhaW5lZC5mb3JFYWNoKGZjTmFtZSA9PiB7XG4gICAgICB0aGlzW2ZjTmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICB0aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbmlzaCA9IChlcnIsIHQpID0+IHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemVkU3RvcmVPbmNlKSB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBpMThuZXh0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2FsbCBpbml0IGp1c3Qgb25jZSEnKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkgdGhpcy5sb2dnZXIubG9nKCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHQpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHQpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZmluaXNoKG51bGwsIHRoaXMudC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UodGhpcy5vcHRpb25zLmxuZywgZmluaXNoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8ICF0aGlzLm9wdGlvbnMuaW5pdEFzeW5jKSB7XG4gICAgICBsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkUmVzb3VyY2VzKGxhbmd1YWdlLCBjYWxsYmFjayA9IG5vb3ApIHtcbiAgICBsZXQgdXNlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3QgdXNlZExuZyA9IGlzU3RyaW5nKGxhbmd1YWdlKSA/IGxhbmd1YWdlIDogdGhpcy5sYW5ndWFnZTtcbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnZnVuY3Rpb24nKSB1c2VkQ2FsbGJhY2sgPSBsYW5ndWFnZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAodXNlZExuZz8udG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScgJiYgKCF0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCB0aGlzLm9wdGlvbnMucHJlbG9hZC5sZW5ndGggPT09IDApKSByZXR1cm4gdXNlZENhbGxiYWNrKCk7XG4gICAgICBjb25zdCB0b0xvYWQgPSBbXTtcbiAgICAgIGNvbnN0IGFwcGVuZCA9IGxuZyA9PiB7XG4gICAgICAgIGlmICghbG5nKSByZXR1cm47XG4gICAgICAgIGlmIChsbmcgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgIGxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAobCA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKCF1c2VkTG5nKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICAgIGZhbGxiYWNrcy5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCh1c2VkTG5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkPy5mb3JFYWNoPy4obCA9PiBhcHBlbmQobCkpO1xuICAgICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCB0aGlzLm9wdGlvbnMubnMsIGUgPT4ge1xuICAgICAgICBpZiAoIWUgJiYgIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlKSB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UodGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIHVzZWRDYWxsYmFjayhlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkQ2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbG9hZFJlc291cmNlcyhsbmdzLCBucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGxuZ3M7XG4gICAgICBsbmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG5zO1xuICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghbG5ncykgbG5ncyA9IHRoaXMubGFuZ3VhZ2VzO1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLm5zO1xuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcDtcbiAgICB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IucmVsb2FkKGxuZ3MsIG5zLCBlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgdXNlKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhbiB1bmRlZmluZWQgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmICghbW9kdWxlLnR5cGUpIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBwYXNzaW5nIGEgd3JvbmcgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2JhY2tlbmQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuYmFja2VuZCA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbG9nZ2VyJyB8fCBtb2R1bGUubG9nICYmIG1vZHVsZS53YXJuICYmIG1vZHVsZS5lcnJvcikge1xuICAgICAgdGhpcy5tb2R1bGVzLmxvZ2dlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbGFuZ3VhZ2VEZXRlY3RvcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdpMThuRm9ybWF0Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ3Bvc3RQcm9jZXNzb3InKSB7XG4gICAgICBwb3N0UHJvY2Vzc29yLmFkZFBvc3RQcm9jZXNzb3IobW9kdWxlKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnZm9ybWF0dGVyJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmZvcm1hdHRlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnM3JkUGFydHknKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZXh0ZXJuYWwucHVzaChtb2R1bGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSZXNvbHZlZExhbmd1YWdlKGwpIHtcbiAgICBpZiAoIWwgfHwgIXRoaXMubGFuZ3VhZ2VzKSByZXR1cm47XG4gICAgaWYgKFsnY2ltb2RlJywgJ2RldiddLmluZGV4T2YobCkgPiAtMSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGxpID0gMDsgbGkgPCB0aGlzLmxhbmd1YWdlcy5sZW5ndGg7IGxpKyspIHtcbiAgICAgIGNvbnN0IGxuZ0luTG5ncyA9IHRoaXMubGFuZ3VhZ2VzW2xpXTtcbiAgICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGxuZ0luTG5ncykgPiAtMSkgY29udGludWU7XG4gICAgICBpZiAodGhpcy5zdG9yZS5oYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nSW5MbmdzKSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgPSBsbmdJbkxuZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlcy5pbmRleE9mKGwpIDwgMCAmJiB0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsKSkge1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzLnVuc2hpZnQobCk7XG4gICAgfVxuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gbG5nO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdpbmcnLCBsbmcpO1xuICAgIGNvbnN0IHNldExuZ1Byb3BzID0gbCA9PiB7XG4gICAgICB0aGlzLmxhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsKTtcbiAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZShsKTtcbiAgICB9O1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyLCBsKSA9PiB7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAodGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9PT0gbG5nKSB7XG4gICAgICAgICAgc2V0TG5nUHJvcHMobCk7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5lbWl0KCdsYW5ndWFnZUNoYW5nZWQnLCBsKTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgoLi4uYXJncykgPT4gdGhpcy50KC4uLmFyZ3MpKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCAoLi4uYXJncykgPT4gdGhpcy50KC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldExuZyA9IGxuZ3MgPT4ge1xuICAgICAgaWYgKCFsbmcgJiYgIWxuZ3MgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yKSBsbmdzID0gW107XG4gICAgICBjb25zdCBmbCA9IGlzU3RyaW5nKGxuZ3MpID8gbG5ncyA6IGxuZ3MgJiYgbG5nc1swXTtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhmbCkgPyBmbCA6IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMoaXNTdHJpbmcobG5ncykgPyBbbG5nc10gOiBsbmdzKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdG9yLmxhbmd1YWdlKSB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvcj8uY2FjaGVVc2VyTGFuZ3VhZ2U/LihsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFJlc291cmNlcyhsLCBlcnIgPT4ge1xuICAgICAgICBkb25lKGVyciwgbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmFzeW5jKSB7XG4gICAgICBzZXRMbmcodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdCgpKTtcbiAgICB9IGVsc2UgaWYgKCFsbmcgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgaWYgKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKS50aGVuKHNldExuZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KHNldExuZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExuZyhsbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgZ2V0Rml4ZWRUKGxuZywgbnMsIGtleVByZWZpeCkge1xuICAgIGNvbnN0IGZpeGVkVCA9IChrZXksIG9wdHMsIC4uLnJlc3QpID0+IHtcbiAgICAgIGxldCBvO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvID0gdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKFtrZXksIG9wdHNdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0ge1xuICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG8ubG5nID0gby5sbmcgfHwgZml4ZWRULmxuZztcbiAgICAgIG8ubG5ncyA9IG8ubG5ncyB8fCBmaXhlZFQubG5ncztcbiAgICAgIG8ubnMgPSBvLm5zIHx8IGZpeGVkVC5ucztcbiAgICAgIGlmIChvLmtleVByZWZpeCAhPT0gJycpIG8ua2V5UHJlZml4ID0gby5rZXlQcmVmaXggfHwga2V5UHJlZml4IHx8IGZpeGVkVC5rZXlQcmVmaXg7XG4gICAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAoby5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnZnVuY3Rpb24nKSBrID0ga2V5c0Zyb21TZWxlY3RvcihrLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGAke28ua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a31gO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSBrZXkgPSBrZXlzRnJvbVNlbGVjdG9yKGtleSwge1xuICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRLZXkgPSBvLmtleVByZWZpeCA/IGAke28ua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50KHJlc3VsdEtleSwgbyk7XG4gICAgfTtcbiAgICBpZiAoaXNTdHJpbmcobG5nKSkge1xuICAgICAgZml4ZWRULmxuZyA9IGxuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZml4ZWRULmxuZ3MgPSBsbmc7XG4gICAgfVxuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIGZpeGVkVC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgcmV0dXJuIGZpeGVkVDtcbiAgfVxuICB0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yPy50cmFuc2xhdGUoLi4uYXJncyk7XG4gIH1cbiAgZXhpc3RzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yPy5leGlzdHMoLi4uYXJncyk7XG4gIH1cbiAgc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfVxuICBoYXNMb2FkZWROYW1lc3BhY2UobnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdoYXNMb2FkZWROYW1lc3BhY2U6IGkxOG5leHQgd2FzIG5vdCBpbml0aWFsaXplZCcsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxhbmd1YWdlcyB8fCAhdGhpcy5sYW5ndWFnZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdoYXNMb2FkZWROYW1lc3BhY2U6IGkxOG4ubGFuZ3VhZ2VzIHdlcmUgdW5kZWZpbmVkIG9yIGVtcHR5JywgdGhpcy5sYW5ndWFnZXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsbmcgPSBvcHRpb25zLmxuZyB8fCB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgfHwgdGhpcy5sYW5ndWFnZXNbMF07XG4gICAgY29uc3QgZmFsbGJhY2tMbmcgPSB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgOiBmYWxzZTtcbiAgICBjb25zdCBsYXN0TG5nID0gdGhpcy5sYW5ndWFnZXNbdGhpcy5sYW5ndWFnZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgbG9hZE5vdFBlbmRpbmcgPSAobCwgbikgPT4ge1xuICAgICAgY29uc3QgbG9hZFN0YXRlID0gdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnN0YXRlW2Ake2x9fCR7bn1gXTtcbiAgICAgIHJldHVybiBsb2FkU3RhdGUgPT09IC0xIHx8IGxvYWRTdGF0ZSA9PT0gMCB8fCBsb2FkU3RhdGUgPT09IDI7XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5wcmVjaGVjaykge1xuICAgICAgY29uc3QgcHJlUmVzdWx0ID0gb3B0aW9ucy5wcmVjaGVjayh0aGlzLCBsb2FkTm90UGVuZGluZyk7XG4gICAgICBpZiAocHJlUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiBwcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5iYWNrZW5kIHx8IHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgJiYgIXRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxvYWROb3RQZW5kaW5nKGxuZywgbnMpICYmICghZmFsbGJhY2tMbmcgfHwgbG9hZE5vdFBlbmRpbmcobGFzdExuZywgbnMpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvYWROYW1lc3BhY2VzKG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ucykge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcobnMpKSBucyA9IFtuc107XG4gICAgbnMuZm9yRWFjaChuID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihuKSA8IDApIHRoaXMub3B0aW9ucy5ucy5wdXNoKG4pO1xuICAgIH0pO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkTGFuZ3VhZ2VzKGxuZ3MsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmIChpc1N0cmluZyhsbmdzKSkgbG5ncyA9IFtsbmdzXTtcbiAgICBjb25zdCBwcmVsb2FkZWQgPSB0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCBbXTtcbiAgICBjb25zdCBuZXdMbmdzID0gbG5ncy5maWx0ZXIobG5nID0+IHByZWxvYWRlZC5pbmRleE9mKGxuZykgPCAwICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5pc1N1cHBvcnRlZENvZGUobG5nKSk7XG4gICAgaWYgKCFuZXdMbmdzLmxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucHJlbG9hZCA9IHByZWxvYWRlZC5jb25jYXQobmV3TG5ncyk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGRpcihsbmcpIHtcbiAgICBpZiAoIWxuZykgbG5nID0gdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8ICh0aGlzLmxhbmd1YWdlcz8ubGVuZ3RoID4gMCA/IHRoaXMubGFuZ3VhZ2VzWzBdIDogdGhpcy5sYW5ndWFnZSk7XG4gICAgaWYgKCFsbmcpIHJldHVybiAncnRsJztcbiAgICB0cnkge1xuICAgICAgY29uc3QgbCA9IG5ldyBJbnRsLkxvY2FsZShsbmcpO1xuICAgICAgaWYgKGwgJiYgbC5nZXRUZXh0SW5mbykge1xuICAgICAgICBjb25zdCB0aSA9IGwuZ2V0VGV4dEluZm8oKTtcbiAgICAgICAgaWYgKHRpICYmIHRpLmRpcmVjdGlvbikgcmV0dXJuIHRpLmRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGNvbnN0IHJ0bExuZ3MgPSBbJ2FyJywgJ3NodScsICdzcXInLCAnc3NoJywgJ3hhYScsICd5aGQnLCAneXVkJywgJ2FhbycsICdhYmgnLCAnYWJ2JywgJ2FjbScsICdhY3EnLCAnYWN3JywgJ2FjeCcsICdhY3knLCAnYWRmJywgJ2FkcycsICdhZWInLCAnYWVjJywgJ2FmYicsICdhanAnLCAnYXBjJywgJ2FwZCcsICdhcmInLCAnYXJxJywgJ2FycycsICdhcnknLCAnYXJ6JywgJ2F1eicsICdhdmwnLCAnYXloJywgJ2F5bCcsICdheW4nLCAnYXlwJywgJ2JieicsICdwZ2EnLCAnaGUnLCAnaXcnLCAncHMnLCAncGJ0JywgJ3BidScsICdwc3QnLCAncHJwJywgJ3ByZCcsICd1ZycsICd1cicsICd5ZGQnLCAneWRzJywgJ3lpaCcsICdqaScsICd5aScsICdoYm8nLCAnbWVuJywgJ3htbicsICdmYScsICdqcHInLCAncGVvJywgJ3BlcycsICdwcnMnLCAnZHYnLCAnc2FtJywgJ2NrYiddO1xuICAgIGNvbnN0IGxhbmd1YWdlVXRpbHMgPSB0aGlzLnNlcnZpY2VzPy5sYW5ndWFnZVV0aWxzIHx8IG5ldyBMYW5ndWFnZVV0aWwoZ2V0KCkpO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCctbGF0bicpID4gMSkgcmV0dXJuICdsdHInO1xuICAgIHJldHVybiBydGxMbmdzLmluZGV4T2YobGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShsbmcpKSA+IC0xIHx8IGxuZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy1hcmFiJykgPiAxID8gJ3J0bCcgOiAnbHRyJztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2Uob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgSTE4bihvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xvbmVJbnN0YW5jZShvcHRpb25zID0ge30sIGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IGZvcmtSZXNvdXJjZVN0b3JlID0gb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIGRlbGV0ZSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4ue1xuICAgICAgICBpc0Nsb25lOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJMThuKG1lcmdlZE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmRlYnVnICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvbmUubG9nZ2VyID0gY2xvbmUubG9nZ2VyLmNsb25lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtZW1iZXJzVG9Db3B5ID0gWydzdG9yZScsICdzZXJ2aWNlcycsICdsYW5ndWFnZSddO1xuICAgIG1lbWJlcnNUb0NvcHkuZm9yRWFjaChtID0+IHtcbiAgICAgIGNsb25lW21dID0gdGhpc1ttXTtcbiAgICB9KTtcbiAgICBjbG9uZS5zZXJ2aWNlcyA9IHtcbiAgICAgIC4uLnRoaXMuc2VydmljZXNcbiAgICB9O1xuICAgIGNsb25lLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkge1xuICAgICAgY29uc3QgY2xvbmVkRGF0YSA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmUuZGF0YSkucmVkdWNlKChwcmV2LCBsKSA9PiB7XG4gICAgICAgIHByZXZbbF0gPSB7XG4gICAgICAgICAgLi4udGhpcy5zdG9yZS5kYXRhW2xdXG4gICAgICAgIH07XG4gICAgICAgIHByZXZbbF0gPSBPYmplY3Qua2V5cyhwcmV2W2xdKS5yZWR1Y2UoKGFjYywgbikgPT4ge1xuICAgICAgICAgIGFjY1tuXSA9IHtcbiAgICAgICAgICAgIC4uLnByZXZbbF1bbl1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHByZXZbbF0pO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGNsb25lLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUoY2xvbmVkRGF0YSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICBjbG9uZS5zZXJ2aWNlcy5yZXNvdXJjZVN0b3JlID0gY2xvbmUuc3RvcmU7XG4gICAgfVxuICAgIGNsb25lLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihjbG9uZS5zZXJ2aWNlcywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vbignKicsIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgY2xvbmUuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY2xvbmUuaW5pdChtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vcHRpb25zID0gbWVyZ2VkT3B0aW9ucztcbiAgICBjbG9uZS50cmFuc2xhdG9yLmJhY2tlbmRDb25uZWN0b3Iuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlczogdGhpcy5sYW5ndWFnZXMsXG4gICAgICByZXNvbHZlZExhbmd1YWdlOiB0aGlzLnJlc29sdmVkTGFuZ3VhZ2VcbiAgICB9O1xuICB9XG59XG5jb25zdCBpbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2UoKTtcbmluc3RhbmNlLmNyZWF0ZUluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBpbnN0YW5jZS5jcmVhdGVJbnN0YW5jZTtcbmNvbnN0IGRpciA9IGluc3RhbmNlLmRpcjtcbmNvbnN0IGluaXQgPSBpbnN0YW5jZS5pbml0O1xuY29uc3QgbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLmxvYWRSZXNvdXJjZXM7XG5jb25zdCByZWxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5yZWxvYWRSZXNvdXJjZXM7XG5jb25zdCB1c2UgPSBpbnN0YW5jZS51c2U7XG5jb25zdCBjaGFuZ2VMYW5ndWFnZSA9IGluc3RhbmNlLmNoYW5nZUxhbmd1YWdlO1xuY29uc3QgZ2V0Rml4ZWRUID0gaW5zdGFuY2UuZ2V0Rml4ZWRUO1xuY29uc3QgdCA9IGluc3RhbmNlLnQ7XG5jb25zdCBleGlzdHMgPSBpbnN0YW5jZS5leGlzdHM7XG5jb25zdCBzZXREZWZhdWx0TmFtZXNwYWNlID0gaW5zdGFuY2Uuc2V0RGVmYXVsdE5hbWVzcGFjZTtcbmNvbnN0IGhhc0xvYWRlZE5hbWVzcGFjZSA9IGluc3RhbmNlLmhhc0xvYWRlZE5hbWVzcGFjZTtcbmNvbnN0IGxvYWROYW1lc3BhY2VzID0gaW5zdGFuY2UubG9hZE5hbWVzcGFjZXM7XG5jb25zdCBsb2FkTGFuZ3VhZ2VzID0gaW5zdGFuY2UubG9hZExhbmd1YWdlcztcblxuZXhwb3J0IHsgY2hhbmdlTGFuZ3VhZ2UsIGNyZWF0ZUluc3RhbmNlLCBpbnN0YW5jZSBhcyBkZWZhdWx0LCBkaXIsIGV4aXN0cywgZ2V0Rml4ZWRULCBoYXNMb2FkZWROYW1lc3BhY2UsIGluaXQsIGtleXNGcm9tU2VsZWN0b3IgYXMga2V5RnJvbVNlbGVjdG9yLCBsb2FkTGFuZ3VhZ2VzLCBsb2FkTmFtZXNwYWNlcywgbG9hZFJlc291cmNlcywgcmVsb2FkUmVzb3VyY2VzLCBzZXREZWZhdWx0TmFtZXNwYWNlLCB0LCB1c2UgfTtcbiJdLCJuYW1lcyI6WyJpc1N0cmluZyIsIm9iaiIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJmb3JFYWNoIiwibSIsImxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAiLCJjbGVhbktleSIsImtleSIsImluZGV4T2YiLCJyZXBsYWNlIiwiY2FuTm90VHJhdmVyc2VEZWVwZXIiLCJnZXRMYXN0T2ZQYXRoIiwicGF0aCIsIkVtcHR5Iiwic3RhY2siLCJzcGxpdCIsInN0YWNrSW5kZXgiLCJsZW5ndGgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwidW5kZWZpbmVkIiwiZSIsInAiLCJzbGljZSIsImxhc3QiLCJwdXNoUGF0aCIsImNvbmNhdCIsInB1c2giLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJSZWdFeHBDYWNoZSIsImNhcGFjaXR5IiwicmVnRXhwTWFwIiwiTWFwIiwicmVnRXhwUXVldWUiLCJnZXRSZWdFeHAiLCJwYXR0ZXJuIiwicmVnRXhwRnJvbUNhY2hlIiwiZ2V0IiwicmVnRXhwTmV3IiwiUmVnRXhwIiwiZGVsZXRlIiwic2hpZnQiLCJzZXQiLCJjaGFycyIsImxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSIsImxvb2tzTGlrZU9iamVjdFBhdGgiLCJuc1NlcGFyYXRvciIsImtleVNlcGFyYXRvciIsInBvc3NpYmxlQ2hhcnMiLCJmaWx0ZXIiLCJjIiwiciIsIm1hcCIsImpvaW4iLCJtYXRjaGVkIiwidGVzdCIsImtpIiwic3Vic3RyaW5nIiwiZGVlcEZpbmQiLCJ0b2tlbnMiLCJjdXJyZW50IiwiaSIsIm5leHQiLCJuZXh0UGF0aCIsImoiLCJnZXRDbGVhbmVkQ29kZSIsImNvZGUiLCJjb25zb2xlTG9nZ2VyIiwidHlwZSIsImxvZyIsImFyZ3MiLCJvdXRwdXQiLCJ3YXJuIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBwbHkiLCJMb2dnZXIiLCJjb25jcmV0ZUxvZ2dlciIsIm9wdGlvbnMiLCJpbml0IiwicHJlZml4IiwibG9nZ2VyIiwiZGVidWciLCJmb3J3YXJkIiwiZGVwcmVjYXRlIiwibHZsIiwiZGVidWdPbmx5IiwiY3JlYXRlIiwibW9kdWxlTmFtZSIsImNsb25lIiwiYmFzZUxvZ2dlciIsIkV2ZW50RW1pdHRlciIsIm9ic2VydmVycyIsIm9uIiwiZXZlbnRzIiwibGlzdGVuZXIiLCJldmVudCIsIm51bUxpc3RlbmVycyIsIm9mZiIsImVtaXQiLCJjbG9uZWQiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwib2JzZXJ2ZXIiLCJudW1UaW1lc0FkZGVkIiwiUmVzb3VyY2VTdG9yZSIsIm5zIiwiZGVmYXVsdE5TIiwiaWdub3JlSlNPTlN0cnVjdHVyZSIsImFkZE5hbWVzcGFjZXMiLCJyZW1vdmVOYW1lc3BhY2VzIiwiaW5kZXgiLCJzcGxpY2UiLCJnZXRSZXNvdXJjZSIsImxuZyIsImlzQXJyYXkiLCJyZXN1bHQiLCJhZGRSZXNvdXJjZSIsInNpbGVudCIsImFkZFJlc291cmNlcyIsInJlc291cmNlcyIsImFkZFJlc291cmNlQnVuZGxlIiwiZGVlcCIsInNraXBDb3B5IiwicGFjayIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInJlbW92ZVJlc291cmNlQnVuZGxlIiwiaGFzUmVzb3VyY2VCdW5kbGUiLCJnZXRSZXNvdXJjZUJ1bmRsZSIsImdldERhdGFCeUxhbmd1YWdlIiwiaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zIiwibiIsImtleXMiLCJmaW5kIiwidiIsInRvSlNPTiIsInBvc3RQcm9jZXNzb3IiLCJwcm9jZXNzb3JzIiwiYWRkUG9zdFByb2Nlc3NvciIsIm1vZHVsZSIsIm5hbWUiLCJoYW5kbGUiLCJ0cmFuc2xhdG9yIiwicHJvY2Vzc29yIiwicHJvY2VzcyIsIlBBVEhfS0VZIiwiU3ltYm9sIiwiY3JlYXRlUHJveHkiLCJzdGF0ZSIsImhhbmRsZXIiLCJwcm94eSIsInJldm9rZSIsIlByb3h5IiwicmV2b2NhYmxlIiwia2V5c0Zyb21TZWxlY3RvciIsInNlbGVjdG9yIiwib3B0cyIsImNoZWNrZWRMb2FkZWRGb3IiLCJzaG91bGRIYW5kbGVBc09iamVjdCIsIlRyYW5zbGF0b3IiLCJzZXJ2aWNlcyIsImNoYW5nZUxhbmd1YWdlIiwibGFuZ3VhZ2UiLCJleGlzdHMiLCJvIiwiaW50ZXJwb2xhdGlvbiIsIm9wdCIsInJlc29sdmVkIiwiZXh0cmFjdEZyb21LZXkiLCJuYW1lc3BhY2VzIiwid291bGRDaGVja0Zvck5zSW5LZXkiLCJzZWVtc05hdHVyYWxMYW5ndWFnZSIsInVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yIiwidXNlckRlZmluZWROc1NlcGFyYXRvciIsIm1hdGNoIiwiaW50ZXJwb2xhdG9yIiwibmVzdGluZ1JlZ2V4cCIsInBhcnRzIiwidHJhbnNsYXRlIiwibGFzdEtleSIsIm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyIiwiYXJndW1lbnRzIiwicmV0dXJuRGV0YWlscyIsIm5hbWVzcGFjZSIsImFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIiwidG9Mb3dlckNhc2UiLCJ1c2VkS2V5IiwiZXhhY3RVc2VkS2V5IiwidXNlZExuZyIsInVzZWROUyIsInVzZWRQYXJhbXMiLCJnZXRVc2VkUGFyYW1zRGV0YWlscyIsInJlc1VzZWRLZXkiLCJyZXNFeGFjdFVzZWRLZXkiLCJub09iamVjdCIsImpvaW5BcnJheXMiLCJoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCIsImkxOG5Gb3JtYXQiLCJoYW5kbGVBc09iamVjdCIsIm5lZWRzUGx1cmFsSGFuZGxpbmciLCJjb3VudCIsImhhc0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRWYWx1ZVN1ZmZpeCIsInBsdXJhbFJlc29sdmVyIiwiZ2V0U3VmZml4IiwiZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrIiwib3JkaW5hbCIsIm5lZWRzWmVyb1N1ZmZpeExvb2t1cCIsImRlZmF1bHRWYWx1ZSIsInBsdXJhbFNlcGFyYXRvciIsInJlc0Zvck9iakhuZGwiLCJyZXNUeXBlIiwidG9TdHJpbmciLCJyZXR1cm5PYmplY3RzIiwicmV0dXJuZWRPYmplY3RIYW5kbGVyIiwicmVzVHlwZUlzQXJyYXkiLCJuZXdLZXlUb1VzZSIsImRlZXBLZXkiLCJleHRlbmRUcmFuc2xhdGlvbiIsInVzZWREZWZhdWx0IiwiaXNWYWxpZExvb2t1cCIsIm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSIsInJlc0Zvck1pc3NpbmciLCJ1cGRhdGVNaXNzaW5nIiwiZmsiLCJsbmdzIiwiZmFsbGJhY2tMbmdzIiwibGFuZ3VhZ2VVdGlscyIsImdldEZhbGxiYWNrQ29kZXMiLCJmYWxsYmFja0xuZyIsInNhdmVNaXNzaW5nVG8iLCJ0b1Jlc29sdmVIaWVyYXJjaHkiLCJzZW5kIiwibCIsInNwZWNpZmljRGVmYXVsdFZhbHVlIiwiZGVmYXVsdEZvck1pc3NpbmciLCJtaXNzaW5nS2V5SGFuZGxlciIsImJhY2tlbmRDb25uZWN0b3IiLCJzYXZlTWlzc2luZyIsInNhdmVNaXNzaW5nUGx1cmFscyIsInN1ZmZpeGVzIiwiZ2V0U3VmZml4ZXMiLCJzdWZmaXgiLCJhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkiLCJwYXJzZU1pc3NpbmdLZXlIYW5kbGVyIiwiZGVmYXVsdFZhcmlhYmxlcyIsInNraXBJbnRlcnBvbGF0aW9uIiwic2tpcE9uVmFyaWFibGVzIiwibmVzdEJlZiIsIm5iIiwiaW50ZXJwb2xhdGUiLCJuYSIsIm5lc3RBZnQiLCJuZXN0IiwiY29udGV4dCIsInJlc2V0IiwicG9zdFByb2Nlc3MiLCJwb3N0UHJvY2Vzc29yTmFtZXMiLCJhcHBseVBvc3RQcm9jZXNzb3IiLCJwb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZCIsImkxOG5SZXNvbHZlZCIsImZvdW5kIiwiZXh0cmFjdGVkIiwiZmFsbGJhY2tOUyIsIm5lZWRzQ29udGV4dEhhbmRsaW5nIiwiY29kZXMiLCJ1dGlscyIsImhhc0xvYWRlZE5hbWVzcGFjZSIsImZpbmFsS2V5cyIsImFkZExvb2t1cEtleXMiLCJwbHVyYWxTdWZmaXgiLCJ6ZXJvU3VmZml4Iiwib3JkaW5hbFByZWZpeCIsImNvbnRleHRLZXkiLCJjb250ZXh0U2VwYXJhdG9yIiwicG9zc2libGVLZXkiLCJwb3AiLCJyZXR1cm5OdWxsIiwicmV0dXJuRW1wdHlTdHJpbmciLCJyZXNvdXJjZVN0b3JlIiwib3B0aW9uc0tleXMiLCJ1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEiLCJvcHRpb24iLCJMYW5ndWFnZVV0aWwiLCJzdXBwb3J0ZWRMbmdzIiwiZ2V0U2NyaXB0UGFydEZyb21Db2RlIiwiZm9ybWF0TGFuZ3VhZ2VDb2RlIiwiZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUiLCJmb3JtYXR0ZWRDb2RlIiwiSW50bCIsImdldENhbm9uaWNhbExvY2FsZXMiLCJsb3dlckNhc2VMbmciLCJjbGVhbkNvZGUiLCJpc1N1cHBvcnRlZENvZGUiLCJsb2FkIiwibm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzIiwiZ2V0QmVzdE1hdGNoRnJvbUNvZGVzIiwiY2xlYW5lZExuZyIsImxuZ1NjT25seSIsImxuZ09ubHkiLCJzdXBwb3J0ZWRMbmciLCJmYWxsYmFja3MiLCJkZWZhdWx0IiwiZmFsbGJhY2tDb2RlIiwiZmFsbGJhY2tDb2RlcyIsImFkZENvZGUiLCJmYyIsInN1ZmZpeGVzT3JkZXIiLCJ6ZXJvIiwib25lIiwidHdvIiwiZmV3IiwibWFueSIsIm90aGVyIiwiZHVtbXlSdWxlIiwic2VsZWN0IiwicmVzb2x2ZWRPcHRpb25zIiwicGx1cmFsQ2F0ZWdvcmllcyIsIlBsdXJhbFJlc29sdmVyIiwicGx1cmFsUnVsZXNDYWNoZSIsImFkZFJ1bGUiLCJydWxlcyIsImNsZWFyQ2FjaGUiLCJnZXRSdWxlIiwiY2xlYW5lZENvZGUiLCJjYWNoZUtleSIsInJ1bGUiLCJQbHVyYWxSdWxlcyIsImVyciIsImxuZ1BhcnQiLCJuZWVkc1BsdXJhbCIsImdldFBsdXJhbEZvcm1zT2ZLZXkiLCJzb3J0IiwicGx1cmFsQ2F0ZWdvcnkxIiwicGx1cmFsQ2F0ZWdvcnkyIiwicGx1cmFsQ2F0ZWdvcnkiLCJwcmVwZW5kIiwiZGVlcEZpbmRXaXRoRGVmYXVsdHMiLCJyZWdleFNhZmUiLCJ2YWwiLCJJbnRlcnBvbGF0b3IiLCJmb3JtYXQiLCJlc2NhcGVWYWx1ZSIsImVzY2FwZSQxIiwidXNlUmF3VmFsdWVUb0VzY2FwZSIsInByZWZpeEVzY2FwZWQiLCJzdWZmaXhFc2NhcGVkIiwiZm9ybWF0U2VwYXJhdG9yIiwidW5lc2NhcGVTdWZmaXgiLCJ1bmVzY2FwZVByZWZpeCIsIm5lc3RpbmdQcmVmaXgiLCJuZXN0aW5nUHJlZml4RXNjYXBlZCIsIm5lc3RpbmdTdWZmaXgiLCJuZXN0aW5nU3VmZml4RXNjYXBlZCIsIm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIiwibWF4UmVwbGFjZXMiLCJhbHdheXNGb3JtYXQiLCJyZXNldFJlZ0V4cCIsImdldE9yUmVzZXRSZWdFeHAiLCJleGlzdGluZ1JlZ0V4cCIsImxhc3RJbmRleCIsInJlZ2V4cCIsInJlZ2V4cFVuZXNjYXBlIiwicmVwbGFjZXMiLCJoYW5kbGVGb3JtYXQiLCJpbnRlcnBvbGF0aW9ua2V5IiwidHJpbSIsImYiLCJtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIiLCJ0b2RvcyIsInJlZ2V4Iiwic2FmZVZhbHVlIiwidG9kbyIsImV4ZWMiLCJtYXRjaGVkVmFyIiwidGVtcCIsImNsb25lZE9wdGlvbnMiLCJoYW5kbGVIYXNPcHRpb25zIiwiaW5oZXJpdGVkT3B0aW9ucyIsInNlcCIsIm9wdGlvbnNTdHJpbmciLCJtYXRjaGVkU2luZ2xlUXVvdGVzIiwibWF0Y2hlZERvdWJsZVF1b3RlcyIsImZvcm1hdHRlcnMiLCJrZXlFbmRJbmRleCIsImxhc3RJbmRleE9mIiwiZWxlbSIsIkJvb2xlYW4iLCJyZWR1Y2UiLCJwYXJzZUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImZvcm1hdE5hbWUiLCJmb3JtYXRPcHRpb25zIiwib3B0U3RyIiwiY3VycmVuY3kiLCJyYW5nZSIsInJlc3QiLCJ0cmltbWVkS2V5IiwiaXNOYU4iLCJwYXJzZUludCIsImNyZWF0ZUNhY2hlZEZvcm1hdHRlciIsImZuIiwiY2FjaGUiLCJvcHRGb3JDYWNoZSIsImZvcm1hdFBhcmFtcyIsImZybSIsImNyZWF0ZU5vbkNhY2hlZEZvcm1hdHRlciIsIkZvcm1hdHRlciIsImNmIiwiY2FjaGVJbkJ1aWx0Rm9ybWF0cyIsImZvcm1hdHMiLCJudW1iZXIiLCJmb3JtYXR0ZXIiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZWxhdGl2ZXRpbWUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJsaXN0IiwiTGlzdEZvcm1hdCIsImFkZCIsImFkZENhY2hlZCIsImZpbmRJbmRleCIsIm1lbSIsImZvcm1hdHRlZCIsInZhbE9wdGlvbnMiLCJsb2NhbGUiLCJyZW1vdmVQZW5kaW5nIiwicSIsInBlbmRpbmciLCJwZW5kaW5nQ291bnQiLCJDb25uZWN0b3IiLCJiYWNrZW5kIiwic3RvcmUiLCJ3YWl0aW5nUmVhZHMiLCJtYXhQYXJhbGxlbFJlYWRzIiwicmVhZGluZ0NhbGxzIiwibWF4UmV0cmllcyIsInJldHJ5VGltZW91dCIsInF1ZXVlIiwicXVldWVMb2FkIiwibGFuZ3VhZ2VzIiwiY2FsbGJhY2siLCJ0b0xvYWQiLCJ0b0xvYWRMYW5ndWFnZXMiLCJ0b0xvYWROYW1lc3BhY2VzIiwiaGFzQWxsTmFtZXNwYWNlcyIsInJlbG9hZCIsImxvYWRlZCIsImVycm9ycyIsImRvbmUiLCJsb2FkZWRLZXlzIiwicmVhZCIsImZjTmFtZSIsInRyaWVkIiwid2FpdCIsInJlc29sdmVyIiwic2V0VGltZW91dCIsImJpbmQiLCJ0aGVuIiwiY2F0Y2giLCJwcmVwYXJlTG9hZGluZyIsImxvYWRPbmUiLCJmYWxsYmFja1ZhbHVlIiwiaXNVcGRhdGUiLCJjbGIiLCJpbml0QXN5bmMiLCJwcmVsb2FkIiwic2ltcGxpZnlQbHVyYWxTdWZmaXgiLCJwYXJ0aWFsQnVuZGxlZExhbmd1YWdlcyIsInJldCIsInREZXNjcmlwdGlvbiIsInRyYW5zZm9ybU9wdGlvbnMiLCJpbml0SW1tZWRpYXRlIiwibm9vcCIsImJpbmRNZW1iZXJGdW5jdGlvbnMiLCJpbnN0IiwibWVtcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsIkkxOG4iLCJtb2R1bGVzIiwiZXh0ZXJuYWwiLCJpc0luaXRpYWxpemVkIiwiaXNDbG9uZSIsImlzSW5pdGlhbGl6aW5nIiwiZGVmT3B0cyIsImNyZWF0ZUNsYXNzT25EZW1hbmQiLCJDbGFzc09yT2JqZWN0IiwibHUiLCJ1c2luZ0xlZ2FjeUZvcm1hdEZ1bmN0aW9uIiwibGFuZ3VhZ2VEZXRlY3RvciIsImRldGVjdGlvbiIsInN0b3JlQXBpIiwic3RvcmVBcGlDaGFpbmVkIiwiZGVmZXJyZWQiLCJmaW5pc2giLCJpbml0aWFsaXplZFN0b3JlT25jZSIsImxvYWRSZXNvdXJjZXMiLCJ1c2VkQ2FsbGJhY2siLCJhcHBlbmQiLCJyZXNvbHZlZExhbmd1YWdlIiwic2V0UmVzb2x2ZWRMYW5ndWFnZSIsInJlbG9hZFJlc291cmNlcyIsInVzZSIsIkVycm9yIiwibGkiLCJsbmdJbkxuZ3MiLCJ1bnNoaWZ0IiwiaXNMYW5ndWFnZUNoYW5naW5nVG8iLCJzZXRMbmdQcm9wcyIsInNldExuZyIsImZsIiwiY2FjaGVVc2VyTGFuZ3VhZ2UiLCJhc3luYyIsImRldGVjdCIsImdldEZpeGVkVCIsImtleVByZWZpeCIsImZpeGVkVCIsInJlc3VsdEtleSIsInNldERlZmF1bHROYW1lc3BhY2UiLCJsYXN0TG5nIiwibG9hZE5vdFBlbmRpbmciLCJsb2FkU3RhdGUiLCJwcmVjaGVjayIsInByZVJlc3VsdCIsImxvYWROYW1lc3BhY2VzIiwibG9hZExhbmd1YWdlcyIsInByZWxvYWRlZCIsIm5ld0xuZ3MiLCJkaXIiLCJMb2NhbGUiLCJnZXRUZXh0SW5mbyIsInRpIiwiZGlyZWN0aW9uIiwicnRsTG5ncyIsImNsb25lSW5zdGFuY2UiLCJmb3JrUmVzb3VyY2VTdG9yZSIsIm1lcmdlZE9wdGlvbnMiLCJtZW1iZXJzVG9Db3B5IiwiY2xvbmVkRGF0YSIsInByZXYiLCJhY2MiLCJjcmVhdGVJbnN0YW5jZSIsImluc3RhbmNlIiwia2V5RnJvbVNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

}]);