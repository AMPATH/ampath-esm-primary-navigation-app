"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_openmrs_esm_app_shell"] = self["webpackChunk_openmrs_esm_app_shell"] || []).push([["vendors-node_modules_react-router-dom_dist_index_js"],{

/***/ "../../../node_modules/@remix-run/router/dist/router.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/@remix-run/router/dist/router.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   ErrorResponse: () => (/* binding */ ErrorResponse),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   invariant: () => (/* binding */ invariant),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename),\n/* harmony export */   unstable_createStaticHandler: () => (/* binding */ unstable_createStaticHandler),\n/* harmony export */   warning: () => (/* binding */ warning)\n/* harmony export */ });\n/**\n * @remix-run/router v1.0.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _assert_this_initialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _call_super(_this, derived, args) {\n    derived = _get_prototype_of(derived);\n    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _set_prototype_of(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _is_native_function(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possible_constructor_return(self, call) {\n    if (call && (_type_of(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assert_this_initialized(self);\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _wrap_native_super(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrap_native_super = function wrapNativeSuper(Class) {\n        if (Class === null || !_is_native_function(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _get_prototype_of(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _set_prototype_of(Wrapper, Class);\n    };\n    return _wrap_native_super(Class);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction _ts_values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function _extends(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options_initialEntries = options.initialEntries, initialEntries = _options_initialEntries === void 0 ? [\n        \"/\"\n    ] : _options_initialEntries, initialIndex = options.initialIndex, _options_v5Compat = options.v5Compat, v5Compat = _options_v5Compat === void 0 ? false : _options_v5Compat;\n    var entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map(function(entry, index) {\n        return createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined);\n    });\n    var index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    var action = Action.Pop;\n    var listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        var location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning$1(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    var history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref: function createHref(to) {\n            return typeof to === \"string\" ? to : createPath(to);\n        },\n        push: function push(to, state) {\n            action = Action.Push;\n            var nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action: action,\n                    location: nextLocation\n                });\n            }\n        },\n        replace: function replace(to, state) {\n            action = Action.Replace;\n            var nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action: action,\n                    location: nextLocation\n                });\n            }\n        },\n        go: function go(delta) {\n            action = Action.Pop;\n            index = clampIndex(index + delta);\n            if (listener) {\n                listener({\n                    action: action,\n                    location: getCurrentLocation()\n                });\n            }\n        },\n        listen: function listen(fn) {\n            listener = fn;\n            return function() {\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        var _window_location = window1.location, pathname = _window_location.pathname, search = _window_location.search, hash = _window_location.hash;\n        return createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        var _parsePath = parsePath(window1.location.hash.substr(1)), _parsePath_pathname = _parsePath.pathname, pathname = _parsePath_pathname === void 0 ? \"/\" : _parsePath_pathname, _parsePath_search = _parsePath.search, search = _parsePath_search === void 0 ? \"\" : _parsePath_search, _parsePath_hash = _parsePath.hash, hash = _parsePath_hash === void 0 ? \"\" : _parsePath_hash;\n        return createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        var base = window1.document.querySelector(\"base\");\n        var href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            var url = window1.location.href;\n            var hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning$1(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\nfunction warning$1(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location) {\n    return {\n        usr: location.state,\n        key: location.key\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    var location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state: state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    var _ref_pathname = _ref.pathname, pathname = _ref_pathname === void 0 ? \"/\" : _ref_pathname, _ref_search = _ref.search, search = _ref_search === void 0 ? \"\" : _ref_search, _ref_hash = _ref.hash, hash = _ref_hash === void 0 ? \"\" : _ref_hash;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    var parsedPath = {};\n    if (path) {\n        var hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        var searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options_window = options.window, window1 = _options_window === void 0 ? document.defaultView : _options_window, _options_v5Compat = options.v5Compat, v5Compat = _options_v5Compat === void 0 ? false : _options_v5Compat;\n    var globalHistory = window1.history;\n    var action = Action.Pop;\n    var listener = null;\n    function handlePop() {\n        action = Action.Pop;\n        if (listener) {\n            listener({\n                action: action,\n                location: history.location\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        var location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        var historyState = getHistoryState(location);\n        var url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action: action,\n                location: location\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        var location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        var historyState = getHistoryState(location);\n        var url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action: action,\n                location: location\n            });\n        }\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen: function listen(fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return function() {\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref: function createHref1(to) {\n            return createHref(window1, to);\n        },\n        push: push,\n        replace: replace,\n        go: function go(n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n} //#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nfunction isIndexRoute(route) {\n    return route.index === true;\n} // Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, parentPath, allIds) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (allIds === void 0) {\n        allIds = new Set();\n    }\n    return routes.map(function(route, index) {\n        var treePath = _to_consumable_array(parentPath).concat([\n            index\n        ]);\n        var id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!allIds.has(id), \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n        allIds.add(id);\n        if (isIndexRoute(route)) {\n            var indexRoute = _extends({}, route, {\n                id: id\n            });\n            return indexRoute;\n        } else {\n            var pathOrLayoutRoute = _extends({}, route, {\n                id: id,\n                children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined\n            });\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    var location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    var pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    var branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    var matches = null;\n    for(var i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], pathname);\n    }\n    return matches;\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    routes.forEach(function(route, index) {\n        var meta = {\n            relativePath: route.path || \"\",\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route: route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        var path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        var routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        } // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path: path,\n            score: computeScore(path, route.index),\n            routesMeta: routesMeta\n        });\n    });\n    return branches;\n}\nfunction rankRouteBranches(branches) {\n    branches.sort(function(a, b) {\n        return a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map(function(meta) {\n            return meta.childrenIndex;\n        }), b.routesMeta.map(function(meta) {\n            return meta.childrenIndex;\n        }));\n    });\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = function(s) {\n    return s === \"*\";\n};\nfunction computeScore(path, index) {\n    var segments = path.split(\"/\");\n    var initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter(function(s) {\n        return !isSplat(s);\n    }).reduce(function(score, segment) {\n        return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue);\n    }, initialScore);\n}\nfunction compareIndexes(a, b) {\n    var siblings = a.length === b.length && a.slice(0, -1).every(function(n, i) {\n        return n === b[i];\n    });\n    return siblings ? // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    var routesMeta = branch.routesMeta;\n    var matchedParams = {};\n    var matchedPathname = \"/\";\n    var matches = [];\n    for(var i = 0; i < routesMeta.length; ++i){\n        var meta = routesMeta[i];\n        var end = i === routesMeta.length - 1;\n        var remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        var match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end: end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        var route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route: route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/generate-path\n */ function generatePath(path, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return path.replace(/:(\\w+)/g, function(_, key) {\n        invariant(params[key] != null, \"Missing \\\":\" + key + \"\\\" param\");\n        return params[key];\n    }).replace(/(\\/?)\\*/, function(_, prefix, __, str) {\n        var star = \"*\";\n        if (params[star] == null) {\n            // If no splat was provided, trim the trailing slash _unless_ it's\n            // the entire path\n            return str === \"/*\" ? \"/\" : \"\";\n        } // Apply the splat\n        return \"\" + prefix + params[star];\n    });\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    var _compilePath = _sliced_to_array(compilePath(pattern.path, pattern.caseSensitive, pattern.end), 2), matcher = _compilePath[0], paramNames = _compilePath[1];\n    var match = pathname.match(matcher);\n    if (!match) return null;\n    var matchedPathname = match[0];\n    var pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    var captureGroups = match.slice(1);\n    var params = paramNames.reduce(function(memo, paramName, index) {\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            var splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n        return memo;\n    }, {});\n    return {\n        params: params,\n        pathname: matchedPathname,\n        pathnameBase: pathnameBase,\n        pattern: pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    var paramNames = [];\n    var regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/:(\\w+)/g, function(_, paramName) {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        paramNames.push(\"*\");\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    var matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        paramNames\n    ];\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    } // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    var startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    var nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\n/**\n * @private\n */ function warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging React Router!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    var _ref = typeof to === \"string\" ? parsePath(to) : to, toPathname = _ref.pathname, _ref_search = _ref.search, search = _ref_search === void 0 ? \"\" : _ref_search, _ref_hash = _ref.hash, hash = _ref_hash === void 0 ? \"\" : _ref_hash;\n    var pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname: pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    var segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    var relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach(function(segment) {\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    var to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    var isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    var toPathname = isEmptyPath ? \"/\" : to.pathname;\n    var from; // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (isPathRelative || toPathname == null) {\n        from = locationPathname;\n    } else {\n        var routePathnameIndex = routePathnames.length - 1;\n        if (toPathname.startsWith(\"..\")) {\n            var toSegments = toPathname.split(\"/\"); // Each leading .. segment means \"go up one route\" instead of \"go up one\n            // URL segment\".  This is a key difference from how <a href> works and a\n            // major reason we call this a \"to\" value instead of a \"href\".\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        } // If there are more \"..\" segments than parent routes, resolve relative to\n        // the root / URL.\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    var path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original \"to\" had one\n    var hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\"); // Or if this was a link to the current path which has a trailing slash\n    var hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ var joinPaths = function(paths) {\n    return paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n};\n/**\n * @private\n */ var normalizePathname = function(pathname) {\n    return pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n};\n/**\n * @private\n */ var normalizeSearch = function(search) {\n    return !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n};\n/**\n * @private\n */ var normalizeHash = function(hash) {\n    return !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n};\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ var json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    var responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    var headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers: headers\n    }));\n};\nvar AbortedDeferredError = /*#__PURE__*/ function(Error1) {\n    \"use strict\";\n    _inherits(AbortedDeferredError, Error1);\n    function AbortedDeferredError() {\n        _class_call_check(this, AbortedDeferredError);\n        return _call_super(this, AbortedDeferredError, arguments);\n    }\n    return AbortedDeferredError;\n}(_wrap_native_super(Error));\nvar DeferredData = /*#__PURE__*/ function() {\n    \"use strict\";\n    function DeferredData(data) {\n        var _this = this;\n        _class_call_check(this, DeferredData);\n        this.pendingKeys = new Set();\n        this.subscriber = undefined;\n        invariant(data && (typeof data === \"undefined\" ? \"undefined\" : _type_of(data)) === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\"); // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        var reject;\n        this.abortPromise = new Promise(function(_, r) {\n            return reject = r;\n        });\n        this.controller = new AbortController();\n        var onAbort = function() {\n            return reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        };\n        this.unlistenAbortSignal = function() {\n            return _this.controller.signal.removeEventListener(\"abort\", onAbort);\n        };\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce(function(acc, _ref) {\n            var _$_ref = _sliced_to_array(_ref, 2), key = _$_ref[0], value = _$_ref[1];\n            return Object.assign(acc, _define_property({}, key, _this.trackPromise(key, value)));\n        }, {});\n    }\n    _create_class(DeferredData, [\n        {\n            key: \"trackPromise\",\n            value: function trackPromise(key, value) {\n                var _this = this;\n                if (!_instanceof(value, Promise)) {\n                    return value;\n                }\n                this.pendingKeys.add(key); // We store a little wrapper promise that will be extended with\n                // _data/_error props upon resolve/reject\n                var promise = Promise.race([\n                    value,\n                    this.abortPromise\n                ]).then(function(data) {\n                    return _this.onSettle(promise, key, null, data);\n                }, function(error) {\n                    return _this.onSettle(promise, key, error);\n                }); // Register rejection listeners to avoid uncaught promise rejections on\n                // errors or aborted deferred values\n                promise.catch(function() {});\n                Object.defineProperty(promise, \"_tracked\", {\n                    get: function() {\n                        return true;\n                    }\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"onSettle\",\n            value: function onSettle(promise, key, error, data) {\n                if (this.controller.signal.aborted && _instanceof(error, AbortedDeferredError)) {\n                    this.unlistenAbortSignal();\n                    Object.defineProperty(promise, \"_error\", {\n                        get: function() {\n                            return error;\n                        }\n                    });\n                    return Promise.reject(error);\n                }\n                this.pendingKeys.delete(key);\n                if (this.done) {\n                    // Nothing left to abort!\n                    this.unlistenAbortSignal();\n                }\n                var subscriber = this.subscriber;\n                if (error) {\n                    Object.defineProperty(promise, \"_error\", {\n                        get: function() {\n                            return error;\n                        }\n                    });\n                    subscriber && subscriber(false);\n                    return Promise.reject(error);\n                }\n                Object.defineProperty(promise, \"_data\", {\n                    get: function() {\n                        return data;\n                    }\n                });\n                subscriber && subscriber(false);\n                return data;\n            }\n        },\n        {\n            key: \"subscribe\",\n            value: function subscribe(fn) {\n                this.subscriber = fn;\n            }\n        },\n        {\n            key: \"cancel\",\n            value: function cancel() {\n                var _this = this;\n                this.controller.abort();\n                this.pendingKeys.forEach(function(v, k) {\n                    return _this.pendingKeys.delete(k);\n                });\n                var subscriber = this.subscriber;\n                subscriber && subscriber(true);\n            }\n        },\n        {\n            key: \"resolveData\",\n            value: function resolveData(signal) {\n                return _async_to_generator(function() {\n                    var _this, aborted, onAbort;\n                    return _ts_generator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                _this = this;\n                                aborted = false;\n                                if (!!this.done) return [\n                                    3,\n                                    2\n                                ];\n                                onAbort = function() {\n                                    return _this.cancel();\n                                };\n                                signal.addEventListener(\"abort\", onAbort);\n                                return [\n                                    4,\n                                    new Promise(function(resolve) {\n                                        _this.subscribe(function(aborted) {\n                                            signal.removeEventListener(\"abort\", onAbort);\n                                            if (aborted || _this.done) {\n                                                resolve(aborted);\n                                            }\n                                        });\n                                    })\n                                ];\n                            case 1:\n                                aborted = _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                return [\n                                    2,\n                                    aborted\n                                ];\n                        }\n                    });\n                }).call(this);\n            }\n        },\n        {\n            key: \"done\",\n            get: function get() {\n                return this.pendingKeys.size === 0;\n            }\n        },\n        {\n            key: \"unwrappedData\",\n            get: function get() {\n                invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n                return Object.entries(this.data).reduce(function(acc, _ref2) {\n                    var _$_ref2 = _sliced_to_array(_ref2, 2), key = _$_ref2[0], value = _$_ref2[1];\n                    return Object.assign(acc, _define_property({}, key, unwrapTrackedPromise(value)));\n                }, {});\n            }\n        }\n    ]);\n    return DeferredData;\n}();\nfunction isTrackedPromise(value) {\n    return _instanceof(value, Promise) && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nfunction defer(data) {\n    return new DeferredData(data);\n}\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ var redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    var responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    var headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers: headers\n    }));\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */ var ErrorResponse = function ErrorResponse(status, statusText, data) {\n    \"use strict\";\n    _class_call_check(this, ErrorResponse);\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.data = data;\n};\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response throw from an action/loader\n */ function isRouteErrorResponse(e) {\n    return _instanceof(e, ErrorResponse);\n}\nvar IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined\n};\nvar IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined\n}; //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    var dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history\n    var unlistenHistory = null; // Externally-provided functions to call on all state changes\n    var subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing\n    var savedScrollPositions = null; // Externally-provided function to get scroll restoration keys\n    var getScrollRestorationKey = null; // Externally-provided function to get current scroll position\n    var getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    var initialScrollRestored = false;\n    var initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);\n    var initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        var _getNotFoundMatches = getNotFoundMatches(dataRoutes), matches = _getNotFoundMatches.matches, route = _getNotFoundMatches.route, error = _getNotFoundMatches.error;\n        initialMatches = matches;\n        initialErrors = _define_property({}, route.id, error);\n    }\n    var initialized = !initialMatches.some(function(m) {\n        return m.route.loader;\n    }) || init.hydrationData != null;\n    var router;\n    var state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized: initialized,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map()\n    }; // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    var pendingAction = Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    var pendingPreventScrollReset = false; // AbortController for the active navigation\n    var pendingNavigationController; // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    var isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidate()\n    //  - X-Remix-Revalidate (from redirect)\n    var isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    var cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    var cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers\n    var fetchControllers = new Map(); // Track loads based on the order in which they started\n    var incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    var pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions\n    var fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions\n    var fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers\n    var fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    var activeDeferreds = new Map(); // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen(function(_ref) {\n            var historyAction = _ref.action, location = _ref.location;\n            return startNavigation(historyAction, location);\n        }); // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location);\n        }\n        return router;\n    } // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach(function(_, key) {\n            return deleteFetcher(key);\n        });\n    } // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return function() {\n            return subscribers.delete(fn);\n        };\n    } // Update our state and notify the calling context of the change\n    function updateState(newState) {\n        state = _extends({}, state, newState);\n        subscribers.forEach(function(subscriber) {\n            return subscriber(state);\n        });\n    } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState) {\n        var _state$navigation$for;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a submission\n        // - We're past the submitting state and into the loading state\n        // - The location we've finished loading is different from the submission\n        //   location, indicating we redirected from the action (avoids false\n        //   positives for loading/submissionRedirect when actionData returned\n        //   on a prior submission)\n        var isActionReload = state.actionData != null && state.navigation.formMethod != null && state.navigation.state === \"loading\" && ((_state$navigation$for = state.navigation.formAction) == null ? void 0 : _state$navigation$for.split(\"?\")[0]) === location.pathname; // Always preserve any existing loaderData from re-used routes\n        var newLoaderData = newState.loaderData ? {\n            loaderData: mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [])\n        } : {};\n        updateState(_extends({}, isActionReload ? {} : {\n            actionData: null\n        }, newState, newLoaderData, {\n            historyAction: pendingAction,\n            location: location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            // Don't restore on submission navigations\n            restoreScrollPosition: state.navigation.formData ? false : getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset: pendingPreventScrollReset\n        }));\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        } // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    } // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    function navigate(to, opts) {\n        return _async_to_generator(function() {\n            var _normalizeNavigateOptions, path, submission, error, location, historyAction, preventScrollReset;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (typeof to === \"number\") {\n                            init.history.go(to);\n                            return [\n                                2\n                            ];\n                        }\n                        _normalizeNavigateOptions = normalizeNavigateOptions(to, opts), path = _normalizeNavigateOptions.path, submission = _normalizeNavigateOptions.submission, error = _normalizeNavigateOptions.error;\n                        location = createLocation(state.location, path, opts && opts.state);\n                        historyAction = (opts && opts.replace) === true || submission != null ? Action.Replace : Action.Push;\n                        preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n                        return [\n                            4,\n                            startNavigation(historyAction, location, {\n                                submission: submission,\n                                // Send through the formData serialization error if we have one so we can\n                                // render at the right error boundary after we match routes\n                                pendingError: error,\n                                preventScrollReset: preventScrollReset,\n                                replace: opts && opts.replace\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            _state.sent()\n                        ];\n                }\n            });\n        })();\n    } // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        }); // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        } // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        } // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    } // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    function startNavigation(historyAction, location, opts) {\n        return _async_to_generator(function() {\n            var loadingNavigation, matches, _getNotFoundMatches, notFoundMatches, route, error, request, pendingActionData, pendingError, actionOutput, navigation, _ref, shortCircuited, loaderData, errors;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        // Abort any in-progress navigations and start a new one. Unset any ongoing\n                        // uninterrupted revalidations unless told otherwise, since we want this\n                        // new navigation to update history normally\n                        pendingNavigationController && pendingNavigationController.abort();\n                        pendingNavigationController = null;\n                        pendingAction = historyAction;\n                        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,\n                        // and track whether we should reset scroll on completion\n                        saveScrollPosition(state.location, state.matches);\n                        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n                        loadingNavigation = opts && opts.overrideNavigation;\n                        matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing\n                        if (!matches) {\n                            _getNotFoundMatches = getNotFoundMatches(dataRoutes), notFoundMatches = _getNotFoundMatches.matches, route = _getNotFoundMatches.route, error = _getNotFoundMatches.error; // Cancel all pending deferred on 404s since we don't keep any routes\n                            cancelActiveDeferreds();\n                            completeNavigation(location, {\n                                matches: notFoundMatches,\n                                loaderData: {},\n                                errors: _define_property({}, route.id, error)\n                            });\n                            return [\n                                2\n                            ];\n                        } // Short circuit if it's only a hash change\n                        if (isHashChangeOnly(state.location, location)) {\n                            completeNavigation(location, {\n                                matches: matches\n                            });\n                            return [\n                                2\n                            ];\n                        } // Create a controller/Request for this navigation\n                        pendingNavigationController = new AbortController();\n                        request = createRequest(location, pendingNavigationController.signal, opts && opts.submission);\n                        if (!(opts && opts.pendingError)) return [\n                            3,\n                            1\n                        ];\n                        // If we have a pendingError, it means the user attempted a GET submission\n                        // with binary FormData so assign here and skip to handleLoaders.  That\n                        // way we handle calling loaders above the boundary etc.  It's not really\n                        // different from an actionError in that sense.\n                        pendingError = _define_property({}, findNearestBoundary(matches).route.id, opts.pendingError);\n                        return [\n                            3,\n                            3\n                        ];\n                    case 1:\n                        if (!(opts && opts.submission)) return [\n                            3,\n                            3\n                        ];\n                        return [\n                            4,\n                            handleAction(request, location, opts.submission, matches, {\n                                replace: opts.replace\n                            })\n                        ];\n                    case 2:\n                        actionOutput = _state.sent();\n                        if (actionOutput.shortCircuited) {\n                            return [\n                                2\n                            ];\n                        }\n                        pendingActionData = actionOutput.pendingActionData;\n                        pendingError = actionOutput.pendingActionError;\n                        navigation = _extends({\n                            state: \"loading\",\n                            location: location\n                        }, opts.submission);\n                        loadingNavigation = navigation;\n                        _state.label = 3;\n                    case 3:\n                        return [\n                            4,\n                            handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError)\n                        ];\n                    case 4:\n                        _ref = _state.sent(), shortCircuited = _ref.shortCircuited, loaderData = _ref.loaderData, errors = _ref.errors;\n                        if (shortCircuited) {\n                            return [\n                                2\n                            ];\n                        } // Clean up now that the action/loaders have completed.  Don't clean up if\n                        // we short circuited because pendingNavigationController will have already\n                        // been assigned to a new controller for the next navigation\n                        pendingNavigationController = null;\n                        completeNavigation(location, {\n                            matches: matches,\n                            loaderData: loaderData,\n                            errors: errors\n                        });\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    } // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    function handleAction(request, location, submission, matches, opts) {\n        return _async_to_generator(function() {\n            var navigation, result, actionMatch, redirectNavigation, boundaryMatch;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        interruptActiveLoads(); // Put us in a submitting state\n                        navigation = _extends({\n                            state: \"submitting\",\n                            location: location\n                        }, submission);\n                        updateState({\n                            navigation: navigation\n                        }); // Call our action and get the result\n                        actionMatch = getTargetMatch(matches, location);\n                        if (!!actionMatch.route.action) return [\n                            3,\n                            1\n                        ];\n                        result = getMethodNotAllowedResult(location);\n                        return [\n                            3,\n                            3\n                        ];\n                    case 1:\n                        return [\n                            4,\n                            callLoaderOrAction(\"action\", request, actionMatch)\n                        ];\n                    case 2:\n                        result = _state.sent();\n                        if (request.signal.aborted) {\n                            return [\n                                2,\n                                {\n                                    shortCircuited: true\n                                }\n                            ];\n                        }\n                        _state.label = 3;\n                    case 3:\n                        if (!isRedirectResult(result)) return [\n                            3,\n                            5\n                        ];\n                        redirectNavigation = _extends({\n                            state: \"loading\",\n                            location: createLocation(state.location, result.location)\n                        }, submission);\n                        return [\n                            4,\n                            startRedirectNavigation(result, redirectNavigation, opts && opts.replace)\n                        ];\n                    case 4:\n                        _state.sent();\n                        return [\n                            2,\n                            {\n                                shortCircuited: true\n                            }\n                        ];\n                    case 5:\n                        if (isErrorResult(result)) {\n                            // Store off the pending error - we use it to determine which loaders\n                            // to call and will commit it when we complete the navigation\n                            boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the\n                            // action threw an error that'll be rendered in an errorElement, we fall\n                            // back to PUSH so that the user can use the back button to get back to\n                            // the pre-submission form location to try again\n                            if ((opts && opts.replace) !== true) {\n                                pendingAction = Action.Push;\n                            }\n                            return [\n                                2,\n                                {\n                                    pendingActionError: _define_property({}, boundaryMatch.route.id, result.error)\n                                }\n                            ];\n                        }\n                        if (isDeferredResult(result)) {\n                            throw new Error(\"defer() is not supported in actions\");\n                        }\n                        return [\n                            2,\n                            {\n                                pendingActionData: _define_property({}, actionMatch.route.id, result.data)\n                            }\n                        ];\n                }\n            });\n        })();\n    } // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {\n        return _async_to_generator(function() {\n            var loadingNavigation, navigation, _getMatchesToLoad, matchesToLoad, revalidatingFetchers, _ref, results, loaderResults, fetcherResults, redirect, redirectNavigation, _processLoaderData, loaderData, errors, didAbortFetchLoads;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        // Figure out the right navigation we want to use for data loading\n                        loadingNavigation = overrideNavigation;\n                        if (!loadingNavigation) {\n                            navigation = {\n                                state: \"loading\",\n                                location: location,\n                                formMethod: undefined,\n                                formAction: undefined,\n                                formEncType: undefined,\n                                formData: undefined\n                            };\n                            loadingNavigation = navigation;\n                        }\n                        _getMatchesToLoad = _sliced_to_array(getMatchesToLoad(state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches), 2), matchesToLoad = _getMatchesToLoad[0], revalidatingFetchers = _getMatchesToLoad[1]; // Cancel pending deferreds for no-longer-matched routes or routes we're\n                        // about to reload.  Note that if this is an action reload we would have\n                        // already cancelled all pending deferreds so this would be a no-op\n                        cancelActiveDeferreds(function(routeId) {\n                            return !(matches && matches.some(function(m) {\n                                return m.route.id === routeId;\n                            })) || matchesToLoad && matchesToLoad.some(function(m) {\n                                return m.route.id === routeId;\n                            });\n                        }); // Short circuit if we have no loaders to run\n                        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n                            completeNavigation(location, {\n                                matches: matches,\n                                loaderData: mergeLoaderData(state.loaderData, {}, matches),\n                                // Commit pending error if we're short circuiting\n                                errors: pendingError || null,\n                                actionData: pendingActionData || null\n                            });\n                            return [\n                                2,\n                                {\n                                    shortCircuited: true\n                                }\n                            ];\n                        } // If this is an uninterrupted revalidation, we remain in our current idle\n                        // state.  If not, we need to switch to our loading state and load data,\n                        // preserving any new action data or existing action data (in the case of\n                        // a revalidation interrupting an actionReload)\n                        if (!isUninterruptedRevalidation) {\n                            revalidatingFetchers.forEach(function(_ref2) {\n                                var _$_ref2 = _sliced_to_array(_ref2, 1), key = _$_ref2[0];\n                                var fetcher = state.fetchers.get(key);\n                                var revalidatingFetcher = {\n                                    state: \"loading\",\n                                    data: fetcher && fetcher.data,\n                                    formMethod: undefined,\n                                    formAction: undefined,\n                                    formEncType: undefined,\n                                    formData: undefined\n                                };\n                                state.fetchers.set(key, revalidatingFetcher);\n                            });\n                            updateState(_extends({\n                                navigation: loadingNavigation,\n                                actionData: pendingActionData || state.actionData || null\n                            }, revalidatingFetchers.length > 0 ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {}));\n                        }\n                        pendingNavigationLoadId = ++incrementingLoadId;\n                        revalidatingFetchers.forEach(function(_ref3) {\n                            var _$_ref3 = _sliced_to_array(_ref3, 1), key = _$_ref3[0];\n                            return fetchControllers.set(key, pendingNavigationController);\n                        });\n                        return [\n                            4,\n                            callLoadersAndMaybeResolveData(state.matches, matchesToLoad, revalidatingFetchers, request)\n                        ];\n                    case 1:\n                        _ref = _state.sent(), results = _ref.results, loaderResults = _ref.loaderResults, fetcherResults = _ref.fetcherResults;\n                        if (request.signal.aborted) {\n                            return [\n                                2,\n                                {\n                                    shortCircuited: true\n                                }\n                            ];\n                        } // Clean up _after_ loaders have completed.  Don't clean up if we short\n                        // circuited because fetchControllers would have been aborted and\n                        // reassigned to new controllers for the next navigation\n                        revalidatingFetchers.forEach(function(_ref4) {\n                            var _$_ref4 = _sliced_to_array(_ref4, 1), key = _$_ref4[0];\n                            return fetchControllers.delete(key);\n                        }); // If any loaders returned a redirect Response, start a new REPLACE navigation\n                        redirect = findRedirect(results);\n                        if (!redirect) return [\n                            3,\n                            3\n                        ];\n                        redirectNavigation = getLoaderRedirect(state, redirect);\n                        return [\n                            4,\n                            startRedirectNavigation(redirect, redirectNavigation, replace)\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2,\n                            {\n                                shortCircuited: true\n                            }\n                        ];\n                    case 3:\n                        _processLoaderData = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _processLoaderData.loaderData, errors = _processLoaderData.errors; // Wire up subscribers to update loaderData as promises settle\n                        activeDeferreds.forEach(function(deferredData, routeId) {\n                            deferredData.subscribe(function(aborted) {\n                                // Note: No need to updateState here since the TrackedPromise on\n                                // loaderData is stable across resolve/reject\n                                // Remove this instance if we were aborted or if promises have settled\n                                if (aborted || deferredData.done) {\n                                    activeDeferreds.delete(routeId);\n                                }\n                            });\n                        });\n                        markFetchRedirectsDone();\n                        didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n                        return [\n                            2,\n                            _extends({\n                                loaderData: loaderData,\n                                errors: errors\n                            }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {})\n                        ];\n                }\n            });\n        })();\n    }\n    function getFetcher(key) {\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    } // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (typeof AbortController === \"undefined\") {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        var matches = matchRoutes(dataRoutes, href, init.basename);\n        if (!matches) {\n            setFetcherError(key, routeId, new ErrorResponse(404, \"Not Found\", null));\n            return;\n        }\n        var _normalizeNavigateOptions = normalizeNavigateOptions(href, opts, true), path = _normalizeNavigateOptions.path, submission = _normalizeNavigateOptions.submission;\n        var match = getTargetMatch(matches, path);\n        if (submission) {\n            handleFetcherAction(key, routeId, path, match, submission);\n            return;\n        } // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, [\n            path,\n            match\n        ]);\n        handleFetcherLoader(key, routeId, path, match);\n    } // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    function handleFetcherAction(key, routeId, path, match, submission) {\n        return _async_to_generator(function() {\n            var error, existingFetcher, fetcher, abortController, fetchRequest, actionResult, loadingFetcher, redirectNavigation, nextLocation, revalidationRequest, matches, loadId, loadFetcher, _getMatchesToLoad, matchesToLoad, revalidatingFetchers, _ref, results, loaderResults, fetcherResults, redirect, redirectNavigation1, _processLoaderData, loaderData, errors, doneFetcher, didAbortFetchLoads;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        interruptActiveLoads();\n                        fetchLoadMatches.delete(key);\n                        if (!match.route.action) {\n                            error = getMethodNotAllowedResult(path).error;\n                            setFetcherError(key, routeId, error);\n                            return [\n                                2\n                            ];\n                        } // Put this fetcher into it's submitting state\n                        existingFetcher = state.fetchers.get(key);\n                        fetcher = _extends({\n                            state: \"submitting\"\n                        }, submission, {\n                            data: existingFetcher && existingFetcher.data\n                        });\n                        state.fetchers.set(key, fetcher);\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        }); // Call the action for the fetcher\n                        abortController = new AbortController();\n                        fetchRequest = createRequest(path, abortController.signal, submission);\n                        fetchControllers.set(key, abortController);\n                        return [\n                            4,\n                            callLoaderOrAction(\"action\", fetchRequest, match)\n                        ];\n                    case 1:\n                        actionResult = _state.sent();\n                        if (fetchRequest.signal.aborted) {\n                            // We can delete this so long as we weren't aborted by ou our own fetcher\n                            // re-submit which would have put _new_ controller is in fetchControllers\n                            if (fetchControllers.get(key) === abortController) {\n                                fetchControllers.delete(key);\n                            }\n                            return [\n                                2\n                            ];\n                        }\n                        if (!isRedirectResult(actionResult)) return [\n                            3,\n                            3\n                        ];\n                        fetchControllers.delete(key);\n                        fetchRedirectIds.add(key);\n                        loadingFetcher = _extends({\n                            state: \"loading\"\n                        }, submission, {\n                            data: undefined\n                        });\n                        state.fetchers.set(key, loadingFetcher);\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        });\n                        redirectNavigation = _extends({\n                            state: \"loading\",\n                            location: createLocation(state.location, actionResult.location)\n                        }, submission);\n                        return [\n                            4,\n                            startRedirectNavigation(actionResult, redirectNavigation)\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2\n                        ];\n                    case 3:\n                        if (isErrorResult(actionResult)) {\n                            setFetcherError(key, routeId, actionResult.error);\n                            return [\n                                2\n                            ];\n                        }\n                        if (isDeferredResult(actionResult)) {\n                            invariant(false, \"defer() is not supported in actions\");\n                        } // Start the data load for current matches, or the next location if we're\n                        // in the middle of a navigation\n                        nextLocation = state.navigation.location || state.location;\n                        revalidationRequest = createRequest(nextLocation, abortController.signal);\n                        matches = state.navigation.state !== \"idle\" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;\n                        invariant(matches, \"Didn't find any matches after fetcher action\");\n                        loadId = ++incrementingLoadId;\n                        fetchReloadIds.set(key, loadId);\n                        loadFetcher = _extends({\n                            state: \"loading\",\n                            data: actionResult.data\n                        }, submission);\n                        state.fetchers.set(key, loadFetcher);\n                        _getMatchesToLoad = _sliced_to_array(getMatchesToLoad(state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, _define_property({}, match.route.id, actionResult.data), undefined, fetchLoadMatches), 2), matchesToLoad = _getMatchesToLoad[0], revalidatingFetchers = _getMatchesToLoad[1]; // Put all revalidating fetchers into the loading state, except for the\n                        // current fetcher which we want to keep in it's current loading state which\n                        // contains it's action submission info + action data\n                        revalidatingFetchers.filter(function(_ref5) {\n                            var _$_ref5 = _sliced_to_array(_ref5, 1), staleKey = _$_ref5[0];\n                            return staleKey !== key;\n                        }).forEach(function(_ref6) {\n                            var _$_ref6 = _sliced_to_array(_ref6, 1), staleKey = _$_ref6[0];\n                            var existingFetcher = state.fetchers.get(staleKey);\n                            var revalidatingFetcher = {\n                                state: \"loading\",\n                                data: existingFetcher && existingFetcher.data,\n                                formMethod: undefined,\n                                formAction: undefined,\n                                formEncType: undefined,\n                                formData: undefined\n                            };\n                            state.fetchers.set(staleKey, revalidatingFetcher);\n                            fetchControllers.set(staleKey, abortController);\n                        });\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        });\n                        return [\n                            4,\n                            callLoadersAndMaybeResolveData(state.matches, matchesToLoad, revalidatingFetchers, revalidationRequest)\n                        ];\n                    case 4:\n                        _ref = _state.sent(), results = _ref.results, loaderResults = _ref.loaderResults, fetcherResults = _ref.fetcherResults;\n                        if (abortController.signal.aborted) {\n                            return [\n                                2\n                            ];\n                        }\n                        fetchReloadIds.delete(key);\n                        fetchControllers.delete(key);\n                        revalidatingFetchers.forEach(function(_ref7) {\n                            var _$_ref7 = _sliced_to_array(_ref7, 1), staleKey = _$_ref7[0];\n                            return fetchControllers.delete(staleKey);\n                        });\n                        redirect = findRedirect(results);\n                        if (!redirect) return [\n                            3,\n                            6\n                        ];\n                        redirectNavigation1 = getLoaderRedirect(state, redirect);\n                        return [\n                            4,\n                            startRedirectNavigation(redirect, redirectNavigation1)\n                        ];\n                    case 5:\n                        _state.sent();\n                        return [\n                            2\n                        ];\n                    case 6:\n                        _processLoaderData = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _processLoaderData.loaderData, errors = _processLoaderData.errors;\n                        doneFetcher = {\n                            state: \"idle\",\n                            data: actionResult.data,\n                            formMethod: undefined,\n                            formAction: undefined,\n                            formEncType: undefined,\n                            formData: undefined\n                        };\n                        state.fetchers.set(key, doneFetcher);\n                        didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is\n                        // more recent than the navigation, we want the newer data so abort the\n                        // navigation and complete it with the fetcher data\n                        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n                            invariant(pendingAction, \"Expected pending action\");\n                            pendingNavigationController && pendingNavigationController.abort();\n                            completeNavigation(state.navigation.location, {\n                                matches: matches,\n                                loaderData: loaderData,\n                                errors: errors,\n                                fetchers: new Map(state.fetchers)\n                            });\n                        } else {\n                            // otherwise just update with the fetcher data, preserving any existing\n                            // loaderData for loaders that did not need to reload.  We have to\n                            // manually merge here since we aren't going through completeNavigation\n                            updateState(_extends({\n                                errors: errors,\n                                loaderData: mergeLoaderData(state.loaderData, loaderData, matches)\n                            }, didAbortFetchLoads ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {}));\n                            isRevalidationRequired = false;\n                        }\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    function handleFetcherLoader(key, routeId, path, match) {\n        return _async_to_generator(function() {\n            var existingFetcher, loadingFetcher, abortController, fetchRequest, result, redirectNavigation, boundaryMatch, doneFetcher;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state\n                        loadingFetcher = {\n                            state: \"loading\",\n                            formMethod: undefined,\n                            formAction: undefined,\n                            formEncType: undefined,\n                            formData: undefined,\n                            data: existingFetcher && existingFetcher.data\n                        };\n                        state.fetchers.set(key, loadingFetcher);\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        }); // Call the loader for this fetcher route match\n                        abortController = new AbortController();\n                        fetchRequest = createRequest(path, abortController.signal);\n                        fetchControllers.set(key, abortController);\n                        return [\n                            4,\n                            callLoaderOrAction(\"loader\", fetchRequest, match)\n                        ];\n                    case 1:\n                        result = _state.sent();\n                        if (!isDeferredResult(result)) return [\n                            3,\n                            3\n                        ];\n                        return [\n                            4,\n                            resolveDeferredData(result, fetchRequest.signal, true)\n                        ];\n                    case 2:\n                        result = _state.sent() || result;\n                        _state.label = 3;\n                    case 3:\n                        // re-load which would have put _new_ controller is in fetchControllers\n                        if (fetchControllers.get(key) === abortController) {\n                            fetchControllers.delete(key);\n                        }\n                        if (fetchRequest.signal.aborted) {\n                            return [\n                                2\n                            ];\n                        } // If the loader threw a redirect Response, start a new REPLACE navigation\n                        if (!isRedirectResult(result)) return [\n                            3,\n                            5\n                        ];\n                        redirectNavigation = getLoaderRedirect(state, result);\n                        return [\n                            4,\n                            startRedirectNavigation(result, redirectNavigation)\n                        ];\n                    case 4:\n                        _state.sent();\n                        return [\n                            2\n                        ];\n                    case 5:\n                        if (isErrorResult(result)) {\n                            boundaryMatch = findNearestBoundary(state.matches, routeId);\n                            state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n                            // do we need to behave any differently with our non-redirect errors?\n                            // What if it was a non-redirect Response?\n                            updateState({\n                                fetchers: new Map(state.fetchers),\n                                errors: _define_property({}, boundaryMatch.route.id, result.error)\n                            });\n                            return [\n                                2\n                            ];\n                        }\n                        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\"); // Put the fetcher back into an idle state\n                        doneFetcher = {\n                            state: \"idle\",\n                            data: result.data,\n                            formMethod: undefined,\n                            formAction: undefined,\n                            formEncType: undefined,\n                            formData: undefined\n                        };\n                        state.fetchers.set(key, doneFetcher);\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        });\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ function startRedirectNavigation(redirect, navigation, replace) {\n        return _async_to_generator(function() {\n            var redirectHistoryAction;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (redirect.revalidate) {\n                            isRevalidationRequired = true;\n                        }\n                        invariant(navigation.location, \"Expected a location on the redirect navigation\"); // There's no need to abort on redirects, since we don't detect the\n                        // redirect until the action/loaders have settled\n                        pendingNavigationController = null;\n                        redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n                        return [\n                            4,\n                            startNavigation(redirectHistoryAction, navigation.location, {\n                                overrideNavigation: navigation\n                            })\n                        ];\n                    case 1:\n                        _state.sent();\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    }\n    function callLoadersAndMaybeResolveData(currentMatches, matchesToLoad, fetchersToLoad, request) {\n        return _async_to_generator(function() {\n            var results, loaderResults, fetcherResults;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        return [\n                            4,\n                            Promise.all(_to_consumable_array(matchesToLoad.map(function(m) {\n                                return callLoaderOrAction(\"loader\", request, m);\n                            })).concat(_to_consumable_array(fetchersToLoad.map(function(_ref8) {\n                                var _$_ref8 = _sliced_to_array(_ref8, 3), href = _$_ref8[1], match = _$_ref8[2];\n                                return callLoaderOrAction(\"loader\", createRequest(href, request.signal), match);\n                            }))))\n                        ];\n                    case 1:\n                        results = _state.sent();\n                        loaderResults = results.slice(0, matchesToLoad.length);\n                        fetcherResults = results.slice(matchesToLoad.length);\n                        return [\n                            4,\n                            Promise.all([\n                                resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData),\n                                resolveDeferredResults(currentMatches, fetchersToLoad.map(function(_ref9) {\n                                    var _$_ref9 = _sliced_to_array(_ref9, 3), match = _$_ref9[2];\n                                    return match;\n                                }), fetcherResults, request.signal, true)\n                            ])\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2,\n                            {\n                                results: results,\n                                loaderResults: loaderResults,\n                                fetcherResults: fetcherResults\n                            }\n                        ];\n                }\n            });\n        })();\n    }\n    function interruptActiveLoads() {\n        var // revalidation\n        _cancelledDeferredRoutes;\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for\n        (_cancelledDeferredRoutes = cancelledDeferredRoutes).push.apply(_cancelledDeferredRoutes, _to_consumable_array(cancelActiveDeferreds())); // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach(function(_, key) {\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function setFetcherError(key, routeId, error) {\n        var boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: _define_property({}, boundaryMatch.route.id, error),\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function deleteFetcher(key) {\n        if (fetchControllers.has(key)) abortFetcher(key);\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        state.fetchers.delete(key);\n    }\n    function abortFetcher(key) {\n        var controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var key = _step.value;\n                var fetcher = getFetcher(key);\n                var doneFetcher = {\n                    state: \"idle\",\n                    data: fetcher.data,\n                    formMethod: undefined,\n                    formAction: undefined,\n                    formEncType: undefined,\n                    formData: undefined\n                };\n                state.fetchers.set(key, doneFetcher);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    function markFetchRedirectsDone() {\n        var doneKeys = [];\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = fetchRedirectIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var key = _step.value;\n                var fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    fetchRedirectIds.delete(key);\n                    doneKeys.push(key);\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        markFetchersDone(doneKeys);\n    }\n    function abortStaleFetchLoads(landedId) {\n        var yeetedKeys = [];\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = fetchReloadIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], id = _step_value[1];\n                if (id < landedId) {\n                    var fetcher = state.fetchers.get(key);\n                    invariant(fetcher, \"Expected fetcher: \" + key);\n                    if (fetcher.state === \"loading\") {\n                        abortFetcher(key);\n                        fetchReloadIds.delete(key);\n                        yeetedKeys.push(key);\n                    }\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function cancelActiveDeferreds(predicate) {\n        var cancelledRouteIds = [];\n        activeDeferreds.forEach(function(dfd, routeId) {\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    } // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || function(location) {\n            return location.key;\n        }; // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            var y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return function() {\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n            var userMatches = matches.map(function(m) {\n                return createUseMatchesMatch(m, state.loaderData);\n            });\n            var key = getScrollRestorationKey(location, userMatches) || location.key;\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n            var userMatches = matches.map(function(m) {\n                return createUseMatchesMatch(m, state.loaderData);\n            });\n            var key = getScrollRestorationKey(location, userMatches) || location.key;\n            var y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    router = {\n        get basename () {\n            return init.basename;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        initialize: initialize,\n        subscribe: subscribe,\n        enableScrollRestoration: enableScrollRestoration,\n        navigate: navigate,\n        fetch: fetch,\n        revalidate: revalidate,\n        createHref: createHref,\n        getFetcher: getFetcher,\n        deleteFetcher: deleteFetcher,\n        dispose: dispose,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds\n    };\n    return router;\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nfunction unstable_createStaticHandler(routes) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to unstable_createStaticHandler\");\n    var dataRoutes = convertRoutesToDataRoutes(routes);\n    function query(request) {\n        return _async_to_generator(function() {\n            var _ref, location, result;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        return [\n                            4,\n                            queryImpl(request)\n                        ];\n                    case 1:\n                        _ref = _state.sent(), location = _ref.location, result = _ref.result;\n                        if (_instanceof(result, Response)) {\n                            return [\n                                2,\n                                result\n                            ];\n                        } // When returning StaticHandlerContext, we patch back in the location here\n                        // since we need it for React Context.  But this helps keep our submit and\n                        // loadRouteData operating on a Request instead of a Location\n                        return [\n                            2,\n                            _extends({\n                                location: location\n                            }, result)\n                        ];\n                }\n            });\n        })();\n    }\n    function queryRoute(request, routeId) {\n        return _async_to_generator(function() {\n            var result, error, routeData, value;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        return [\n                            4,\n                            queryImpl(request, routeId)\n                        ];\n                    case 1:\n                        result = _state.sent().result;\n                        if (_instanceof(result, Response)) {\n                            return [\n                                2,\n                                result\n                            ];\n                        }\n                        error = result.errors ? Object.values(result.errors)[0] : undefined;\n                        if (error !== undefined) {\n                            // While we always re-throw Responses returned from loaders/actions\n                            // directly for route requests and prevent the unwrapping into an\n                            // ErrorResponse, we still need this for error cases _prior_ the\n                            // execution of the loader/action, such as a 404/405 error.\n                            if (isRouteErrorResponse(error)) {\n                                return [\n                                    2,\n                                    new Response(error.data, {\n                                        status: error.status,\n                                        statusText: error.statusText\n                                    })\n                                ];\n                            } // If we got back result.errors, that means the loader/action threw\n                            // _something_ that wasn't a Response, but it's not guaranteed/required\n                            // to be an `instanceof Error` either, so we have to use throw here to\n                            // preserve the \"error\" state outside of queryImpl.\n                            throw error;\n                        } // Pick off the right state value to return\n                        routeData = [\n                            result.actionData,\n                            result.loaderData\n                        ].find(function(v) {\n                            return v;\n                        });\n                        value = Object.values(routeData || {})[0];\n                        if (isRouteErrorResponse(value)) {\n                            return [\n                                2,\n                                new Response(value.data, {\n                                    status: value.status,\n                                    statusText: value.statusText\n                                })\n                            ];\n                        }\n                        return [\n                            2,\n                            value\n                        ];\n                }\n            });\n        })();\n    }\n    function queryImpl(request, routeId) {\n        return _async_to_generator(function() {\n            var _matchRequest, location, matches, shortCircuitState, result, result1, e;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        invariant(request.method !== \"HEAD\", \"query()/queryRoute() do not support HEAD requests\");\n                        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n                        _matchRequest = matchRequest(request, routeId), location = _matchRequest.location, matches = _matchRequest.matches, shortCircuitState = _matchRequest.shortCircuitState;\n                        _state.label = 1;\n                    case 1:\n                        _state.trys.push([\n                            1,\n                            5,\n                            ,\n                            6\n                        ]);\n                        if (shortCircuitState) {\n                            return [\n                                2,\n                                {\n                                    location: location,\n                                    result: shortCircuitState\n                                }\n                            ];\n                        }\n                        if (!(request.method !== \"GET\")) return [\n                            3,\n                            3\n                        ];\n                        return [\n                            4,\n                            submit(request, matches, getTargetMatch(matches, location), routeId != null)\n                        ];\n                    case 2:\n                        result = _state.sent();\n                        return [\n                            2,\n                            {\n                                location: location,\n                                result: result\n                            }\n                        ];\n                    case 3:\n                        return [\n                            4,\n                            loadRouteData(request, matches, routeId != null)\n                        ];\n                    case 4:\n                        result1 = _state.sent();\n                        return [\n                            2,\n                            {\n                                location: location,\n                                result: _extends({}, result1, {\n                                    actionData: null,\n                                    actionHeaders: {}\n                                })\n                            }\n                        ];\n                    case 5:\n                        e = _state.sent();\n                        if (_instanceof(e, Response)) {\n                            return [\n                                2,\n                                {\n                                    location: location,\n                                    result: e\n                                }\n                            ];\n                        }\n                        throw e;\n                    case 6:\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    }\n    function submit(request, matches, actionMatch, isRouteRequest) {\n        return _async_to_generator(function() {\n            var result, href, method, boundaryMatch, boundaryMatch1, context, context1;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!!actionMatch.route.action) return [\n                            3,\n                            1\n                        ];\n                        href = createHref(new URL(request.url));\n                        result = getMethodNotAllowedResult(href);\n                        return [\n                            3,\n                            3\n                        ];\n                    case 1:\n                        return [\n                            4,\n                            callLoaderOrAction(\"action\", request, actionMatch, true, isRouteRequest)\n                        ];\n                    case 2:\n                        result = _state.sent();\n                        if (request.signal.aborted) {\n                            method = isRouteRequest ? \"queryRoute\" : \"query\";\n                            throw new Error(method + \"() call aborted\");\n                        }\n                        _state.label = 3;\n                    case 3:\n                        if (isRedirectResult(result)) {\n                            // Uhhhh - this should never happen, we should always throw these from\n                            // calLoaderOrAction, but the type narrowing here keeps TS happy and we\n                            // can get back on the \"throw all redirect responses\" train here should\n                            // this ever happen :/\n                            throw new Response(null, {\n                                status: result.status,\n                                headers: {\n                                    Location: result.location\n                                }\n                            });\n                        }\n                        if (isDeferredResult(result)) {\n                            throw new Error(\"defer() is not supported in actions\");\n                        }\n                        if (isRouteRequest) {\n                            if (isErrorResult(result)) {\n                                boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n                                return [\n                                    2,\n                                    {\n                                        matches: [\n                                            actionMatch\n                                        ],\n                                        loaderData: {},\n                                        actionData: null,\n                                        errors: _define_property({}, boundaryMatch.route.id, result.error),\n                                        // Note: statusCode + headers are unused here since queryRoute will\n                                        // return the raw Response or value\n                                        statusCode: 500,\n                                        loaderHeaders: {},\n                                        actionHeaders: {}\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {\n                                    matches: [\n                                        actionMatch\n                                    ],\n                                    loaderData: {},\n                                    actionData: _define_property({}, actionMatch.route.id, result.data),\n                                    errors: null,\n                                    // Note: statusCode + headers are unused here since queryRoute will\n                                    // return the raw Response or value\n                                    statusCode: 200,\n                                    loaderHeaders: {},\n                                    actionHeaders: {}\n                                }\n                            ];\n                        }\n                        if (!isErrorResult(result)) return [\n                            3,\n                            5\n                        ];\n                        // Store off the pending error - we use it to determine which loaders\n                        // to call and will commit it when we complete the navigation\n                        boundaryMatch1 = findNearestBoundary(matches, actionMatch.route.id);\n                        return [\n                            4,\n                            loadRouteData(request, matches, isRouteRequest, _define_property({}, boundaryMatch1.route.id, result.error))\n                        ];\n                    case 4:\n                        context = _state.sent();\n                        return [\n                            2,\n                            _extends({}, context, {\n                                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                                actionData: null,\n                                actionHeaders: _extends({}, result.headers ? _define_property({}, actionMatch.route.id, result.headers) : {})\n                            })\n                        ];\n                    case 5:\n                        return [\n                            4,\n                            loadRouteData(request, matches, isRouteRequest)\n                        ];\n                    case 6:\n                        context1 = _state.sent();\n                        return [\n                            2,\n                            _extends({}, context1, result.statusCode ? {\n                                statusCode: result.statusCode\n                            } : {}, {\n                                actionData: _define_property({}, actionMatch.route.id, result.data),\n                                actionHeaders: _extends({}, result.headers ? _define_property({}, actionMatch.route.id, result.headers) : {})\n                            })\n                        ];\n                }\n            });\n        })();\n    }\n    function loadRouteData(request, matches, isRouteRequest, pendingActionError) {\n        return _async_to_generator(function() {\n            var matchesToLoad, results, method, context;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        matchesToLoad = getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]).filter(function(m) {\n                            return m.route.loader;\n                        }); // Short circuit if we have no loaders to run\n                        if (matchesToLoad.length === 0) {\n                            return [\n                                2,\n                                {\n                                    matches: matches,\n                                    loaderData: {},\n                                    errors: pendingActionError || null,\n                                    statusCode: 200,\n                                    loaderHeaders: {}\n                                }\n                            ];\n                        }\n                        return [\n                            4,\n                            Promise.all(_to_consumable_array(matchesToLoad.map(function(m) {\n                                return callLoaderOrAction(\"loader\", request, m, true, isRouteRequest);\n                            })))\n                        ];\n                    case 1:\n                        results = _state.sent();\n                        if (request.signal.aborted) {\n                            method = isRouteRequest ? \"queryRoute\" : \"query\";\n                            throw new Error(method + \"() call aborted\");\n                        } // Can't do anything with these without the Remix side of things, so just\n                        // cancel them for now\n                        results.forEach(function(result) {\n                            if (isDeferredResult(result)) {\n                                result.deferredData.cancel();\n                            }\n                        }); // Process and commit output from loaders\n                        context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError);\n                        return [\n                            2,\n                            _extends({}, context, {\n                                matches: matches\n                            })\n                        ];\n                }\n            });\n        })();\n    }\n    function matchRequest(req, routeId) {\n        var url = new URL(req.url);\n        var location = createLocation(\"\", createPath(url), null, \"default\");\n        var matches = matchRoutes(dataRoutes, location);\n        if (matches && routeId) {\n            matches = matches.filter(function(m) {\n                return m.route.id === routeId;\n            });\n        } // Short circuit with a 404 if we match nothing\n        if (!matches) {\n            var _getNotFoundMatches = getNotFoundMatches(dataRoutes), notFoundMatches = _getNotFoundMatches.matches, route = _getNotFoundMatches.route, error = _getNotFoundMatches.error;\n            return {\n                location: location,\n                matches: notFoundMatches,\n                shortCircuitState: {\n                    matches: notFoundMatches,\n                    loaderData: {},\n                    actionData: null,\n                    errors: _define_property({}, route.id, error),\n                    statusCode: 404,\n                    loaderHeaders: {},\n                    actionHeaders: {}\n                }\n            };\n        }\n        return {\n            location: location,\n            matches: matches\n        };\n    }\n    return {\n        dataRoutes: dataRoutes,\n        query: query,\n        queryRoute: queryRoute\n    };\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    var newContext = _extends({}, context, {\n        statusCode: 500,\n        errors: _define_property({}, context._deepestRenderedBoundaryId || routes[0].id, error)\n    });\n    return newContext;\n} // Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(to, opts, isFetcher) {\n    if (isFetcher === void 0) {\n        isFetcher = false;\n    }\n    var path = typeof to === \"string\" ? to : createPath(to); // Return location verbatim on non-submission navigations\n    if (!opts || !(\"formMethod\" in opts) && !(\"formData\" in opts)) {\n        return {\n            path: path\n        };\n    } // Create a Submission on non-GET navigations\n    if (opts.formMethod != null && opts.formMethod !== \"get\") {\n        return {\n            path: path,\n            submission: {\n                formMethod: opts.formMethod,\n                formAction: createHref(parsePath(path)),\n                formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n                formData: opts.formData\n            }\n        };\n    } // No formData to flatten for GET submission\n    if (!opts.formData) {\n        return {\n            path: path\n        };\n    } // Flatten submission onto URLSearchParams for GET submissions\n    var parsedPath = parsePath(path);\n    try {\n        var searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to\n        // navigation GET submissions which run all loaders), we need to preserve\n        // any incoming ?index params\n        if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n            searchParams.append(\"index\", \"\");\n        }\n        parsedPath.search = \"?\" + searchParams;\n    } catch (e) {\n        return {\n            path: path,\n            error: new ErrorResponse(400, \"Bad Request\", \"Cannot submit binary form data using GET\")\n        };\n    }\n    return {\n        path: createPath(parsedPath)\n    };\n}\nfunction getLoaderRedirect(state, redirect) {\n    var _state_navigation = state.navigation, formMethod = _state_navigation.formMethod, formAction = _state_navigation.formAction, formEncType = _state_navigation.formEncType, formData = _state_navigation.formData;\n    var navigation = {\n        state: \"loading\",\n        location: createLocation(state.location, redirect.location),\n        formMethod: formMethod || undefined,\n        formAction: formAction || undefined,\n        formEncType: formEncType || undefined,\n        formData: formData || undefined\n    };\n    return navigation;\n} // Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    var boundaryMatches = matches;\n    if (boundaryId) {\n        var index = matches.findIndex(function(m) {\n            return m.route.id === boundaryId;\n        });\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {\n    var actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : null; // Pick navigation matches that are net-new or qualify for revalidation\n    var boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    var boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    var navigationMatches = boundaryMatches.filter(function(match, index) {\n        return match.route.loader != null && (isNewLoader(state.loaderData, state.matches[index], match) || // If this route had a pending deferred cancelled it must be revalidated\n        cancelledDeferredRoutes.some(function(id) {\n            return id === match.route.id;\n        }) || shouldRevalidateLoader(state.location, state.matches[index], submission, location, match, isRevalidationRequired, actionResult));\n    }); // Pick fetcher.loads that need to be revalidated\n    var revalidatingFetchers = [];\n    fetchLoadMatches && fetchLoadMatches.forEach(function(_ref10, key) {\n        var _$_ref10 = _sliced_to_array(_ref10, 2), href = _$_ref10[0], match = _$_ref10[1];\n        // This fetcher was cancelled from a prior action submission - force reload\n        if (cancelledFetcherLoads.includes(key)) {\n            revalidatingFetchers.push([\n                key,\n                href,\n                match\n            ]);\n        } else if (isRevalidationRequired) {\n            var shouldRevalidate = shouldRevalidateLoader(href, match, submission, href, match, isRevalidationRequired, actionResult);\n            if (shouldRevalidate) {\n                revalidatingFetchers.push([\n                    key,\n                    href,\n                    match\n                ]);\n            }\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    var isNew = !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    var isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    var currentPath = currentMatch.route.path;\n    return currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"];\n}\nfunction shouldRevalidateLoader(currentLocation, currentMatch, submission, location, match, isRevalidationRequired, actionResult) {\n    var currentUrl = createURL(currentLocation);\n    var currentParams = currentMatch.params;\n    var nextUrl = createURL(location);\n    var nextParams = match.params; // This is the default implementation as to when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    // Note that fetchers always provide the same current/next locations so the\n    // URL-based checks here don't apply to fetcher shouldRevalidate calls\n    var defaultShouldRevalidate = isNewRouteInstance(currentMatch, match) || // Clicked the same link, resubmitted a GET form\n    currentUrl.toString() === nextUrl.toString() || // Search params affect all loaders\n    currentUrl.search !== nextUrl.search || // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate\n    isRevalidationRequired;\n    if (match.route.shouldRevalidate) {\n        var routeChoice = match.route.shouldRevalidate(_extends({\n            currentUrl: currentUrl,\n            currentParams: currentParams,\n            nextUrl: nextUrl,\n            nextParams: nextParams\n        }, submission, {\n            actionResult: actionResult,\n            defaultShouldRevalidate: defaultShouldRevalidate\n        }));\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return defaultShouldRevalidate;\n}\nfunction callLoaderOrAction(type, request, match, skipRedirects, isRouteRequest) {\n    return _async_to_generator(function() {\n        var resultType, result, reject, abortPromise, onReject, handler, e, status, location, data, contentType;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (skipRedirects === void 0) {\n                        skipRedirects = false;\n                    }\n                    if (isRouteRequest === void 0) {\n                        isRouteRequest = false;\n                    }\n                    abortPromise = new Promise(function(_, r) {\n                        return reject = r;\n                    });\n                    onReject = function() {\n                        return reject();\n                    };\n                    request.signal.addEventListener(\"abort\", onReject);\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        4,\n                        5\n                    ]);\n                    handler = match.route[type];\n                    invariant(handler, \"Could not find the \" + type + \" to run on the \\\"\" + match.route.id + \"\\\" route\");\n                    return [\n                        4,\n                        Promise.race([\n                            handler({\n                                request: request,\n                                params: match.params\n                            }),\n                            abortPromise\n                        ])\n                    ];\n                case 2:\n                    result = _state.sent();\n                    return [\n                        3,\n                        5\n                    ];\n                case 3:\n                    e = _state.sent();\n                    resultType = ResultType.error;\n                    result = e;\n                    return [\n                        3,\n                        5\n                    ];\n                case 4:\n                    request.signal.removeEventListener(\"abort\", onReject);\n                    return [\n                        7\n                    ];\n                case 5:\n                    if (!_instanceof(result, Response)) return [\n                        3,\n                        10\n                    ];\n                    // Process redirects\n                    status = result.status;\n                    location = result.headers.get(\"Location\"); // For SSR single-route requests, we want to hand Responses back directly\n                    // without unwrapping\n                    if (isRouteRequest) {\n                        throw result;\n                    }\n                    if (status >= 300 && status <= 399 && location != null) {\n                        // Don't process redirects in the router during SSR document requests.\n                        // Instead, throw the Response and let the server handle it with an HTTP\n                        // redirect\n                        if (skipRedirects) {\n                            throw result;\n                        }\n                        return [\n                            2,\n                            {\n                                type: ResultType.redirect,\n                                status: status,\n                                location: location,\n                                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null\n                            }\n                        ];\n                    }\n                    contentType = result.headers.get(\"Content-Type\");\n                    if (!(contentType && contentType.startsWith(\"application/json\"))) return [\n                        3,\n                        7\n                    ];\n                    return [\n                        4,\n                        result.json()\n                    ];\n                case 6:\n                    data = _state.sent();\n                    return [\n                        3,\n                        9\n                    ];\n                case 7:\n                    return [\n                        4,\n                        result.text()\n                    ];\n                case 8:\n                    data = _state.sent();\n                    _state.label = 9;\n                case 9:\n                    if (resultType === ResultType.error) {\n                        return [\n                            2,\n                            {\n                                type: resultType,\n                                error: new ErrorResponse(status, result.statusText, data),\n                                headers: result.headers\n                            }\n                        ];\n                    }\n                    return [\n                        2,\n                        {\n                            type: ResultType.data,\n                            data: data,\n                            statusCode: result.status,\n                            headers: result.headers\n                        }\n                    ];\n                case 10:\n                    if (resultType === ResultType.error) {\n                        return [\n                            2,\n                            {\n                                type: resultType,\n                                error: result\n                            }\n                        ];\n                    }\n                    if (_instanceof(result, DeferredData)) {\n                        return [\n                            2,\n                            {\n                                type: ResultType.deferred,\n                                deferredData: result\n                            }\n                        ];\n                    }\n                    return [\n                        2,\n                        {\n                            type: ResultType.data,\n                            data: result\n                        }\n                    ];\n            }\n        });\n    })();\n}\nfunction createRequest(location, signal, submission) {\n    var url = createURL(location).toString();\n    var init = {\n        signal: signal\n    };\n    if (submission) {\n        var formMethod = submission.formMethod, formEncType = submission.formEncType, formData = submission.formData;\n        init.method = formMethod.toUpperCase();\n        init.body = formEncType === \"application/x-www-form-urlencoded\" ? convertFormDataToSearchParams(formData) : formData;\n    } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    var searchParams = new URLSearchParams();\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = formData.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];\n            invariant(typeof value === \"string\", 'File inputs are not supported with encType \"application/x-www-form-urlencoded\", ' + 'please use \"multipart/form-data\" instead.');\n            searchParams.append(key, value);\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return searchParams;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    var loaderData = {};\n    var errors = null;\n    var statusCode;\n    var foundError = false;\n    var loaderHeaders = {}; // Process loader results into state.loaderData/state.errors\n    results.forEach(function(result, index) {\n        var id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            var boundaryMatch = findNearestBoundary(matches, id);\n            var error = result.error; // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = Object.assign(errors || {}, _define_property({}, boundaryMatch.route.id, error)); // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else if (isDeferredResult(result)) {\n            activeDeferreds && activeDeferreds.set(id, result.deferredData);\n            loaderData[id] = result.deferredData.data; // TODO: Add statusCode/headers once we wire up streaming in Remix\n        } else {\n            loaderData[id] = result.data; // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    }); // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here\n    if (pendingError) {\n        errors = pendingError;\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors,\n        statusCode: statusCode || 200,\n        loaderHeaders: loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    var _processRouteLoaderData = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds), loaderData = _processRouteLoaderData.loaderData, errors = _processRouteLoaderData.errors; // Process results from our revalidating fetchers\n    for(var index = 0; index < revalidatingFetchers.length; index++){\n        var _revalidatingFetchers_index = _sliced_to_array(revalidatingFetchers[index], 3), key = _revalidatingFetchers_index[0], match = _revalidatingFetchers_index[2];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        var result = fetcherResults[index]; // Process fetcher non-redirect errors\n        if (isErrorResult(result)) {\n            var boundaryMatch = findNearestBoundary(state.matches, match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, _define_property({}, boundaryMatch.route.id, result.error));\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            throw new Error(\"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            throw new Error(\"Unhandled fetcher deferred data\");\n        } else {\n            var doneFetcher = {\n                state: \"idle\",\n                data: result.data,\n                formMethod: undefined,\n                formAction: undefined,\n                formEncType: undefined,\n                formData: undefined\n            };\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches) {\n    var mergedLoaderData = _extends({}, newLoaderData);\n    matches.forEach(function(match) {\n        var id = match.route.id;\n        if (newLoaderData[id] === undefined && loaderData[id] !== undefined) {\n            mergedLoaderData[id] = loaderData[id];\n        }\n    });\n    return mergedLoaderData;\n} // Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    var eligibleMatches = routeId ? matches.slice(0, matches.findIndex(function(m) {\n        return m.route.id === routeId;\n    }) + 1) : _to_consumable_array(matches);\n    return eligibleMatches.reverse().find(function(m) {\n        return m.route.hasErrorBoundary === true;\n    }) || matches[0];\n}\nfunction getNotFoundMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    var route = routes.find(function(r) {\n        return r.index || r.path === \"\" || r.path === \"/\";\n    }) || {\n        id: \"__shim-404-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route: route\n            }\n        ],\n        route: route,\n        error: new ErrorResponse(404, \"Not Found\", null)\n    };\n}\nfunction getMethodNotAllowedResult(path) {\n    var href = typeof path === \"string\" ? path : createHref(path);\n    console.warn(\"You're trying to submit to a route that does not have an action.  To \" + \"fix this, please add an `action` function to the route for \" + (\"[\" + href + \"]\"));\n    return {\n        type: ResultType.error,\n        error: new ErrorResponse(405, \"Method Not Allowed\", \"No action found for [\" + href + \"]\")\n    };\n} // Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(var i = results.length - 1; i >= 0; i--){\n        var result = results[i];\n        if (isRedirectResult(result)) {\n            return result;\n        }\n    }\n} // Create an href to represent a \"server\" URL without the hash\nfunction createHref(location) {\n    return (location.pathname || \"\") + (location.search || \"\");\n}\nfunction isHashChangeOnly(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {\n    return _async_to_generator(function() {\n        var _loop, index;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _loop = function(index) {\n                        var result, match, currentMatch, isRevalidatingLoader;\n                        return _ts_generator(this, function(_state) {\n                            switch(_state.label){\n                                case 0:\n                                    result = results[index];\n                                    match = matchesToLoad[index];\n                                    currentMatch = currentMatches.find(function(m) {\n                                        return m.route.id === match.route.id;\n                                    });\n                                    isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n                                    if (!(isDeferredResult(result) && (isFetcher || isRevalidatingLoader))) return [\n                                        3,\n                                        2\n                                    ];\n                                    // Note: we do not have to touch activeDeferreds here since we race them\n                                    // against the signal in resolveDeferredData and they'll get aborted\n                                    // there if needed\n                                    return [\n                                        4,\n                                        resolveDeferredData(result, signal, isFetcher).then(function(result) {\n                                            if (result) {\n                                                results[index] = result || results[index];\n                                            }\n                                        })\n                                    ];\n                                case 1:\n                                    _state.sent();\n                                    _state.label = 2;\n                                case 2:\n                                    return [\n                                        2\n                                    ];\n                            }\n                        });\n                    };\n                    index = 0;\n                    _state.label = 1;\n                case 1:\n                    if (!(index < results.length)) return [\n                        3,\n                        4\n                    ];\n                    return [\n                        5,\n                        _ts_values(_loop(index))\n                    ];\n                case 2:\n                    _state.sent();\n                    _state.label = 3;\n                case 3:\n                    index++;\n                    return [\n                        3,\n                        1\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\nfunction resolveDeferredData(result, signal, unwrap) {\n    return _async_to_generator(function() {\n        var aborted;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (unwrap === void 0) {\n                        unwrap = false;\n                    }\n                    return [\n                        4,\n                        result.deferredData.resolveData(signal)\n                    ];\n                case 1:\n                    aborted = _state.sent();\n                    if (aborted) {\n                        return [\n                            2\n                        ];\n                    }\n                    if (unwrap) {\n                        try {\n                            return [\n                                2,\n                                {\n                                    type: ResultType.data,\n                                    data: result.deferredData.unwrappedData\n                                }\n                            ];\n                        } catch (e) {\n                            // Handle any TrackedPromise._error values encountered while unwrapping\n                            return [\n                                2,\n                                {\n                                    type: ResultType.error,\n                                    error: e\n                                }\n                            ];\n                        }\n                    }\n                    return [\n                        2,\n                        {\n                            type: ResultType.data,\n                            data: result.deferredData.data\n                        }\n                    ];\n            }\n        });\n    })();\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some(function(v) {\n        return v === \"\";\n    });\n} // Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(match, loaderData) {\n    var route = match.route, pathname = match.pathname, params = match.params;\n    return {\n        id: route.id,\n        pathname: pathname,\n        params: params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction getTargetMatch(matches, location) {\n    var search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && !hasNakedIndexQuery(search || \"\")) {\n        return matches.slice(-2)[0];\n    }\n    return matches.slice(-1)[0];\n}\nfunction createURL(location) {\n    var base = typeof window !== \"undefined\" && typeof window.location !== \"undefined\" ? window.location.origin : \"unknown://unknown\";\n    var href = typeof location === \"string\" ? location : createHref(location);\n    return new URL(href, base);\n} //#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcm91dGVyL2Rpc3Qvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7O0NBRUcsT0FDU0EsT0FBWjtDQUFBLFNBQVlBLE1BQVosRUFBa0I7SUFDaEI7Ozs7OztHQU1HLEdBQ0hBLE1BQUE7SUFFQTs7OztHQUlHLEdBQ0hBLE1BQUE7SUFFQTs7O0dBR0csR0FDSEEsTUFBQTtBQUNELENBdEJELEVBQVlBLE1BQU0sS0FBTkEsTUFBTSxHQXNCakIsR0F0QmlCLENBQWxCO0FBa0tBLElBQU1DLGlCQUFpQixHQUFHLFVBQTFCO0FBK0JBOzs7Q0FHRyxHQUNhLFNBQUFDLG1CQUFBLENBQ2RDLE9BRGMsRUFDb0I7SUFBQSxJQUFsQ0EsT0FBa0M7UUFBbENBLE9BQWtDLEdBQUYsRUFBRTtJQUFBO0lBRWxDLElBQUksa0RBQUVDLGNBQWMsd0NBQUc7UUFBQyxHQUFEO0tBQW5CLG1EQUEwQkMsWUFBMUIsc0JBQTZERixPQUFqRSxXQUE0Q0csUUFBUSxrQ0FBRztJQUN2RCxJQUFJQyxPQUFKLENBSGtDO0lB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QixHQUVJLG1CQUhOO0lBSUEsSUFBSS9hLElBQUksR0FBRyxPQUFPckMsUUFBUCxLQUFvQixRQUFwQixHQUErQkEsUUFBL0IsR0FBMENRLFVBQVUsQ0FBQ1IsUUFBRCxDQUEvRDtJQUNBLE9BQU8sSUFBSTBaLEdBQUosQ0FBUXJYLElBQVIsRUFBY0gsSUFBZCxDQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL2hpc3RvcnkudHM/YmM4MiIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL3V0aWxzLnRzPzM4ZjEiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi9yb3V0ZXIudHM/NTA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvbiB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBQb3AgPSBcIlBPUFwiLFxuXG4gIC8qKlxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cbiAgICovXG4gIFB1c2ggPSBcIlBVU0hcIixcblxuICAvKipcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxuICAgKi9cbiAgUmVwbGFjZSA9IFwiUkVQTEFDRVwiLFxufVxuXG4vKipcbiAqIFRoZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCB2YWx1ZXMgb2YgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aCB7XG4gIC8qKlxuICAgKiBBIFVSTCBwYXRobmFtZSwgYmVnaW5uaW5nIHdpdGggYSAvLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgc2VhcmNoIHN0cmluZywgYmVnaW5uaW5nIHdpdGggYSA/LlxuICAgKi9cbiAgc2VhcmNoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIGZyYWdtZW50IGlkZW50aWZpZXIsIGJlZ2lubmluZyB3aXRoIGEgIy5cbiAgICovXG4gIGhhc2g6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBlbnRyeSBpbiBhIGhpc3Rvcnkgc3RhY2suIEEgbG9jYXRpb24gY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBVUkwgcGF0aCwgYXMgd2VsbCBhcyBwb3NzaWJseSBzb21lIGFyYml0cmFyeSBzdGF0ZSBhbmQgYSBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb24gZXh0ZW5kcyBQYXRoIHtcbiAgLyoqXG4gICAqIEEgdmFsdWUgb2YgYXJiaXRyYXJ5IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uXG4gICAqL1xuICBzdGF0ZTogYW55O1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uIE1heSBiZSB1c2VkIHRvIHNhZmVseSBzdG9yZVxuICAgKiBhbmQgcmV0cmlldmUgZGF0YSBpbiBzb21lIG90aGVyIHN0b3JhZ2UgQVBJLCBsaWtlIGBsb2NhbFN0b3JhZ2VgLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIHZhbHVlIGlzIGFsd2F5cyBcImRlZmF1bHRcIiBvbiB0aGUgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICovXG4gIGtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBjaGFuZ2UuXG4gICAqL1xuICBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIG5ldyBsb2NhdGlvbi5cbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgbm90aWZpY2F0aW9ucyBhYm91dCBsb2NhdGlvbiBjaGFuZ2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3RlbmVyIHtcbiAgKHVwZGF0ZTogVXBkYXRlKTogdm9pZDtcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBsb2NhdGlvbiB0aGF0IGlzIHRoZSBkZXN0aW5hdGlvbiBvZiBzb21lIG5hdmlnYXRpb24sIGVpdGhlciB2aWFcbiAqIGBoaXN0b3J5LnB1c2hgIG9yIGBoaXN0b3J5LnJlcGxhY2VgLiBNYXkgYmUgZWl0aGVyIGEgVVJMIG9yIHRoZSBwaWVjZXMgb2YgYVxuICogVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFRvID0gc3RyaW5nIHwgUGFydGlhbDxQYXRoPjtcblxuLyoqXG4gKiBBIGhpc3RvcnkgaXMgYW4gaW50ZXJmYWNlIHRvIHRoZSBuYXZpZ2F0aW9uIHN0YWNrLiBUaGUgaGlzdG9yeSBzZXJ2ZXMgYXMgdGhlXG4gKiBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBhcyB3ZWxsIGFzIHByb3ZpZGVzIGEgc2V0IG9mXG4gKiBtZXRob2RzIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hhbmdlIGl0LlxuICpcbiAqIEl0IGlzIHNpbWlsYXIgdG8gdGhlIERPTSdzIGB3aW5kb3cuaGlzdG9yeWAgb2JqZWN0LCBidXQgd2l0aCBhIHNtYWxsZXIsIG1vcmVcbiAqIGZvY3VzZWQgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhpc3Rvcnkge1xuICAvKipcbiAgICogVGhlIGxhc3QgYWN0aW9uIHRoYXQgbW9kaWZpZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgd2lsbCBhbHdheXMgYmVcbiAgICogQWN0aW9uLlBvcCB3aGVuIGEgaGlzdG9yeSBpbnN0YW5jZSBpcyBmaXJzdCBjcmVhdGVkLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbGlkIGhyZWYgZm9yIHRoZSBnaXZlbiBgdG9gIHZhbHVlIHRoYXQgbWF5IGJlIHVzZWQgYXNcbiAgICogdGhlIHZhbHVlIG9mIGFuIDxhIGhyZWY+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlSHJlZih0bzogVG8pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiBvbnRvIHRoZSBoaXN0b3J5IHN0YWNrLCBpbmNyZWFzaW5nIGl0cyBsZW5ndGggYnkgb25lLlxuICAgKiBJZiB0aGVyZSB3ZXJlIGFueSBlbnRyaWVzIGluIHRoZSBzdGFjayBhZnRlciB0aGUgY3VycmVudCBvbmUsIHRoZXkgYXJlXG4gICAqIGxvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2sgd2l0aCBhIG5ldyBvbmUuICBUaGVcbiAgICogbG9jYXRpb24gdGhhdCB3YXMgcmVwbGFjZWQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyBgbmAgZW50cmllcyBiYWNrd2FyZC9mb3J3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrIHJlbGF0aXZlIHRvIHRoZVxuICAgKiBjdXJyZW50IGluZGV4LiBGb3IgZXhhbXBsZSwgYSBcImJhY2tcIiBuYXZpZ2F0aW9uIHdvdWxkIHVzZSBnbygtMSkuXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkZWx0YSBpbiB0aGUgc3RhY2sgaW5kZXhcbiAgICovXG4gIGdvKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgKiBAcmV0dXJucyB1bmxpc3RlbiAtIEEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBzdG9wIGxpc3RlbmluZ1xuICAgKi9cbiAgbGlzdGVuKGxpc3RlbmVyOiBMaXN0ZW5lcik6ICgpID0+IHZvaWQ7XG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0ge1xuICB1c3I6IGFueTtcbiAga2V5Pzogc3RyaW5nO1xufTtcblxuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBNZW1vcnkgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIHVzZXItc3VwcGxpZWQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbG9jYXRpb24uIFVzZWQgd2hlbiBwcm92aWRpbmdcbiAqIGVudHJpZXMgdG8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgIHZpYSBpdHMgYGluaXRpYWxFbnRyaWVzYCBvcHRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEluaXRpYWxFbnRyeSA9IHN0cmluZyB8IFBhcnRpYWw8TG9jYXRpb24+O1xuXG5leHBvcnQgdHlwZSBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB2NUNvbXBhdD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEEgbWVtb3J5IGhpc3Rvcnkgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuIFRoaXMgaXMgdXNlZnVsIGluIHN0YXRlZnVsXG4gKiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlcmUgaXMgbm8gd2ViIGJyb3dzZXIsIHN1Y2ggYXMgbm9kZSB0ZXN0cyBvciBSZWFjdFxuICogTmF0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeUhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShcbiAgb3B0aW9uczogTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogTWVtb3J5SGlzdG9yeSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllczogTG9jYXRpb25bXTsgLy8gRGVjbGFyZSBzbyB3ZSBjYW4gYWNjZXNzIGZyb20gY3JlYXRlTWVtb3J5TG9jYXRpb25cbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PlxuICAgIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgICAgZW50cnksXG4gICAgICB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsXG4gICAgICBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKTogTG9jYXRpb24ge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICB0bzogVG8sXG4gICAgc3RhdGU6IGFueSA9IG51bGwsXG4gICAga2V5Pzogc3RyaW5nXG4gICk6IExvY2F0aW9uIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxuICBsZXQgaGlzdG9yeTogTWVtb3J5SGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgICAgaW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uKCkgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm46IExpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQnJvd3NlciBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgYnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMgaW4gYSB3ZWJcbiAqIGJyb3dzZXIgZW52aXJvbm1lbnQuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvciBtb3N0IHdlYiBhcHBzIGFuZCBwcm92aWRlcyB0aGVcbiAqIGNsZWFuZXN0IFVSTHMgdGhlIGJyb3dzZXIncyBhZGRyZXNzIGJhci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2Jyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3Nlckhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoXG4gIG9wdGlvbnM6IEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBCcm93c2VySGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGFzaCBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgaGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBwb3J0aW9uXG4gKiBvZiB0aGUgVVJMIGluIGEgd2ViIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBpcyBpZGVhbCBmb3IgYXBwcyB0aGF0IGRvIG5vdCBjb250cm9sIHRoZSBzZXJ2ZXIgZm9yIHNvbWUgcmVhc29uXG4gKiAoYmVjYXVzZSB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBpcyBuZXZlciBzZW50IHRvIHRoZSBzZXJ2ZXIpLCBpbmNsdWRpbmcgc29tZVxuICogc2hhcmVkIGhvc3RpbmcgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHByb3ZpZGUgZmluZS1ncmFpbmVkIGNvbnRyb2xzIG92ZXJcbiAqIHdoaWNoIHBhZ2VzIGFyZSBzZXJ2ZWQgYXQgd2hpY2ggVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2hhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaEhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEhhc2hIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHdpbmRvdy5sb2NhdGlvbi5oYXNoLiBUaGlzIG1ha2VzIGl0IGlkZWFsXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcbiAqIHJlc2VydmVkIGZvciBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShcbiAgb3B0aW9uczogSGFzaEhpc3RvcnlPcHRpb25zID0ge31cbik6IEhhc2hIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlSGFzaExvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCIsXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcblxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWYgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uOiBMb2NhdGlvbiwgdG86IFRvKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfSlgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXItYmFzZWQgaGlzdG9yaWVzLCB3ZSBjb21iaW5lIHRoZSBzdGF0ZSBhbmQga2V5IGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbjogTG9jYXRpb24pOiBIaXN0b3J5U3RhdGUge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihcbiAgY3VycmVudDogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHRvOiBUbyxcbiAgc3RhdGU6IGFueSA9IG51bGwsXG4gIGtleT86IHN0cmluZ1xuKTogUmVhZG9ubHk8TG9jYXRpb24+IHtcbiAgbGV0IGxvY2F0aW9uOiBSZWFkb25seTxMb2NhdGlvbj4gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4uKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byksXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogKHRvICYmICh0byBhcyBMb2NhdGlvbikua2V5KSB8fCBrZXkgfHwgY3JlYXRlS2V5KCksXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCIsXG59OiBQYXJ0aWFsPFBhdGg+KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKTogUGFydGlhbDxQYXRoPiB7XG4gIGxldCBwYXJzZWRQYXRoOiBQYXJ0aWFsPFBhdGg+ID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVybEhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIFVybEhpc3RvcnlPcHRpb25zID0ge1xuICB3aW5kb3c/OiBXaW5kb3c7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShcbiAgZ2V0TG9jYXRpb246ICh3aW5kb3c6IFdpbmRvdywgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXSkgPT4gTG9jYXRpb24sXG4gIGNyZWF0ZUhyZWY6ICh3aW5kb3c6IFdpbmRvdywgdG86IFRvKSA9PiBzdHJpbmcsXG4gIHZhbGlkYXRlTG9jYXRpb246ICgobG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pID0+IHZvaWQpIHwgbnVsbCxcbiAgb3B0aW9uczogVXJsSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogVXJsSGlzdG9yeSB7XG4gIGxldCB7IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ISwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uKTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcblxuICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICB9XG5cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbiB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uKTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG5cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IEhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gXCIuL2hpc3RvcnlcIjtcblxuLyoqXG4gKiBNYXAgb2Ygcm91dGVJZCAtPiBkYXRhIHJldHVybmVkIGZyb20gYSBsb2FkZXIvYWN0aW9uL2Vycm9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVEYXRhIHtcbiAgW3JvdXRlSWQ6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGVudW0gUmVzdWx0VHlwZSB7XG4gIGRhdGEgPSBcImRhdGFcIixcbiAgZGVmZXJyZWQgPSBcImRlZmVycmVkXCIsXG4gIHJlZGlyZWN0ID0gXCJyZWRpcmVjdFwiLFxuICBlcnJvciA9IFwiZXJyb3JcIixcbn1cblxuLyoqXG4gKiBTdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Y2Nlc3NSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRhdGE7XG4gIGRhdGE6IGFueTtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCBkZWZlcigpIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmVycmVkUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZDtcbiAgZGVmZXJyZWREYXRhOiBEZWZlcnJlZERhdGE7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVkaXJlY3RSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0O1xuICBzdGF0dXM6IG51bWJlcjtcbiAgbG9jYXRpb246IHN0cmluZztcbiAgcmV2YWxpZGF0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBVbnN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yO1xuICBlcnJvcjogYW55O1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb24gLSBwb3RlbnRpYWxseSBzdWNjZXNzZnVsIG9yIHVuc3VjY2Vzc2Z1bFxuICovXG5leHBvcnQgdHlwZSBEYXRhUmVzdWx0ID1cbiAgfCBTdWNjZXNzUmVzdWx0XG4gIHwgRGVmZXJyZWRSZXN1bHRcbiAgfCBSZWRpcmVjdFJlc3VsdFxuICB8IEVycm9yUmVzdWx0O1xuXG5leHBvcnQgdHlwZSBGb3JtTWV0aG9kID0gXCJnZXRcIiB8IFwicG9zdFwiIHwgXCJwdXRcIiB8IFwicGF0Y2hcIiB8IFwiZGVsZXRlXCI7XG5leHBvcnQgdHlwZSBGb3JtRW5jVHlwZSA9XG4gIHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICB8IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gcGFzcyBhcm91bmQgZm9yIGFjdGlvbiBzdWJtaXNzaW9ucywgbm90IGludGVuZGVkIGZvclxuICogZXh0ZXJuYWwgY29uc3VtcHRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJtaXNzaW9uIHtcbiAgZm9ybU1ldGhvZDogRXhjbHVkZTxGb3JtTWV0aG9kLCBcImdldFwiPjtcbiAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQXJndW1lbnRzIHBhc3NlZCB0byByb3V0ZSBsb2FkZXIvYWN0aW9uIGZ1bmN0aW9ucy4gIFNhbWUgZm9yIG5vdyBidXQgd2Uga2VlcFxuICogdGhpcyBhcyBhIHByaXZhdGUgaW1wbGVtZW50YXRpb24gZGV0YWlsIGluIGNhc2UgdGhleSBkaXZlcmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmludGVyZmFjZSBEYXRhRnVuY3Rpb25BcmdzIHtcbiAgcmVxdWVzdDogUmVxdWVzdDtcbiAgcGFyYW1zOiBQYXJhbXM7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBsb2FkZXIgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb25BcmdzIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJncyB7fVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gYWN0aW9uIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uQXJncyBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3Mge31cblxuLyoqXG4gKiBSb3V0ZSBsb2FkZXIgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb24ge1xuICAoYXJnczogTG9hZGVyRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb24gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uRnVuY3Rpb24ge1xuICAoYXJnczogQWN0aW9uRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uIHNpZ25hdHVyZS4gIFRoaXMgcnVucyBhZnRlciBhbnkgc3VibWlzc2lvblxuICogKG5hdmlnYXRpb24gb3IgZmV0Y2hlciksIHNvIHdlIGZsYXR0ZW4gdGhlIG5hdmlnYXRpb24vZmV0Y2hlciBzdWJtaXNzaW9uXG4gKiBvbnRvIHRoZSBhcmd1bWVudHMuICBJdCBzaG91bGRuJ3QgbWF0dGVyIHdoZXRoZXIgaXQgY2FtZSBmcm9tIGEgbmF2aWdhdGlvblxuICogb3IgYSBmZXRjaGVyLCB3aGF0IHJlYWxseSBtYXR0ZXJzIGlzIHRoZSBVUkxzIGFuZCB0aGUgZm9ybURhdGEgc2luY2UgbG9hZGVyc1xuICogaGF2ZSB0byByZS1ydW4gYmFzZWQgb24gdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2VyZSBwb3RlbnRpYWxseSBtdXRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiB7XG4gIChhcmdzOiB7XG4gICAgY3VycmVudFVybDogVVJMO1xuICAgIGN1cnJlbnRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgbmV4dFVybDogVVJMO1xuICAgIG5leHRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgZm9ybU1ldGhvZD86IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdO1xuICAgIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZT86IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgICBmb3JtRGF0YT86IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAgICBhY3Rpb25SZXN1bHQ/OiBEYXRhUmVzdWx0O1xuICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBib29sZWFuO1xuICB9KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBCYXNlIFJvdXRlT2JqZWN0IHdpdGggY29tbW9uIHByb3BzIHNoYXJlZCBieSBhbGwgdHlwZXMgb2Ygcm91dGVzXG4gKi9cbnR5cGUgQWdub3N0aWNCYXNlUm91dGVPYmplY3QgPSB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbG9hZGVyPzogTG9hZGVyRnVuY3Rpb247XG4gIGFjdGlvbj86IEFjdGlvbkZ1bmN0aW9uO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogYm9vbGVhbjtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbjtcbiAgaGFuZGxlPzogYW55O1xufTtcblxuLyoqXG4gKiBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZHJlblxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGluZGV4OiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb24taW5kZXggcm91dGVzIG1heSBoYXZlIGNoaWxkcmVuLCBidXQgY2Fubm90IGhhdmUgaW5kZXhcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBpbmRleD86IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0XG4gIHwgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ICYge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBIGRhdGEgcm91dGUgb2JqZWN0LCB3aGljaCBpcyBqdXN0IGEgUm91dGVPYmplY3Qgd2l0aCBhIHJlcXVpcmVkIHVuaXF1ZSBJRFxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3Q7XG5cbi8vIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGZpbmRpbmcgcGF0aCBwYXJhbWV0ZXJzIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xudHlwZSBfUGF0aFBhcmFtPFBhdGggZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gc3BsaXQgcGF0aCBpbnRvIGluZGl2aWR1YWwgcGF0aCBzZWdtZW50c1xuICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgTH0vJHtpbmZlciBSfWBcbiAgICA/IF9QYXRoUGFyYW08TD4gfCBfUGF0aFBhcmFtPFI+XG4gICAgOiAvLyBmaW5kIHBhcmFtcyBhZnRlciBgOmBcbiAgICBQYXRoIGV4dGVuZHMgYCR7c3RyaW5nfToke2luZmVyIFBhcmFtfWBcbiAgICA/IFBhcmFtXG4gICAgOiAvLyBvdGhlcndpc2UsIHRoZXJlIGFyZW4ndCBhbnkgcGFyYW1zIHByZXNlbnRcbiAgICAgIG5ldmVyO1xuXG4vKipcbiAqIEV4YW1wbGVzOlxuICogXCIvYS9iLypcIiAtPiBcIipcIlxuICogXCI6YVwiIC0+IFwiYVwiXG4gKiBcIi9hLzpiXCIgLT4gXCJiXCJcbiAqIFwiL2EvYmxhaGJsYWhibGFoOmJcIiAtPiBcImJcIlxuICogXCIvOmEvOmJcIiAtPiBcImFcIiB8IFwiYlwiXG4gKiBcIi86YS9iLzpjLypcIiAtPiBcImFcIiB8IFwiY1wiIHwgXCIqXCJcbiAqL1xudHlwZSBQYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGp1c3QgYSB3aWxkY2FyZFxuICBQYXRoIGV4dGVuZHMgXCIqXCJcbiAgICA/IFwiKlwiXG4gICAgOiAvLyBsb29rIGZvciB3aWxkY2FyZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gICAgUGF0aCBleHRlbmRzIGAke2luZmVyIFJlc3R9LypgXG4gICAgPyBcIipcIiB8IF9QYXRoUGFyYW08UmVzdD5cbiAgICA6IC8vIGxvb2sgZm9yIHBhcmFtcyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbiAgICAgIF9QYXRoUGFyYW08UGF0aD47XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxuZXhwb3J0IHR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGlmIGNvdWxkIG5vdCBmaW5kIHBhdGggcGFyYW1zLCBmYWxsYmFjayB0byBgc3RyaW5nYFxuICBbUGF0aFBhcmFtPFNlZ21lbnQ+XSBleHRlbmRzIFtuZXZlcl0gPyBzdHJpbmcgOiBQYXRoUGFyYW08U2VnbWVudD47XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljUm91dGVNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcm91dGUgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICByb3V0ZTogUm91dGVPYmplY3RUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbiAgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdD4ge31cblxuZnVuY3Rpb24gaXNJbmRleFJvdXRlKFxuICByb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdFxuKTogcm91dGUgaXMgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0IHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuXG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3Nhcnkgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXSxcbiAgYWxsSWRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhYWxsSWRzLmhhcyhpZCksXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgYCArXG4gICAgICAgIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCJcbiAgICApO1xuICAgIGFsbElkcy5hZGQoaWQpO1xuXG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlOiBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0geyAuLi5yb3V0ZSwgaWQgfTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGU6IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICAgICAgPyBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlLmNoaWxkcmVuLCB0cmVlUGF0aCwgYWxsSWRzKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni91dGlscy9tYXRjaC1yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUm91dGVzPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFR5cGVbXSxcbiAgbG9jYXRpb25Bcmc6IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBiYXNlbmFtZSA9IFwiL1wiXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IGxvY2F0aW9uID1cbiAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcblxuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+KGJyYW5jaGVzW2ldLCBwYXRobmFtZSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuaW50ZXJmYWNlIFJvdXRlTWV0YTxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgY2FzZVNlbnNpdGl2ZTogYm9vbGVhbjtcbiAgY2hpbGRyZW5JbmRleDogbnVtYmVyO1xuICByb3V0ZTogUm91dGVPYmplY3RUeXBlO1xufVxuXG5pbnRlcmZhY2UgUm91dGVCcmFuY2g8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcGF0aDogc3RyaW5nO1xuICBzY29yZTogbnVtYmVyO1xuICByb3V0ZXNNZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPltdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFR5cGVbXSxcbiAgYnJhbmNoZXM6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdLFxuICBwYXJlbnRzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdLFxuICBwYXJlbnRQYXRoID0gXCJcIlxuKTogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPltdIHtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCBtZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPiA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcm91dGUucGF0aCB8fCBcIlwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7IHBhdGgsIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLCByb3V0ZXNNZXRhIH0pO1xuICB9KTtcblxuICByZXR1cm4gYnJhbmNoZXM7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIGJyYW5jaDogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPixcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuXG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXM6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMgYXMgUGFyYW1zPFBhcmFtS2V5PixcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aDxQYXRoIGV4dGVuZHMgc3RyaW5nPihcbiAgcGF0aDogUGF0aCxcbiAgcGFyYW1zOiB7XG4gICAgW2tleSBpbiBQYXRoUGFyYW08UGF0aD5dOiBzdHJpbmc7XG4gIH0gPSB7fSBhcyBhbnlcbik6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoXG4gICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGtleTogUGF0aFBhcmFtPFBhdGg+KSA9PiB7XG4gICAgICBpbnZhcmlhbnQocGFyYW1zW2tleV0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgIHJldHVybiBwYXJhbXNba2V5XSE7XG4gICAgfSlcbiAgICAucmVwbGFjZSgvKFxcLz8pXFwqLywgKF8sIHByZWZpeCwgX18sIHN0cikgPT4ge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiIGFzIFBhdGhQYXJhbTxQYXRoPjtcblxuICAgICAgaWYgKHBhcmFtc1tzdGFyXSA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIG5vIHNwbGF0IHdhcyBwcm92aWRlZCwgdHJpbSB0aGUgdHJhaWxpbmcgc2xhc2ggX3VubGVzc18gaXQnc1xuICAgICAgICAvLyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgcmV0dXJuIHN0ciA9PT0gXCIvKlwiID8gXCIvXCIgOiBcIlwiO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB0aGUgc3BsYXRcbiAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtwYXJhbXNbc3Rhcl19YDtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhQYXR0ZXJuPFBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QgYSBVUkwgcGF0aG5hbWUuIE1heSBjb250YWluIGA6aWRgLXN0eWxlIHNlZ21lbnRzXG4gICAqIHRvIGluZGljYXRlIHBsYWNlaG9sZGVycyBmb3IgZHluYW1pYyBwYXJhbWV0ZXJzLiBNYXkgYWxzbyBlbmQgd2l0aCBgLypgIHRvXG4gICAqIGluZGljYXRlIG1hdGNoaW5nIHRoZSByZXN0IG9mIHRoZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBwYXRoOiBQYXRoO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGUgc3RhdGljIHBvcnRpb25zIG9mIHRoZSBgcGF0aGAgc2hvdWxkIGJlIG1hdGNoZWQgaW5cbiAgICogdGhlIHNhbWUgY2FzZS5cbiAgICovXG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGlzIHBhdHRlcm4gc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgZW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIFBhdGhNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIFBhdGhQYXR0ZXJuIG1hdGNoZWQgb24gYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aE1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuO1xufVxuXG50eXBlIE11dGFibGU8VD4gPSB7XG4gIC1yZWFkb25seSBbUCBpbiBrZXlvZiBUXTogVFtQXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG5cbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXM6IFBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsXG4gICAgICAgIHBhcmFtTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21waWxlUGF0aChcbiAgcGF0aDogc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIGVuZCA9IHRydWVcbik6IFtSZWdFeHAsIHN0cmluZ1tdXSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG5cbiAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPVxuICAgIFwiXlwiICtcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgICAgIC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSAvLyBNYWtlIHN1cmUgaXQgaGFzIGEgbGVhZGluZyAvXG4gICAgICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gICAgICAucmVwbGFjZSgvOihcXHcrKS9nLCAoXzogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuIFwiKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCBzbyB3ZSBzaG91bGQgZXhwZWN0IHRvXG4gICAgLy8gbWF0Y2ggb25seSBpZiB3ZSBmaW5kIHRoZSBlbmQgb2YgdGhpcyBwYXRoIHNlZ21lbnQuICBMb29rIGZvciBhbiBvcHRpb25hbFxuICAgIC8vIG5vbi1jYXB0dXJlZCB0cmFpbGluZyBzbGFzaCAodG8gbWF0Y2ggYSBwb3J0aW9uIG9mIHRoZSBVUkwpIG9yIHRoZSBlbmRcbiAgICAvLyBvZiB0aGUgcGF0aCAoaWYgd2UndmUgbWF0Y2hlZCB0byB0aGUgZW5kKS4gIFdlIHVzZWQgdG8gZG8gdGhpcyB3aXRoIGFcbiAgICAvLyB3b3JkIGJvdW5kYXJ5IGJ1dCB0aGF0IGdpdmVzIGZhbHNlIHBvc2l0aXZlcyBvbiByb3V0ZXMgbGlrZVxuICAgIC8vIC91c2VyLXByZWZlcmVuY2VzIHNpbmNlIGAtYCBjb3VudHMgYXMgYSB3b3JkIGJvdW5kYXJ5LlxuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2ggZm9yIFwiXCIgb3IgXCIvXCJcbiAgfVxuXG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG5cbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcIiR7cGFyYW1OYW1lfVwiIHdpbGwgbm90IGJlIGRlY29kZWQgYmVjYXVzZWAgK1xuICAgICAgICBgIHRoZSBzdHJpbmcgXCIke3ZhbHVlfVwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5YCArXG4gICAgICAgIGAgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBiYXNlbmFtZTogc3RyaW5nXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIGxlYXZlIHRyYWlsaW5nIHNsYXNoIGJlaGF2aW9yIGluIHRoZSB1c2VyJ3MgY29udHJvbCwgc28gaWYgdGhleVxuICAvLyBzcGVjaWZ5IGEgYmFzZW5hbWUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLCB3ZSBzaG91bGQgc3VwcG9ydCBpdFxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICAgID8gYmFzZW5hbWUubGVuZ3RoIC0gMVxuICAgIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGJvb2xlYW4sIG1lc3NhZ2U/OiBzdHJpbmcpOiBhc3NlcnRzIHZhbHVlO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudDxUPihcbiAgdmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBtZXNzYWdlPzogc3RyaW5nXG4pOiBhc3NlcnRzIHZhbHVlIGlzIFQ7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBhbnksIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXNvbHZlZCBwYXRoIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG86IFRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIik6IFBhdGgge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKFxuICBjaGFyOiBzdHJpbmcsXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGRlc3Q6IHN0cmluZyxcbiAgcGF0aDogUGFydGlhbDxQYXRoPlxuKSB7XG4gIHJldHVybiAoXG4gICAgYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBgICtcbiAgICBgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwYXRoXG4gICAgKX1dLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgYCArXG4gICAgYFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYCArXG4gICAgYGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZyxcbiAgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZVxuKTogUGF0aCB7XG4gIGxldCB0bzogUGFydGlhbDxQYXRoPjtcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHsgLi4udG9BcmcgfTtcblxuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cblxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgbGV0IGZyb206IHN0cmluZztcblxuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmIChpc1BhdGhSZWxhdGl2ZSB8fCB0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBcInRvXCIgaGFkIG9uZVxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID1cbiAgICB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPVxuICAgIChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmIChcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nID0+XG4gIHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCJcbiAgICA/IFwiXCJcbiAgICA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKVxuICAgID8gc2VhcmNoXG4gICAgOiBcIj9cIiArIHNlYXJjaDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplSGFzaCA9IChoYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG5cbmV4cG9ydCB0eXBlIEpzb25GdW5jdGlvbiA9IDxEYXRhPihcbiAgZGF0YTogRGF0YSxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5leHBvcnQgY29uc3QganNvbjogSnNvbkZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZWRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcbiAgX3RyYWNrZWQ/OiBib29sZWFuO1xuICBfZGF0YT86IGFueTtcbiAgX2Vycm9yPzogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQWJvcnRlZERlZmVycmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWREYXRhIHtcbiAgcHJpdmF0ZSBwZW5kaW5nS2V5czogU2V0PHN0cmluZyB8IG51bWJlcj4gPSBuZXcgU2V0PHN0cmluZyB8IG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG4gIHByaXZhdGUgYWJvcnRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIHVubGlzdGVuQWJvcnRTaWduYWw6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgc3Vic2NyaWJlcj86IChhYm9ydGVkOiBib29sZWFuKSA9PiB2b2lkID0gdW5kZWZpbmVkO1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIGludmFyaWFudChcbiAgICAgIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSksXG4gICAgICBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIlxuICAgICk7XG5cbiAgICAvLyBTZXQgdXAgYW4gQWJvcnRDb250cm9sbGVyICsgUHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHRvIGV4aXQgZWFybHlcbiAgICAvLyBjYW5jZWxsYXRpb25cbiAgICBsZXQgcmVqZWN0OiAoZTogQWJvcnRlZERlZmVycmVkRXJyb3IpID0+IHZvaWQ7XG4gICAgdGhpcy5hYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PlxuICAgICAgcmVqZWN0KG5ldyBBYm9ydGVkRGVmZXJyZWRFcnJvcihcIkRlZmVycmVkIGRhdGEgYWJvcnRlZFwiKSk7XG4gICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsID0gKCkgPT5cbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB0aGlzLnRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSxcbiAgICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHRyYWNrUHJvbWlzZShcbiAgICBrZXk6IHN0cmluZyB8IG51bWJlcixcbiAgICB2YWx1ZTogUHJvbWlzZTx1bmtub3duPiB8IHVua25vd25cbiAgKTogVHJhY2tlZFByb21pc2UgfCB1bmtub3duIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nS2V5cy5hZGQoa2V5KTtcblxuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2U6IFRyYWNrZWRQcm9taXNlID0gUHJvbWlzZS5yYWNlKFt2YWx1ZSwgdGhpcy5hYm9ydFByb21pc2VdKS50aGVuKFxuICAgICAgKGRhdGEpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBudWxsLCBkYXRhIGFzIHVua25vd24pLFxuICAgICAgKGVycm9yKSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IgYXMgdW5rbm93bilcbiAgICApO1xuXG4gICAgLy8gUmVnaXN0ZXIgcmVqZWN0aW9uIGxpc3RlbmVycyB0byBhdm9pZCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgb25cbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvblNldHRsZShcbiAgICBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSxcbiAgICBrZXk6IHN0cmluZyB8IG51bWJlcixcbiAgICBlcnJvcjogdW5rbm93bixcbiAgICBkYXRhPzogdW5rbm93blxuICApOiB1bmtub3duIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiZcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3JcbiAgICApIHtcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nS2V5cy5kZWxldGUoa2V5KTtcblxuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBhYm9ydCFcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLnN1YnNjcmliZXI7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgc3Vic2NyaWJlciAmJiBzdWJzY3JpYmVyKGZhbHNlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEgfSk7XG4gICAgc3Vic2NyaWJlciAmJiBzdWJzY3JpYmVyKGZhbHNlKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHN1YnNjcmliZShmbjogKGFib3J0ZWQ6IGJvb2xlYW4pID0+IHZvaWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXIgPSBmbjtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzLmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXMuZGVsZXRlKGspKTtcbiAgICBsZXQgc3Vic2NyaWJlciA9IHRoaXMuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyICYmIHN1YnNjcmliZXIodHJ1ZSk7XG4gIH1cblxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWw6IEFib3J0U2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cblxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5cy5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSxcbiAgICAgIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFRyYWNrZWRQcm9taXNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgKHZhbHVlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCA9PT0gdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmVyKGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEpO1xufVxuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEZ1bmN0aW9uID0gKFxuICB1cmw6IHN0cmluZyxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvclJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHN0YXR1czogbnVtYmVyLCBzdGF0dXNUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsIGRhdGE6IGFueSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvdyBmcm9tIGFuIGFjdGlvbi9sb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGU6IGFueSk6IGUgaXMgRXJyb3JSZXNwb25zZSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgRXJyb3JSZXNwb25zZTtcbn1cbiIsImltcG9ydCB0eXBlIHsgSGlzdG9yeSwgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIEhpc3RvcnlBY3Rpb24sXG4gIGNyZWF0ZUxvY2F0aW9uLFxuICBjcmVhdGVQYXRoLFxuICBwYXJzZVBhdGgsXG59IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJlc3VsdCxcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIERlZmVycmVkUmVzdWx0LFxuICBFcnJvclJlc3VsdCxcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIFJlZGlyZWN0UmVzdWx0LFxuICBSb3V0ZURhdGEsXG4gIEFnbm9zdGljUm91dGVPYmplY3QsXG4gIFN1Ym1pc3Npb24sXG4gIFN1Y2Nlc3NSZXN1bHQsXG4gIEFnbm9zdGljUm91dGVNYXRjaCxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIERlZmVycmVkRGF0YSxcbiAgRXJyb3JSZXNwb25zZSxcbiAgUmVzdWx0VHlwZSxcbiAgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyxcbiAgaW52YXJpYW50LFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgbWF0Y2hSb3V0ZXMsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIFJvdXRlciBpbnN0YW5jZSBtYW5hZ2VzIGFsbCBuYXZpZ2F0aW9uIGFuZCBkYXRhIGxvYWRpbmcvbXV0YXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgYmFzZW5hbWUoKTogUm91dGVySW5pdFtcImJhc2VuYW1lXCJdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBzdGF0ZSgpOiBSb3V0ZXJTdGF0ZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgcm91dGVzIGZvciB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHJvdXRlcygpOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBpbmNsdWRpbmcgYWRkaW5nIGhpc3RvcnkgbGlzdGVuZXJzIGFuZCBraWNraW5nIG9mZlxuICAgKiBpbml0aWFsIGRhdGEgZmV0Y2hlcy4gIFJldHVybnMgYSBmdW5jdGlvbiB0byBjbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnRcbiAgICogYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBpbml0aWFsaXplKCk6IFJvdXRlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFN1YnNjcmliZSB0byByb3V0ZXIuc3RhdGUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBuZXcgc3RhdGVcbiAgICovXG4gIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcik6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGJlaGF2aW9yIGluIHRoZSByb3V0ZXJcbiAgICpcbiAgICogQHBhcmFtIHNhdmVkU2Nyb2xsUG9zaXRpb25zIE9iamVjdCB0aGF0IHdpbGwgbWFuYWdlIHBvc2l0aW9ucywgaW4gY2FzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQncyBiZWluZyByZXN0b3JlZCBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAqIEBwYXJhbSBnZXRTY3JvbGxQb3NpdGlvbiAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGFjdGl2ZSBZIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZ2V0S2V5ICAgICAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgdG8gdXNlIGZvciByZXN0b3JhdGlvblxuICAgKi9cbiAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogTmF2aWdhdGUgZm9yd2FyZC9iYWNrd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBAcGFyYW0gdG8gRGVsdGEgdG8gbW92ZSBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgbmF2aWdhdGUodG86IG51bWJlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSB0byBQYXRoIHRvIG5hdmlnYXRlIHRvXG4gICAqIEBwYXJhbSBvcHRzIE5hdmlnYXRpb24gb3B0aW9ucyAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgbmF2aWdhdGUodG86IFRvLCBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSBmZXRjaGVyIGxvYWQvc3VibWlzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ga2V5ICAgICBGZXRjaGVyIGtleVxuICAgKiBAcGFyYW0gcm91dGVJZCBSb3V0ZSB0aGF0IG93bnMgdGhlIGZldGNoZXJcbiAgICogQHBhcmFtIGhyZWYgICAgaHJlZiB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0cyAgICBGZXRjaGVyIG9wdGlvbnMsIChtZXRob2QsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAqL1xuICBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYWxsIGN1cnJlbnQgcm91dGUgbG9hZGVycyBhbmQgZmV0Y2hlciBsb2Fkc1xuICAgKi9cbiAgcmV2YWxpZGF0ZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaHJlZiBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uXG4gICAqIEBwYXJhbSBsb2NhdGlvblxuICAgKi9cbiAgY3JlYXRlSHJlZihsb2NhdGlvbjogTG9jYXRpb24gfCBVUkwpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQvY3JlYXRlIGEgZmV0Y2hlciBmb3IgdGhlIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk/OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSB0aGUgZmV0Y2hlciBmb3IgYSBnaXZlbiBrZXlcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgZGVsZXRlRmV0Y2hlcihrZXk/OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogQ2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0IGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgZmV0Y2ggQWJvcnRDb250cm9sbGVycyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgcGVuZGluZyBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGFjY2Vzc2VkIGJ5IHVuaXQgdGVzdHNcbiAgICovXG4gIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPjtcbn1cblxuLyoqXG4gKiBTdGF0ZSBtYWludGFpbmVkIGludGVybmFsbHkgYnkgdGhlIHJvdXRlci4gIER1cmluZyBhIG5hdmlnYXRpb24sIGFsbCBzdGF0ZXNcbiAqIHJlZmxlY3QgdGhlIHRoZSBcIm9sZFwiIGxvY2F0aW9uIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3RhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiBvZiB0aGUgbW9zdCByZWNlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24gcmVmbGVjdGVkIGJ5IHRoZSByb3V0ZXJcbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2V0IG9mIHJvdXRlIG1hdGNoZXNcbiAgICovXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcblxuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgd2UndmUgY29tcGxldGVkIG91ciBpbml0aWFsIGRhdGEgbG9hZFxuICAgKi9cbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdlIHNob3VsZCBzdGFydCBhdCBmb3IgYSBuZXcgdmlld1xuICAgKiAgLSBudW1iZXIgLT4gc2Nyb2xsIHBvc2l0aW9uIHRvIHJlc3RvcmUgdG9cbiAgICogIC0gZmFsc2UgLT4gZG8gbm90IHJlc3RvcmUgc2Nyb2xsIGF0IGFsbCAodXNlZCBkdXJpbmcgc3VibWlzc2lvbnMpXG4gICAqICAtIG51bGwgLT4gZG9uJ3QgaGF2ZSBhIHNhdmVkIHBvc2l0aW9uLCBzY3JvbGwgdG8gaGFzaCBvciB0b3Agb2YgcGFnZVxuICAgKi9cbiAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudW1iZXIgfCBmYWxzZSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBuYXZpZ2F0aW9uIHNob3VsZCBza2lwIHJlc2V0dGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIGlmIHdlIGFyZSB1bmFibGUgdG8gcmVzdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgbmF2aWdhdGlvbjogTmF2aWdhdGlvbjtcblxuICAvKipcbiAgICogVHJhY2tzIGFueSBpbi1wcm9ncmVzcyByZXZhbGlkYXRpb25zXG4gICAqL1xuICByZXZhbGlkYXRpb246IFJldmFsaWRhdGlvblN0YXRlO1xuXG4gIC8qKlxuICAgKiBEYXRhIGZyb20gdGhlIGxvYWRlcnMgZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBhY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGFjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVycm9ycyBjYXVnaHQgZnJvbSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBlcnJvcnM6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBjdXJyZW50IGZldGNoZXJzXG4gICAqL1xuICBmZXRjaGVyczogTWFwPHN0cmluZywgRmV0Y2hlcj47XG59XG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBoeWRyYXRlIGEgUm91dGVyIGZyb20gU1NSXG4gKi9cbmV4cG9ydCB0eXBlIEh5ZHJhdGlvblN0YXRlID0gUGFydGlhbDxcbiAgUGljazxSb3V0ZXJTdGF0ZSwgXCJsb2FkZXJEYXRhXCIgfCBcImFjdGlvbkRhdGFcIiB8IFwiZXJyb3JzXCI+XG4+O1xuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNyZWF0ZVJvdXRlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckluaXQge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W107XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG4gIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBsb2NhdGlvbjogUm91dGVyU3RhdGVbXCJsb2NhdGlvblwiXTtcbiAgbWF0Y2hlczogUm91dGVyU3RhdGVbXCJtYXRjaGVzXCJdO1xuICBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIGFjdGlvbkRhdGE6IFJvdXRlclN0YXRlW1wiYWN0aW9uRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aW9uSGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG4gIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBIFN0YXRpY0hhbmRsZXIgaW5zdGFuY2UgbWFuYWdlcyBhIHNpbmd1bGFyIFNTUiBuYXZpZ2F0aW9uL2ZldGNoIGV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlciB7XG4gIGRhdGFSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG4gIHF1ZXJ5KHJlcXVlc3Q6IFJlcXVlc3QpOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKHJlcXVlc3Q6IFJlcXVlc3QsIHJvdXRlSWQ/OiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogU3Vic2NyaWJlciBmdW5jdGlvbiBzaWduYXR1cmUgZm9yIGNoYW5nZXMgdG8gcm91dGVyIHN0YXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3Vic2NyaWJlciB7XG4gIChzdGF0ZTogUm91dGVyU3RhdGUpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVXNlTWF0Y2hlc01hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgcGFyYW1zOiBBZ25vc3RpY1JvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gIGRhdGE6IHVua25vd247XG4gIGhhbmRsZTogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBrZXkgdG8gYmUgdXNlZCBpbiBzY3JvbGwgcmVzdG9yYXRpb25cbiAqIGZvciBhIGdpdmVuIGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB7XG4gIChsb2NhdGlvbjogTG9jYXRpb24sIG1hdGNoZXM6IFVzZU1hdGNoZXNNYXRjaFtdKTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24ge1xuICAoKTogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIExpbmsgbmF2aWdhdGlvblxuICovXG50eXBlIExpbmtOYXZpZ2F0ZU9wdGlvbnMgPSB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgRm9ybSBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyA9IHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBmb3JtTWV0aG9kPzogRm9ybU1ldGhvZDtcbiAgZm9ybUVuY1R5cGU/OiBGb3JtRW5jVHlwZTtcbiAgZm9ybURhdGE6IEZvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBPcHRpb25zIHRvIHBhc3MgdG8gbmF2aWdhdGUoKSBmb3IgZWl0aGVyIGEgTGluayBvciBGb3JtIG5hdmlnYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyTmF2aWdhdGVPcHRpb25zID1cbiAgfCBMaW5rTmF2aWdhdGVPcHRpb25zXG4gIHwgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIHRvIHBhc3MgdG8gZmV0Y2goKVxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJGZXRjaE9wdGlvbnMgPVxuICB8IE9taXQ8TGlua05hdmlnYXRlT3B0aW9ucywgXCJyZXBsYWNlXCI+XG4gIHwgT21pdDxTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zLCBcInJlcGxhY2VcIj47XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3Igc3RhdGUubmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uU3RhdGVzID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGxvY2F0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gIH07XG4gIExvYWRpbmc6IHtcbiAgICBzdGF0ZTogXCJsb2FkaW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2Q7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICBmb3JtRGF0YTogRm9ybURhdGE7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uID0gTmF2aWdhdGlvblN0YXRlc1trZXlvZiBOYXZpZ2F0aW9uU3RhdGVzXTtcblxuZXhwb3J0IHR5cGUgUmV2YWxpZGF0aW9uU3RhdGUgPSBcImlkbGVcIiB8IFwibG9hZGluZ1wiO1xuXG4vKipcbiAqIFBvdGVudGlhbCBzdGF0ZXMgZm9yIGZldGNoZXJzXG4gKi9cbnR5cGUgRmV0Y2hlclN0YXRlczxURGF0YSA9IGFueT4gPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIExvYWRpbmc6IHtcbiAgICBzdGF0ZTogXCJsb2FkaW5nXCI7XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgU3VibWl0dGluZzoge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcjxURGF0YSA9IGFueT4gPVxuICBGZXRjaGVyU3RhdGVzPFREYXRhPltrZXlvZiBGZXRjaGVyU3RhdGVzPFREYXRhPl07XG5cbmludGVyZmFjZSBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIHN0YXJ0TmF2aWdhdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uIGJlY2F1c2Ugd2VcbiAgICogcmVkaXJlY3RlZCBvciBnb3QgaW50ZXJydXB0ZWRcbiAgICovXG4gIHNob3J0Q2lyY3VpdGVkPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUFjdGlvblJlc3VsdCBleHRlbmRzIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogRXJyb3IgdGhyb3duIGZyb20gdGhlIGN1cnJlbnQgYWN0aW9uLCBrZXllZCBieSB0aGUgcm91dGUgY29udGFpbmluZyB0aGVcbiAgICogZXJyb3IgYm91bmRhcnkgdG8gcmVuZGVyIHRoZSBlcnJvci4gIFRvIGJlIGNvbW1pdHRlZCB0byB0aGUgc3RhdGUgYWZ0ZXJcbiAgICogbG9hZGVycyBoYXZlIGNvbXBsZXRlZFxuICAgKi9cbiAgcGVuZGluZ0FjdGlvbkVycm9yPzogUm91dGVEYXRhO1xuICAvKipcbiAgICogRGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbiwga2V5ZWQgYnkgdGhlIHJvdXRlIG93bmluZyB0aGUgYWN0aW9uLlxuICAgKiBUbyBiZSBjb21taXR0ZWQgdG8gdGhlIHN0YXRlIGFmdGVyIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWRcbiAgICovXG4gIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhO1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlTG9hZGVyc1Jlc3VsdCBleHRlbmRzIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogbG9hZGVyRGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBsb2FkZXJzXG4gICAqL1xuICBsb2FkZXJEYXRhPzogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICAvKipcbiAgICogZXJyb3JzIHRocm93biBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBsb2FkZXJzXG4gICAqL1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn1cblxuLyoqXG4gKiBUdXBsZSBvZiBba2V5LCBocmVmLCBEYXRhUm91dGVyTWF0Y2hdIGZvciBhIHJldmFsaWRhdGluZyBmZXRjaGVyLmxvYWQoKVxuICovXG50eXBlIFJldmFsaWRhdGluZ0ZldGNoZXIgPSBbc3RyaW5nLCBzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hdO1xuXG4vKipcbiAqIFR1cGxlIG9mIFtocmVmLCBEYXRhUm91dGVNYXRjaF0gZm9yIGFuIGFjdGl2ZSBmZXRjaGVyLmxvYWQoKVxuICovXG50eXBlIEZldGNoTG9hZE1hdGNoID0gW3N0cmluZywgQWdub3N0aWNEYXRhUm91dGVNYXRjaF07XG5cbmV4cG9ydCBjb25zdCBJRExFX05BVklHQVRJT046IE5hdmlnYXRpb25TdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfRkVUQ0hFUjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbn07XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVSb3V0ZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0OiBSb3V0ZXJJbml0KTogUm91dGVyIHtcbiAgaW52YXJpYW50KFxuICAgIGluaXQucm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIlxuICApO1xuXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcyk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeTogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldDxSb3V0ZXJTdWJzY3JpYmVyPigpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGZhbHNlO1xuXG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKFxuICAgIGRhdGFSb3V0ZXMsXG4gICAgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIGluaXQuYmFzZW5hbWVcbiAgKTtcbiAgbGV0IGluaXRpYWxFcnJvcnM6IFJvdXRlRGF0YSB8IG51bGwgPSBudWxsO1xuXG4gIGlmIChpbml0aWFsTWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IG1hdGNoIGEgdXNlci1wcm92aWRlZC1yb3V0ZSwgZmFsbCBiYWNrIHRvIHRoZSByb290XG4gICAgLy8gdG8gYWxsb3cgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIGxldCB7IG1hdGNoZXMsIHJvdXRlLCBlcnJvciB9ID0gZ2V0Tm90Rm91bmRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBpbml0aWFsRXJyb3JzID0geyBbcm91dGUuaWRdOiBlcnJvciB9O1xuICB9XG5cbiAgbGV0IGluaXRpYWxpemVkID1cbiAgICAhaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpIHx8IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuXG4gIGxldCByb3V0ZXI6IFJvdXRlcjtcbiAgbGV0IHN0YXRlOiBSb3V0ZXJTdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICB9O1xuXG4gIC8vIC0tIFN0YXRlZnVsIGludGVybmFsIHZhcmlhYmxlcyB0byBtYW5hZ2UgbmF2aWdhdGlvbnMgLS1cbiAgLy8gQ3VycmVudCBuYXZpZ2F0aW9uIGluIHByb2dyZXNzICh0byBiZSBjb21taXR0ZWQgaW4gY29tcGxldGVOYXZpZ2F0aW9uKVxuICBsZXQgcGVuZGluZ0FjdGlvbjogSGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUG9wO1xuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBwcmV2ZW50IHRoZSBzY3JvbGwgcmVzZXQgaWYgc2Nyb2xsIGNhbm5vdFxuICAvLyBiZSByZXN0b3JlZD9cbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxuICAvLyAgLSBzdWJtaXNzaW9ucyAoY29tcGxldGVkIG9yIGludGVycnVwdGVkKVxuICAvLyAgLSB1c2VSZXZhbGlkYXRlKClcbiAgLy8gIC0gWC1SZW1peC1SZXZhbGlkYXRlIChmcm9tIHJlZGlyZWN0KVxuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdID0gW107XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzOiBzdHJpbmdbXSA9IFtdO1xuICAvLyBBYm9ydENvbnRyb2xsZXJzIGZvciBhbnkgaW4tZmxpZ2h0IGZldGNoZXJzXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj4oKTtcbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcbiAgLy8gVHJhY2sgdGhlIG91dHN0YW5kaW5nIHBlbmRpbmcgbmF2aWdhdGlvbiBkYXRhIGxvYWQgdG8gYmUgY29tcGFyZWQgYWdhaW5zdFxuICAvLyB0aGUgZ2xvYmFsbHkgaW5jcmVtZW50aW5nIGxvYWQgd2hlbiBhIGZldGNoZXIgbG9hZCBsYW5kcyBhZnRlciBhIGNvbXBsZXRlZFxuICAvLyBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCBkYXRhIHJlbG9hZHMgYXMgYSByZXN1bHQgb2YgdGhlaXIgYWN0aW9uc1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9ucyBmcm9tIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4oKTtcbiAgLy8gU3RvcmUgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBmb3IgYWN0aXZlIHJvdXRlIG1hdGNoZXMuICBXaGVuIGFcbiAgLy8gcm91dGUgbG9hZGVyIHJldHVybnMgZGVmZXIoKSB3ZSBzdGljayBvbmUgaW4gaGVyZS4gIFRoZW4sIHdoZW4gYSBuZXN0ZWRcbiAgLy8gcHJvbWlzZSByZXNvbHZlcyB3ZSB1cGRhdGUgbG9hZGVyRGF0YS4gIElmIGEgbmV3IG5hdmlnYXRpb24gc3RhcnRzIHdlXG4gIC8vIGNhbmNlbCBhY3RpdmUgZGVmZXJyZWRzIGZvciBlbGltaW5hdGVkIHJvdXRlcy5cbiAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+KCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiB9KSA9PlxuICAgICAgICBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pXG4gICAgKTtcblxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oSGlzdG9yeUFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgfVxuXG4gIC8vIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzIGZvciB0aGUgcm91dGVyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBub3RpZnkgdGhlIGNhbGxpbmcgY29udGV4dCBvZiB0aGUgY2hhbmdlXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlOiBQYXJ0aWFsPFJvdXRlclN0YXRlPik6IHZvaWQge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZSxcbiAgICB9O1xuICAgIHN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoc3RhdGUpKTtcbiAgfVxuXG4gIC8vIENvbXBsZXRlIGEgbmF2aWdhdGlvbiByZXR1cm5pbmcgdGhlIHN0YXRlLm5hdmlnYXRpb24gYmFjayB0byB0aGUgSURMRV9OQVZJR0FUSU9OXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXG4gIC8vIC0gTG9jYXRpb24gaXMgYSByZXF1aXJlZCBwYXJhbVxuICAvLyAtIE5hdmlnYXRpb24gd2lsbCBhbHdheXMgYmUgc2V0IHRvIElETEVfTkFWSUdBVElPTlxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG5ld1N0YXRlOiBQYXJ0aWFsPE9taXQ8Um91dGVyU3RhdGUsIFwiYWN0aW9uXCIgfCBcImxvY2F0aW9uXCIgfCBcIm5hdmlnYXRpb25cIj4+XG4gICk6IHZvaWQge1xuICAgIC8vIERlZHVjZSBpZiB3ZSdyZSBpbiBhIGxvYWRpbmcvYWN0aW9uUmVsb2FkIHN0YXRlOlxuICAgIC8vIC0gV2UgaGF2ZSBjb21taXR0ZWQgYWN0aW9uRGF0YSBpbiB0aGUgc3RvcmVcbiAgICAvLyAtIFRoZSBjdXJyZW50IG5hdmlnYXRpb24gd2FzIGEgc3VibWlzc2lvblxuICAgIC8vIC0gV2UncmUgcGFzdCB0aGUgc3VibWl0dGluZyBzdGF0ZSBhbmQgaW50byB0aGUgbG9hZGluZyBzdGF0ZVxuICAgIC8vIC0gVGhlIGxvY2F0aW9uIHdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcgaXMgZGlmZmVyZW50IGZyb20gdGhlIHN1Ym1pc3Npb25cbiAgICAvLyAgIGxvY2F0aW9uLCBpbmRpY2F0aW5nIHdlIHJlZGlyZWN0ZWQgZnJvbSB0aGUgYWN0aW9uIChhdm9pZHMgZmFsc2VcbiAgICAvLyAgIHBvc2l0aXZlcyBmb3IgbG9hZGluZy9zdWJtaXNzaW9uUmVkaXJlY3Qgd2hlbiBhY3Rpb25EYXRhIHJldHVybmVkXG4gICAgLy8gICBvbiBhIHByaW9yIHN1Ym1pc3Npb24pXG4gICAgbGV0IGlzQWN0aW9uUmVsb2FkID1cbiAgICAgIHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJlxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1BY3Rpb24/LnNwbGl0KFwiP1wiKVswXSA9PT0gbG9jYXRpb24ucGF0aG5hbWU7XG5cbiAgICAvLyBBbHdheXMgcHJlc2VydmUgYW55IGV4aXN0aW5nIGxvYWRlckRhdGEgZnJvbSByZS11c2VkIHJvdXRlc1xuICAgIGxldCBuZXdMb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YVxuICAgICAgPyB7XG4gICAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdXG4gICAgICAgICAgKSxcbiAgICAgICAgfVxuICAgICAgOiB7fTtcblxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGFjdGlvbkRhdGEgb24gYW55IGNvbXBsZXRlZCBuYXZpZ2F0aW9uIGJleW9uZCB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGFjdGlvbiwgdW5sZXNzIHdlJ3JlIGN1cnJlbnRseSBmaW5pc2hpbmcgdGhlIGxvYWRpbmcvYWN0aW9uUmVsb2FkIHN0YXRlLlxuICAgICAgLy8gRG8gdGhpcyBwcmlvciB0byBzcHJlYWRpbmcgaW4gbmV3U3RhdGUgaW4gY2FzZSB3ZSBnb3QgYmFjayB0byBiYWNrIGFjdGlvbnNcbiAgICAgIC4uLihpc0FjdGlvblJlbG9hZCA/IHt9IDogeyBhY3Rpb25EYXRhOiBudWxsIH0pLFxuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAuLi5uZXdMb2FkZXJEYXRhLFxuICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBzdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHN0YXRlLm5hdmlnYXRpb24uZm9ybURhdGFcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgfSk7XG5cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiB0aGVuIGRvIG5vdCB0b3VjaCBoaXN0b3J5XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlBvcCkge1xuICAgICAgLy8gRG8gbm90aGluZyBmb3IgUE9QIC0gVVJMIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXG4gIC8vIHJlcGxhY2Ugd2l0aCBhbiBvcHRpb25hbCBzdWJtaXNzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKFxuICAgIHRvOiBudW1iZXIgfCBUbyxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyh0bywgb3B0cyk7XG5cbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9XG4gICAgICAob3B0cyAmJiBvcHRzLnJlcGxhY2UpID09PSB0cnVlIHx8IHN1Ym1pc3Npb24gIT0gbnVsbFxuICAgICAgICA/IEhpc3RvcnlBY3Rpb24uUmVwbGFjZVxuICAgICAgICA6IEhpc3RvcnlBY3Rpb24uUHVzaDtcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzXG4gICAgICAgID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXG4gIC8vIGlzIGludGVycnVwdGVkIGJ5IGEgbmF2aWdhdGlvbiwgYWxsb3cgdGhpcyB0byBcInN1Y2NlZWRcIiBieSBjYWxsaW5nIGFsbFxuICAvLyBsb2FkZXJzIGR1cmluZyB0aGUgbmV4dCBsb2FkZXIgcm91bmRcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBzdWJtaXR0aW5nIGFuIGFjdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24sIHdlJ2xsIGp1c3QgbGV0IHRoZSBmb2xsb3cgdXAgbG9hZGVyIGV4ZWN1dGlvbiBjYWxsIGFsbCBsb2FkZXJzXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7IG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbiB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oXG4gICAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbixcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgb3B0cz86IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbjtcbiAgICAgIHBlbmRpbmdFcnJvcj86IEVycm9yUmVzcG9uc2U7XG4gICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24/OiBib29sZWFuO1xuICAgICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIH1cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQWJvcnQgYW55IGluLXByb2dyZXNzIG5hdmlnYXRpb25zIGFuZCBzdGFydCBhIG5ldyBvbmUuIFVuc2V0IGFueSBvbmdvaW5nXG4gICAgLy8gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb25zIHVubGVzcyB0b2xkIG90aGVyd2lzZSwgc2luY2Ugd2Ugd2FudCB0aGlzXG4gICAgLy8gbmV3IG5hdmlnYXRpb24gdG8gdXBkYXRlIGhpc3Rvcnkgbm9ybWFsbHlcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPVxuICAgICAgKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZXZlcnkgdGltZSB3ZSBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uLFxuICAgIC8vIGFuZCB0cmFjayB3aGV0aGVyIHdlIHNob3VsZCByZXNldCBzY3JvbGwgb24gY29tcGxldGlvblxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgaW5pdC5iYXNlbmFtZSk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9ID0gZ2V0Tm90Rm91bmRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIGRlZmVycmVkIG9uIDQwNHMgc2luY2Ugd2UgZG9uJ3Qga2VlcCBhbnkgcm91dGVzXG4gICAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaXQncyBvbmx5IGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAoaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvblxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvcixcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuc3VibWlzc2lvbikge1xuICAgICAgLy8gQ2FsbCBhY3Rpb24gaWYgd2UgcmVjZWl2ZWQgYW4gYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgIGxldCBhY3Rpb25PdXRwdXQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHsgcmVwbGFjZTogb3B0cy5yZXBsYWNlIH1cbiAgICAgICk7XG5cbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRGF0YTtcbiAgICAgIHBlbmRpbmdFcnJvciA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRXJyb3I7XG5cbiAgICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgLi4ub3B0cy5zdWJtaXNzaW9uLFxuICAgICAgfTtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBDYWxsIGxvYWRlcnNcbiAgICBsZXQgeyBzaG9ydENpcmN1aXRlZCwgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhLFxuICAgICAgcGVuZGluZ0Vycm9yXG4gICAgKTtcblxuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG5vdyB0aGF0IHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmXG4gICAgLy8gd2Ugc2hvcnQgY2lyY3VpdGVkIGJlY2F1c2UgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gbWF0Y2hlZCBieSB0aGUgbGVhZiByb3V0ZSBmb3IgdGhpcyBuYXZpZ2F0aW9uIGFuZCBoYW5kbGVcbiAgLy8gcmVkaXJlY3RzL2Vycm9yc1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24oXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3B0cz86IHsgcmVwbGFjZT86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPEhhbmRsZUFjdGlvblJlc3VsdD4ge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG5cbiAgICAvLyBQdXQgdXMgaW4gYSBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJTdWJtaXR0aW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgIH07XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0pO1xuXG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ6IERhdGFSZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICAgIHJlc3VsdCA9IGdldE1ldGhvZE5vdEFsbG93ZWRSZXN1bHQobG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJhY3Rpb25cIiwgcmVxdWVzdCwgYWN0aW9uTWF0Y2gpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZWRpcmVjdE5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcmVzdWx0LmxvY2F0aW9uKSxcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIH07XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICByZWRpcmVjdE5hdmlnYXRpb24sXG4gICAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gSGlzdG9yeUFjdGlvbi5QdXNoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZW5kaW5nQWN0aW9uRXJyb3I6IHsgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgYWxsIGFwcGxpY2FibGUgbG9hZGVycyBmb3IgdGhlIGdpdmVuIG1hdGNoZXMsIGhhbmRsaW5nIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG92ZXJyaWRlTmF2aWdhdGlvbj86IE5hdmlnYXRpb24sXG4gICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb24sXG4gICAgcmVwbGFjZT86IGJvb2xlYW4sXG4gICAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gICAgcGVuZGluZ0Vycm9yPzogUm91dGVEYXRhXG4gICk6IFByb21pc2U8SGFuZGxlTG9hZGVyc1Jlc3VsdD4ge1xuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHJpZ2h0IG5hdmlnYXRpb24gd2Ugd2FudCB0byB1c2UgZm9yIGRhdGEgbG9hZGluZ1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBpZiAoIWxvYWRpbmdOYXZpZ2F0aW9uKSB7XG4gICAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSxcbiAgICAgIHBlbmRpbmdFcnJvcixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXNcbiAgICApO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICAgIChyb3V0ZUlkKSA9PlxuICAgICAgICAhKG1hdGNoZXMgJiYgbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHxcbiAgICAgICAgKG1hdGNoZXNUb0xvYWQgJiYgbWF0Y2hlc1RvTG9hZC5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSlcbiAgICApO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShzdGF0ZS5sb2FkZXJEYXRhLCB7fSwgbWF0Y2hlcyksXG4gICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGEgfHwgbnVsbCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9uLCB3ZSByZW1haW4gaW4gb3VyIGN1cnJlbnQgaWRsZVxuICAgIC8vIHN0YXRlLiAgSWYgbm90LCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBvdXIgbG9hZGluZyBzdGF0ZSBhbmQgbG9hZCBkYXRhLFxuICAgIC8vIHByZXNlcnZpbmcgYW55IG5ldyBhY3Rpb24gZGF0YSBvciBleGlzdGluZyBhY3Rpb24gZGF0YSAoaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBhIHJldmFsaWRhdGlvbiBpbnRlcnJ1cHRpbmcgYW4gYWN0aW9uUmVsb2FkKVxuICAgIGlmICghaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChba2V5XSkgPT4ge1xuICAgICAgICBjb25zdCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgZGF0YTogZmV0Y2hlciAmJiBmZXRjaGVyLmRhdGEsXG4gICAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB8fCBzdGF0ZS5hY3Rpb25EYXRhIHx8IG51bGwsXG4gICAgICAgIC4uLihyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKFtrZXldKSA9PlxuICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIhKVxuICAgICk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBfYWZ0ZXJfIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZiB3ZSBzaG9ydFxuICAgIC8vIGNpcmN1aXRlZCBiZWNhdXNlIGZldGNoQ29udHJvbGxlcnMgd291bGQgaGF2ZSBiZWVuIGFib3J0ZWQgYW5kXG4gICAgLy8gcmVhc3NpZ25lZCB0byBuZXcgY29udHJvbGxlcnMgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChba2V5XSkgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KSk7XG5cbiAgICAvLyBJZiBhbnkgbG9hZGVycyByZXR1cm5lZCBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uID0gZ2V0TG9hZGVyUmVkaXJlY3Qoc3RhdGUsIHJlZGlyZWN0KTtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlZGlyZWN0LCByZWRpcmVjdE5hdmlnYXRpb24sIHJlcGxhY2UpO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHBlbmRpbmdFcnJvcixcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKChhYm9ydGVkKSA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICAuLi4oZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgIDoge30pLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk6IHN0cmluZyk6IEZldGNoZXI8VERhdGE+IHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIG9wdHM/OiBSb3V0ZXJGZXRjaE9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJyb3V0ZXIuZmV0Y2goKSB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgK1xuICAgICAgICAgIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICtcbiAgICAgICAgICBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGhyZWYsIGluaXQuYmFzZW5hbWUpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgbmV3IEVycm9yUmVzcG9uc2UoNDA0LCBcIk5vdCBGb3VuZFwiLCBudWxsKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGhyZWYsIG9wdHMsIHRydWUpO1xuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuXG4gICAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICAgIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIFtwYXRoLCBtYXRjaF0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvblxuICApIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbikge1xuICAgICAgbGV0IHsgZXJyb3IgfSA9IGdldE1ldGhvZE5vdEFsbG93ZWRSZXN1bHQocGF0aCk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBmZXRjaGVyXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChwYXRoLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLCBzdWJtaXNzaW9uKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIGZldGNoUmVxdWVzdCwgbWF0Y2gpO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgbGV0IGxvYWRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICAgIGxldCByZWRpcmVjdE5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgYWN0aW9uUmVzdWx0LmxvY2F0aW9uKSxcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIH07XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihhY3Rpb25SZXN1bHQsIHJlZGlyZWN0TmF2aWdhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJkZWZlcigpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWN0aW9uc1wiKTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIG5hdmlnYXRpb25cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGluaXQuYmFzZW5hbWUpXG4gICAgICAgIDogc3RhdGUubWF0Y2hlcztcblxuICAgIGludmFyaWFudChtYXRjaGVzLCBcIkRpZG4ndCBmaW5kIGFueSBtYXRjaGVzIGFmdGVyIGZldGNoZXIgYWN0aW9uXCIpO1xuXG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG5cbiAgICBsZXQgbG9hZEZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZGF0YTogYWN0aW9uUmVzdWx0LmRhdGEsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIHsgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGEgfSxcbiAgICAgIHVuZGVmaW5lZCwgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICAgIGZldGNoTG9hZE1hdGNoZXNcbiAgICApO1xuXG4gICAgLy8gUHV0IGFsbCByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgaW50byB0aGUgbG9hZGluZyBzdGF0ZSwgZXhjZXB0IGZvciB0aGVcbiAgICAvLyBjdXJyZW50IGZldGNoZXIgd2hpY2ggd2Ugd2FudCB0byBrZWVwIGluIGl0J3MgY3VycmVudCBsb2FkaW5nIHN0YXRlIHdoaWNoXG4gICAgLy8gY29udGFpbnMgaXQncyBhY3Rpb24gc3VibWlzc2lvbiBpbmZvICsgYWN0aW9uIGRhdGFcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1xuICAgICAgLmZpbHRlcigoW3N0YWxlS2V5XSkgPT4gc3RhbGVLZXkgIT09IGtleSlcbiAgICAgIC5mb3JFYWNoKChbc3RhbGVLZXldKSA9PiB7XG4gICAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciAmJiBleGlzdGluZ0ZldGNoZXIuZGF0YSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHN0YWxlS2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgICB9KTtcblxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgbGV0IHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9XG4gICAgICBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0XG4gICAgICApO1xuXG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgoW3N0YWxlS2V5XSkgPT5cbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHN0YWxlS2V5KVxuICAgICk7XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uID0gZ2V0TG9hZGVyUmVkaXJlY3Qoc3RhdGUsIHJlZGlyZWN0KTtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlZGlyZWN0LCByZWRpcmVjdE5hdmlnYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgZGF0YTogYWN0aW9uUmVzdWx0LmRhdGEsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcblxuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5hdmlnYXRpb24gbG9hZGluZyBzdGF0ZSBhbmQgdGhpcyBmZXRjaGVyIGlzXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcbiAgICAvLyBuYXZpZ2F0aW9uIGFuZCBjb21wbGV0ZSBpdCB3aXRoIHRoZSBmZXRjaGVyIGRhdGFcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWRcbiAgICApIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuXG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xuICAgICAgLy8gbG9hZGVyRGF0YSBmb3IgbG9hZGVycyB0aGF0IGRpZCBub3QgbmVlZCB0byByZWxvYWQuICBXZSBoYXZlIHRvXG4gICAgICAvLyBtYW51YWxseSBtZXJnZSBoZXJlIHNpbmNlIHdlIGFyZW4ndCBnb2luZyB0aHJvdWdoIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShzdGF0ZS5sb2FkZXJEYXRhLCBsb2FkZXJEYXRhLCBtYXRjaGVzKSxcbiAgICAgICAgLi4uKGRpZEFib3J0RmV0Y2hMb2FkcyA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fSksXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIHRoZSBtYXRjaGVkIGxvYWRlciBmb3IgZmV0Y2hlci5sb2FkKCksIGhhbmRsaW5nIHJlZGlyZWN0cywgZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICApIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3MgbG9hZGluZyBzdGF0ZVxuICAgIGxldCBsb2FkaW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciAmJiBleGlzdGluZ0ZldGNoZXIuZGF0YSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRpbmdGZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIC8vIENhbGwgdGhlIGxvYWRlciBmb3IgdGhpcyBmZXRjaGVyIHJvdXRlIG1hdGNoXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChwYXRoLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaFxuICAgICk7XG5cbiAgICAvLyBEZWZlcnJlZCBpc24ndCBzdXBwb3J0ZWQgb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPVxuICAgICAgICAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fFxuICAgICAgICByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91IG91ciBvd24gZmV0Y2hlclxuICAgIC8vIHJlLWxvYWQgd2hpY2ggd291bGQgaGF2ZSBwdXQgX25ld18gY29udHJvbGxlciBpcyBpbiBmZXRjaENvbnRyb2xsZXJzXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvYWRlciB0aHJldyBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uID0gZ2V0TG9hZGVyUmVkaXJlY3Qoc3RhdGUsIHJlc3VsdCk7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXN1bHQsIHJlZGlyZWN0TmF2aWdhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIC8vIFRPRE86IEluIHJlbWl4LCB0aGlzIHdvdWxkIHJlc2V0IHRvIElETEVfTkFWSUdBVElPTiBpZiBpdCB3YXMgYSBjYXRjaCAtXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRvIGJlaGF2ZSBhbnkgZGlmZmVyZW50bHkgd2l0aCBvdXIgbm9uLXJlZGlyZWN0IGVycm9ycz9cbiAgICAgIC8vIFdoYXQgaWYgaXQgd2FzIGEgbm9uLXJlZGlyZWN0IFJlc3BvbnNlP1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIHJlZGlyZWN0cyByZXR1cm5lZCBmcm9tIGFuIGFjdGlvbiBvciBsb2FkZXIuXG4gICAqIE5vcm1hbGx5LCBhIHJlZGlyZWN0IFwicmVwbGFjZXNcIiB0aGUgbmF2aWdhdGlvbiB0aGF0IHRyaWdnZXJlZCBpdC4gIFNvLCBmb3JcbiAgICogZXhhbXBsZTpcbiAgICpcbiAgICogIC0gdXNlciBpcyBvbiAvYVxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcbiAgICogIC0gbG9hZGVyIGZvciAvYiByZWRpcmVjdHMgdG8gL2NcbiAgICpcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcbiAgICogdGhlbiByZXBsYWNlIGl0IHdpdGggL2Mgd2hlbiBpdCBlbmNvdW50ZXJlZCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UuICBJblxuICAgKiB0aGUgZW5kIGl0IHdvdWxkIG9ubHkgZXZlciB1cGRhdGUgdGhlIFVSTCBiYXIgd2l0aCAvYy5cbiAgICpcbiAgICogSW4gY2xpZW50LXNpZGUgcm91dGluZyB1c2luZyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlLCB3ZSBhaW0gdG8gZW11bGF0ZVxuICAgKiB0aGlzIGJlaGF2aW9yIGFuZCB3ZSBhbHNvIGRvIG5vdCB1cGRhdGUgaGlzdG9yeSB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcbiAgICogYWN0dWFsbHkgdG91Y2ggaGlzdG9yeSB1bnRpbCB3ZSd2ZSBwcm9jZXNzZWQgcmVkaXJlY3RzLCBzbyB3ZSBqdXN0IHVzZVxuICAgKiB0aGUgaGlzdG9yeSBhY3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvbiAoUFVTSCBvciBSRVBMQUNFKS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgIHJlZGlyZWN0OiBSZWRpcmVjdFJlc3VsdCxcbiAgICBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uLFxuICAgIHJlcGxhY2U/OiBib29sZWFuXG4gICkge1xuICAgIGlmIChyZWRpcmVjdC5yZXZhbGlkYXRlKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgbmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIFwiRXhwZWN0ZWQgYSBsb2NhdGlvbiBvbiB0aGUgcmVkaXJlY3QgbmF2aWdhdGlvblwiXG4gICAgKTtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICBsZXQgcmVkaXJlY3RIaXN0b3J5QWN0aW9uID1cbiAgICAgIHJlcGxhY2UgPT09IHRydWUgPyBIaXN0b3J5QWN0aW9uLlJlcGxhY2UgOiBIaXN0b3J5QWN0aW9uLlB1c2g7XG4gICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgbmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBuYXZpZ2F0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGZldGNoZXJzVG9Mb2FkOiBSZXZhbGlkYXRpbmdGZXRjaGVyW10sXG4gICAgcmVxdWVzdDogUmVxdWVzdFxuICApIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtKSA9PiBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbSkpLFxuICAgICAgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKChbLCBocmVmLCBtYXRjaF0pID0+XG4gICAgICAgIGNhbGxMb2FkZXJPckFjdGlvbihcImxvYWRlclwiLCBjcmVhdGVSZXF1ZXN0KGhyZWYsIHJlcXVlc3Quc2lnbmFsKSwgbWF0Y2gpXG4gICAgICApLFxuICAgIF0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhXG4gICAgICApLFxuICAgICAgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgICAgICAgY3VycmVudE1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcCgoWywgLCBtYXRjaF0pID0+IG1hdGNoKSxcbiAgICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICB0cnVlXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycnVwdEFjdGl2ZUxvYWRzKCkge1xuICAgIC8vIEV2ZXJ5IGludGVycnVwdGlvbiB0cmlnZ2VycyBhIHJldmFsaWRhdGlvblxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG5cbiAgICAvLyBBYm9ydCBpbi1mbGlnaHQgZmV0Y2hlciBsb2Fkc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMucHVzaChrZXkpO1xuICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZldGNoZXJFcnJvcihrZXk6IHN0cmluZywgcm91dGVJZDogc3RyaW5nLCBlcnJvcjogYW55KSB7XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvcixcbiAgICAgIH0sXG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXk6IHN0cmluZykge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgYEV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6ICR7a2V5fWApO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzOiBzdHJpbmdbXSkge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgZGF0YTogZmV0Y2hlci5kYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpOiB2b2lkIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgIHByZWRpY2F0ZT86IChyb3V0ZUlkOiBzdHJpbmcpID0+IGJvb2xlYW5cbiAgKTogc3RyaW5nW10ge1xuICAgIGxldCBjYW5jZWxsZWRSb3V0ZUlkczogc3RyaW5nW10gPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuXG4gIC8vIE9wdCBpbiB0byBjYXB0dXJpbmcgYW5kIHJlcG9ydGluZyBzY3JvbGwgcG9zaXRpb25zIGR1cmluZyBuYXZpZ2F0aW9ucyxcbiAgLy8gdXNlZCBieSB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgcG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGdldFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uLFxuICAgIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb25cbiAgKSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IGdldEtleSB8fCAoKGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5rZXkpO1xuXG4gICAgLy8gUGVyZm9ybSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24sIHNpbmNlIHdlIG1pc3MgdGhlIGJvYXQgb25cbiAgICAvLyB0aGUgaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGJlY2F1c2Ugd2UndmUgbm90IHlldCByZW5kZXJlZCA8U2Nyb2xsUmVzdG9yYXRpb24vPlxuICAgIC8vIGFuZCB0aGVyZWZvcmUgaGF2ZSBubyBzYXZlZFNjcm9sbFBvc2l0aW9ucyBhdmFpbGFibGVcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBudWxsO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiB2b2lkIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMgJiYgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgJiYgZ2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGxldCB1c2VyTWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtKSA9PlxuICAgICAgICBjcmVhdGVVc2VNYXRjaGVzTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSlcbiAgICAgICk7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIHVzZXJNYXRjaGVzKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQgdXNlck1hdGNoZXMgPSBtYXRjaGVzLm1hcCgobSkgPT5cbiAgICAgICAgY3JlYXRlVXNlTWF0Y2hlc01hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpXG4gICAgICApO1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCB1c2VyTWF0Y2hlcykgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gaW5pdC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGluaXRpYWxpemUsXG4gICAgc3Vic2NyaWJlLFxuICAgIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uLFxuICAgIG5hdmlnYXRlLFxuICAgIGZldGNoLFxuICAgIHJldmFsaWRhdGUsXG4gICAgY3JlYXRlSHJlZixcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXIsXG4gICAgZGlzcG9zZSxcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gdW5zdGFibGVfY3JlYXRlU3RhdGljSGFuZGxlcihcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W11cbik6IFN0YXRpY0hhbmRsZXIge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byB1bnN0YWJsZV9jcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzKTtcblxuICBhc3luYyBmdW5jdGlvbiBxdWVyeShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICk6IFByb21pc2U8U3RhdGljSGFuZGxlckNvbnRleHQgfCBSZXNwb25zZT4ge1xuICAgIGxldCB7IGxvY2F0aW9uLCByZXN1bHQgfSA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIC4uLnJlc3VsdCB9O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0OiBSZXF1ZXN0LCByb3V0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCB7IHJlc3VsdCB9ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIHJvdXRlSWQpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQuZXJyb3JzKVswXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gV2hpbGUgd2UgYWx3YXlzIHJlLXRocm93IFJlc3BvbnNlcyByZXR1cm5lZCBmcm9tIGxvYWRlcnMvYWN0aW9uc1xuICAgICAgLy8gZGlyZWN0bHkgZm9yIHJvdXRlIHJlcXVlc3RzIGFuZCBwcmV2ZW50IHRoZSB1bndyYXBwaW5nIGludG8gYW5cbiAgICAgIC8vIEVycm9yUmVzcG9uc2UsIHdlIHN0aWxsIG5lZWQgdGhpcyBmb3IgZXJyb3IgY2FzZXMgX3ByaW9yXyB0aGVcbiAgICAgIC8vIGV4ZWN1dGlvbiBvZiB0aGUgbG9hZGVyL2FjdGlvbiwgc3VjaCBhcyBhIDQwNC80MDUgZXJyb3IuXG4gICAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZXJyb3IuZGF0YSwge1xuICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IGVycm9yLnN0YXR1c1RleHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ290IGJhY2sgcmVzdWx0LmVycm9ycywgdGhhdCBtZWFucyB0aGUgbG9hZGVyL2FjdGlvbiB0aHJld1xuICAgICAgLy8gX3NvbWV0aGluZ18gdGhhdCB3YXNuJ3QgYSBSZXNwb25zZSwgYnV0IGl0J3Mgbm90IGd1YXJhbnRlZWQvcmVxdWlyZWRcbiAgICAgIC8vIHRvIGJlIGFuIGBpbnN0YW5jZW9mIEVycm9yYCBlaXRoZXIsIHNvIHdlIGhhdmUgdG8gdXNlIHRocm93IGhlcmUgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBcImVycm9yXCIgc3RhdGUgb3V0c2lkZSBvZiBxdWVyeUltcGwuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgbGV0IHJvdXRlRGF0YSA9IFtyZXN1bHQuYWN0aW9uRGF0YSwgcmVzdWx0LmxvYWRlckRhdGFdLmZpbmQoKHYpID0+IHYpO1xuICAgIGxldCB2YWx1ZSA9IE9iamVjdC52YWx1ZXMocm91dGVEYXRhIHx8IHt9KVswXTtcblxuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UodmFsdWUuZGF0YSwge1xuICAgICAgICBzdGF0dXM6IHZhbHVlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogdmFsdWUuc3RhdHVzVGV4dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHJvdXRlSWQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIHJlc3VsdDogT21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiPiB8IFJlc3BvbnNlO1xuICB9PiB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVxdWVzdC5tZXRob2QgIT09IFwiSEVBRFwiLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSBkbyBub3Qgc3VwcG9ydCBIRUFEIHJlcXVlc3RzXCJcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcblxuICAgIGxldCB7IGxvY2F0aW9uLCBtYXRjaGVzLCBzaG9ydENpcmN1aXRTdGF0ZSB9ID0gbWF0Y2hSZXF1ZXN0KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJvdXRlSWRcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4geyBsb2NhdGlvbiwgcmVzdWx0OiBzaG9ydENpcmN1aXRTdGF0ZSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLFxuICAgICAgICAgIHJvdXRlSWQgIT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBsb2NhdGlvbiwgcmVzdWx0IH07XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJvdXRlSWQgIT0gbnVsbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbG9jYXRpb24sIHJlc3VsdDogZSB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgYWN0aW9uTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uKSB7XG4gICAgICBsZXQgaHJlZiA9IGNyZWF0ZUhyZWYobmV3IFVSTChyZXF1ZXN0LnVybCkpO1xuICAgICAgcmVzdWx0ID0gZ2V0TWV0aG9kTm90QWxsb3dlZFJlc3VsdChocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3RcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbExvYWRlck9yQWN0aW9uLCBidXQgdGhlIHR5cGUgbmFycm93aW5nIGhlcmUga2VlcHMgVFMgaGFwcHkgYW5kIHdlXG4gICAgICAvLyBjYW4gZ2V0IGJhY2sgb24gdGhlIFwidGhyb3cgYWxsIHJlZGlyZWN0IHJlc3BvbnNlc1wiIHRyYWluIGhlcmUgc2hvdWxkXG4gICAgICAvLyB0aGlzIGV2ZXIgaGFwcGVuIDovXG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogcmVzdWx0LmxvY2F0aW9uLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgbGV0IGNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCB7XG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKVxuICAgICAgICAgID8gcmVzdWx0LmVycm9yLnN0YXR1c1xuICAgICAgICAgIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4uKHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge30pLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLihyZXN1bHQuc3RhdHVzQ29kZSA/IHsgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfSA6IHt9KSxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEsXG4gICAgICB9LFxuICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuLFxuICAgIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YVxuICApOiBQcm9taXNlPFxuICAgIHwgT21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImFjdGlvbkhlYWRlcnNcIj5cbiAgICB8IFJlc3BvbnNlXG4gID4ge1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICBtYXRjaGVzLFxuICAgICAgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXVxuICAgICkuZmlsdGVyKChtKSA9PiBtLnJvdXRlLmxvYWRlcik7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25FcnJvciB8fCBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbSwgdHJ1ZSwgaXNSb3V0ZVJlcXVlc3QpXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWRgKTtcbiAgICB9XG5cbiAgICAvLyBDYW4ndCBkbyBhbnl0aGluZyB3aXRoIHRoZXNlIHdpdGhvdXQgdGhlIFJlbWl4IHNpZGUgb2YgdGhpbmdzLCBzbyBqdXN0XG4gICAgLy8gY2FuY2VsIHRoZW0gZm9yIG5vd1xuICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC5kZWZlcnJlZERhdGEuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25FcnJvclxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1hdGNoZXMsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoUmVxdWVzdChcbiAgICByZXE6IFJlcXVlc3QsXG4gICAgcm91dGVJZD86IHN0cmluZ1xuICApOiB7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcbiAgICByb3V0ZU1hdGNoPzogQWdub3N0aWNEYXRhUm91dGVNYXRjaDtcbiAgICBzaG9ydENpcmN1aXRTdGF0ZT86IE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIj47XG4gIH0ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24pO1xuICAgIGlmIChtYXRjaGVzICYmIHJvdXRlSWQpIHtcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcigobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCk7XG4gICAgfVxuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCB3aXRoIGEgNDA0IGlmIHdlIG1hdGNoIG5vdGhpbmdcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSA9IGdldE5vdEZvdW5kTWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIHNob3J0Q2lyY3VpdFN0YXRlOiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXR1c0NvZGU6IDQwNCxcbiAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIG1hdGNoZXMgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlLFxuICB9O1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIZWxwZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gIHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgY29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIGVycm9yOiBhbnlcbikge1xuICBsZXQgbmV3Q29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvcixcbiAgICB9LFxuICB9O1xuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cblxuLy8gTm9ybWFsaXplIG5hdmlnYXRpb24gb3B0aW9ucyBieSBjb252ZXJ0aW5nIGZvcm1NZXRob2Q9R0VUIGZvcm1EYXRhIG9iamVjdHMgdG9cbi8vIFVSTFNlYXJjaFBhcmFtcyBzbyB0aGV5IGJlaGF2ZSBpZGVudGljYWxseSB0byBsaW5rcyB3aXRoIHF1ZXJ5IHBhcmFtc1xuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICB0bzogVG8sXG4gIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMsXG4gIGlzRmV0Y2hlciA9IGZhbHNlXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZTtcbn0ge1xuICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG5cbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAoIShcImZvcm1NZXRob2RcIiBpbiBvcHRzKSAmJiAhKFwiZm9ybURhdGFcIiBpbiBvcHRzKSkpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAhPSBudWxsICYmIG9wdHMuZm9ybU1ldGhvZCAhPT0gXCJnZXRcIikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICBmb3JtTWV0aG9kOiBvcHRzLmZvcm1NZXRob2QsXG4gICAgICAgIGZvcm1BY3Rpb246IGNyZWF0ZUhyZWYocGFyc2VQYXRoKHBhdGgpKSxcbiAgICAgICAgZm9ybUVuY1R5cGU6XG4gICAgICAgICAgKG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSkgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgICAgZm9ybURhdGE6IG9wdHMuZm9ybURhdGEsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvLyBObyBmb3JtRGF0YSB0byBmbGF0dGVuIGZvciBHRVQgc3VibWlzc2lvblxuICBpZiAoIW9wdHMuZm9ybURhdGEpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cblxuICAvLyBGbGF0dGVuIHN1Ym1pc3Npb24gb250byBVUkxTZWFyY2hQYXJhbXMgZm9yIEdFVCBzdWJtaXNzaW9uc1xuICBsZXQgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgdHJ5IHtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgLy8gU2luY2UgZmV0Y2hlciBHRVQgc3VibWlzc2lvbnMgb25seSBydW4gYSBzaW5nbGUgbG9hZGVyIChhcyBvcHBvc2VkIHRvXG4gICAgLy8gbmF2aWdhdGlvbiBHRVQgc3VibWlzc2lvbnMgd2hpY2ggcnVuIGFsbCBsb2FkZXJzKSwgd2UgbmVlZCB0byBwcmVzZXJ2ZVxuICAgIC8vIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gICAgaWYgKFxuICAgICAgaXNGZXRjaGVyICYmXG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCAmJlxuICAgICAgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKVxuICAgICkge1xuICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIFwiXCIpO1xuICAgIH1cbiAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlKFxuICAgICAgICA0MDAsXG4gICAgICAgIFwiQmFkIFJlcXVlc3RcIixcbiAgICAgICAgXCJDYW5ub3Qgc3VibWl0IGJpbmFyeSBmb3JtIGRhdGEgdXNpbmcgR0VUXCJcbiAgICAgICksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCkgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGVyUmVkaXJlY3QoXG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgcmVkaXJlY3Q6IFJlZGlyZWN0UmVzdWx0XG4pOiBOYXZpZ2F0aW9uIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1EYXRhIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcmVkaXJlY3QubG9jYXRpb24pLFxuICAgIGZvcm1NZXRob2Q6IGZvcm1NZXRob2QgfHwgdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IGZvcm1BY3Rpb24gfHwgdW5kZWZpbmVkLFxuICAgIGZvcm1FbmNUeXBlOiBmb3JtRW5jVHlwZSB8fCB1bmRlZmluZWQsXG4gICAgZm9ybURhdGE6IGZvcm1EYXRhIHx8IHVuZGVmaW5lZCxcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJvdW5kYXJ5SWQ/OiBzdHJpbmdcbikge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBpc1JldmFsaWRhdGlvblJlcXVpcmVkOiBib29sZWFuLFxuICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10sXG4gIGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10sXG4gIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhLFxuICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGEsXG4gIGZldGNoTG9hZE1hdGNoZXM/OiBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD5cbik6IFtBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sIFJldmFsaWRhdGluZ0ZldGNoZXJbXV0ge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF1cbiAgICA6IHBlbmRpbmdBY3Rpb25EYXRhXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXVxuICAgIDogbnVsbDtcblxuICAvLyBQaWNrIG5hdmlnYXRpb24gbWF0Y2hlcyB0aGF0IGFyZSBuZXQtbmV3IG9yIHF1YWxpZnkgZm9yIHJldmFsaWRhdGlvblxuICBsZXQgYm91bmRhcnlJZCA9IHBlbmRpbmdFcnJvciA/IE9iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF0gOiB1bmRlZmluZWQ7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBib3VuZGFyeUlkKTtcbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PlxuICAgICAgbWF0Y2gucm91dGUubG9hZGVyICE9IG51bGwgJiZcbiAgICAgIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8XG4gICAgICAgIC8vIElmIHRoaXMgcm91dGUgaGFkIGEgcGVuZGluZyBkZWZlcnJlZCBjYW5jZWxsZWQgaXQgbXVzdCBiZSByZXZhbGlkYXRlZFxuICAgICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKChpZCkgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKSB8fFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKFxuICAgICAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIHN0YXRlLm1hdGNoZXNbaW5kZXhdLFxuICAgICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgICAgICBhY3Rpb25SZXN1bHRcbiAgICAgICAgKSlcbiAgKTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMgJiZcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKFtocmVmLCBtYXRjaF0sIGtleSkgPT4ge1xuICAgICAgLy8gVGhpcyBmZXRjaGVyIHdhcyBjYW5jZWxsZWQgZnJvbSBhIHByaW9yIGFjdGlvbiBzdWJtaXNzaW9uIC0gZm9yY2UgcmVsb2FkXG4gICAgICBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaChba2V5LCBocmVmLCBtYXRjaF0pO1xuICAgICAgfSBlbHNlIGlmIChpc1JldmFsaWRhdGlvblJlcXVpcmVkKSB7XG4gICAgICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgICAgIGFjdGlvblJlc3VsdFxuICAgICAgICApO1xuICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goW2tleSwgaHJlZiwgbWF0Y2hdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cblxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoXG4gIGN1cnJlbnRMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgaXNOZXcgPVxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8XG4gICAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICAgIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2gucm91dGUuaWQ7XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcblxuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuXG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHxcbiAgICAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgKGN1cnJlbnRQYXRoICYmXG4gICAgICBjdXJyZW50UGF0aC5lbmRzV2l0aChcIipcIikgJiZcbiAgICAgIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdKVxuICApO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKFxuICBjdXJyZW50TG9jYXRpb246IHN0cmluZyB8IExvY2F0aW9uLFxuICBjdXJyZW50TWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ6IGJvb2xlYW4sXG4gIGFjdGlvblJlc3VsdDogRGF0YVJlc3VsdCB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCBjdXJyZW50VXJsID0gY3JlYXRlVVJMKGN1cnJlbnRMb2NhdGlvbik7XG4gIGxldCBjdXJyZW50UGFyYW1zID0gY3VycmVudE1hdGNoLnBhcmFtcztcbiAgbGV0IG5leHRVcmwgPSBjcmVhdGVVUkwobG9jYXRpb24pO1xuICBsZXQgbmV4dFBhcmFtcyA9IG1hdGNoLnBhcmFtcztcblxuICAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGFzIHRvIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAvLyBwcm92aWRlcyBpdCdzIG93biBpbXBsZW1lbnRhdGlvbiwgdGhlbiB3ZSBnaXZlIHRoZW0gZnVsbCBjb250cm9sIGJ1dFxuICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAvLyBOb3RlIHRoYXQgZmV0Y2hlcnMgYWx3YXlzIHByb3ZpZGUgdGhlIHNhbWUgY3VycmVudC9uZXh0IGxvY2F0aW9ucyBzbyB0aGVcbiAgLy8gVVJMLWJhc2VkIGNoZWNrcyBoZXJlIGRvbid0IGFwcGx5IHRvIGZldGNoZXIgc2hvdWxkUmV2YWxpZGF0ZSBjYWxsc1xuICBsZXQgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPVxuICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSB8fFxuICAgIC8vIENsaWNrZWQgdGhlIHNhbWUgbGluaywgcmVzdWJtaXR0ZWQgYSBHRVQgZm9ybVxuICAgIGN1cnJlbnRVcmwudG9TdHJpbmcoKSA9PT0gbmV4dFVybC50b1N0cmluZygpIHx8XG4gICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2ggfHxcbiAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRlLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkO1xuXG4gIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSh7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gIHR5cGU6IFwibG9hZGVyXCIgfCBcImFjdGlvblwiLFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgc2tpcFJlZGlyZWN0czogYm9vbGVhbiA9IGZhbHNlLFxuICBpc1JvdXRlUmVxdWVzdDogYm9vbGVhbiA9IGZhbHNlXG4pOiBQcm9taXNlPERhdGFSZXN1bHQ+IHtcbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG5cbiAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgbGV0IHJlamVjdDogKCkgPT4gdm9pZDtcbiAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICBsZXQgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcblxuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaW52YXJpYW50PEZ1bmN0aW9uPihcbiAgICAgIGhhbmRsZXIsXG4gICAgICBgQ291bGQgbm90IGZpbmQgdGhlICR7dHlwZX0gdG8gcnVuIG9uIHRoZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgcm91dGVgXG4gICAgKTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICBoYW5kbGVyKHsgcmVxdWVzdCwgcGFyYW1zOiBtYXRjaC5wYXJhbXMgfSksXG4gICAgICBhYm9ydFByb21pc2UsXG4gICAgXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuXG4gICAgLy8gRm9yIFNTUiBzaW5nbGUtcm91dGUgcmVxdWVzdHMsIHdlIHdhbnQgdG8gaGFuZCBSZXNwb25zZXMgYmFjayBkaXJlY3RseVxuICAgIC8vIHdpdGhvdXQgdW53cmFwcGluZ1xuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgdGhyb3cgcmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgU1NSIGRvY3VtZW50IHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdFxuICAgICAgaWYgKHNraXBSZWRpcmVjdHMpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZTogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpICE9PSBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YTogYW55O1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlKHN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0VHlwZSwgZXJyb3I6IHJlc3VsdCB9O1xuICB9XG5cbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlZmVycmVkRGF0YSkge1xuICAgIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQsIGRlZmVycmVkRGF0YTogcmVzdWx0IH07XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHJlc3VsdCB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxuICBsb2NhdGlvbjogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4pOiBSZXF1ZXN0IHtcbiAgbGV0IHVybCA9IGNyZWF0ZVVSTChsb2NhdGlvbikudG9TdHJpbmcoKTtcbiAgbGV0IGluaXQ6IFJlcXVlc3RJbml0ID0geyBzaWduYWwgfTtcblxuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlLCBmb3JtRGF0YSB9ID0gc3VibWlzc2lvbjtcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpbml0LmJvZHkgPVxuICAgICAgZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgPyBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSlcbiAgICAgICAgOiBmb3JtRGF0YTtcbiAgfVxuXG4gIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGE6IEZvcm1EYXRhKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLFxuICAgICAgJ0ZpbGUgaW5wdXRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggZW5jVHlwZSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCAnICtcbiAgICAgICAgJ3BsZWFzZSB1c2UgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgaW5zdGVhZC4nXG4gICAgKTtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgcGVuZGluZ0Vycm9yOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQsXG4gIGFjdGl2ZURlZmVycmVkcz86IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbDtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbn0ge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXSA9IHt9O1xuICBsZXQgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGwgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz4gPSB7fTtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IE9iamVjdC5hc3NpZ24oZXJyb3JzIHx8IHt9LCB7XG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3IsXG4gICAgICB9KTtcbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxuICAgICAgLy8gcHJldmVudCBkZWVwZXIgc3RhdHVzIGNvZGVzIGZyb20gb3ZlcnJpZGluZ1xuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKVxuICAgICAgICAgID8gcmVzdWx0LmVycm9yLnN0YXR1c1xuICAgICAgICAgIDogNTAwO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGFjdGl2ZURlZmVycmVkcyAmJiBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhO1xuICAgICAgLy8gVE9ETzogQWRkIHN0YXR1c0NvZGUvaGVhZGVycyBvbmNlIHdlIHdpcmUgdXAgc3RyZWFtaW5nIGluIFJlbWl4XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAhZm91bmRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlXG4gIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICBlcnJvcnMgPSBwZW5kaW5nRXJyb3I7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0Vycm9yLFxuICAgIGFjdGl2ZURlZmVycmVkc1xuICApO1xuXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBba2V5LCAsIG1hdGNoXSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuXG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgIC4uLmVycm9ycyxcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIHJlZGlyZWN0cyBzaG91bGQgZ2V0IHByb2Nlc3NlZCBhYm92ZSwgYnV0IHdlXG4gICAgICAvLyBrZWVwIHRoaXMgdG8gdHlwZSBuYXJyb3cgdG8gYSBzdWNjZXNzIHJlc3VsdCBpbiB0aGUgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBuZXdMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuKTogUm91dGVEYXRhIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSB7IC4uLm5ld0xvYWRlckRhdGEgfTtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmIChuZXdMb2FkZXJEYXRhW2lkXSA9PT0gdW5kZWZpbmVkICYmIGxvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJvdXRlSWQ/OiBzdHJpbmdcbik6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZFxuICAgID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKVxuICAgIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gKFxuICAgIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZCgobSkgPT4gbS5yb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlKSB8fFxuICAgIG1hdGNoZXNbMF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm90Rm91bmRNYXRjaGVzKHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSk6IHtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3Q7XG4gIGVycm9yOiBFcnJvclJlc3BvbnNlO1xufSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5maW5kKFxuICAgIChyKSA9PiByLmluZGV4IHx8IHIucGF0aCA9PT0gXCJcIiB8fCByLnBhdGggPT09IFwiL1wiXG4gICkgfHwge1xuICAgIGlkOiBcIl9fc2hpbS00MDQtcm91dGVfX1wiLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICByb3V0ZSxcbiAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2UoNDA0LCBcIk5vdCBGb3VuZFwiLCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWV0aG9kTm90QWxsb3dlZFJlc3VsdChwYXRoOiBMb2NhdGlvbiB8IHN0cmluZyk6IEVycm9yUmVzdWx0IHtcbiAgbGV0IGhyZWYgPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhdGggOiBjcmVhdGVIcmVmKHBhdGgpO1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJZb3UncmUgdHJ5aW5nIHRvIHN1Ym1pdCB0byBhIHJvdXRlIHRoYXQgZG9lcyBub3QgaGF2ZSBhbiBhY3Rpb24uICBUbyBcIiArXG4gICAgICBcImZpeCB0aGlzLCBwbGVhc2UgYWRkIGFuIGBhY3Rpb25gIGZ1bmN0aW9uIHRvIHRoZSByb3V0ZSBmb3IgXCIgK1xuICAgICAgYFske2hyZWZ9XWBcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZShcbiAgICAgIDQwNSxcbiAgICAgIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgICBgTm8gYWN0aW9uIGZvdW5kIGZvciBbJHtocmVmfV1gXG4gICAgKSxcbiAgfTtcbn1cblxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzOiBEYXRhUmVzdWx0W10pOiBSZWRpcmVjdFJlc3VsdCB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGFuIGhyZWYgdG8gcmVwcmVzZW50IGEgXCJzZXJ2ZXJcIiBVUkwgd2l0aG91dCB0aGUgaGFzaFxuZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbjogUGFydGlhbDxQYXRoPiB8IExvY2F0aW9uIHwgVVJMKSB7XG4gIHJldHVybiAobG9jYXRpb24ucGF0aG5hbWUgfHwgXCJcIikgKyAobG9jYXRpb24uc2VhcmNoIHx8IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGE6IExvY2F0aW9uLCBiOiBMb2NhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCAhPT0gYi5oYXNoXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIERlZmVycmVkUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRlZmVycmVkO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdDogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBFcnJvclJlc3VsdCB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcjtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQ/OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIFJlZGlyZWN0UmVzdWx0IHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBSZXN1bHRUeXBlLnJlZGlyZWN0O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgaXNGZXRjaGVyOiBib29sZWFuLFxuICBjdXJyZW50TG9hZGVyRGF0YT86IFJvdXRlRGF0YVxuKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICBsZXQgY3VycmVudE1hdGNoID0gY3VycmVudE1hdGNoZXMuZmluZChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZFxuICAgICk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID1cbiAgICAgIGN1cnJlbnRNYXRjaCAhPSBudWxsICYmXG4gICAgICAhaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpICYmXG4gICAgICAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSAmJiAoaXNGZXRjaGVyIHx8IGlzUmV2YWxpZGF0aW5nTG9hZGVyKSkge1xuICAgICAgLy8gTm90ZTogd2UgZG8gbm90IGhhdmUgdG8gdG91Y2ggYWN0aXZlRGVmZXJyZWRzIGhlcmUgc2luY2Ugd2UgcmFjZSB0aGVtXG4gICAgICAvLyBhZ2FpbnN0IHRoZSBzaWduYWwgaW4gcmVzb2x2ZURlZmVycmVkRGF0YSBhbmQgdGhleSdsbCBnZXQgYWJvcnRlZFxuICAgICAgLy8gdGhlcmUgaWYgbmVlZGVkXG4gICAgICBhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCBpc0ZldGNoZXIpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKFxuICByZXN1bHQ6IERlZmVycmVkUmVzdWx0LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICB1bndyYXAgPSBmYWxzZVxuKTogUHJvbWlzZTxTdWNjZXNzUmVzdWx0IHwgRXJyb3JSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHVud3JhcCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEudW53cmFwcGVkRGF0YSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpLmdldEFsbChcImluZGV4XCIpLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xufVxuXG4vLyBOb3RlOiBUaGlzIHNob3VsZCBtYXRjaCB0aGUgZm9ybWF0IGV4cG9ydGVkIGJ5IHVzZU1hdGNoZXMsIHNvIGlmIHlvdSBjaGFuZ2Vcbi8vIHRoaXMgcGxlYXNlIGFsc28gY2hhbmdlIHRoYXQgOikgIEV2ZW50dWFsbHkgd2UnbGwgRFJZIHRoaXMgdXBcbmZ1bmN0aW9uIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YVxuKTogVXNlTWF0Y2hlc01hdGNoIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0gYXMgdW5rbm93bixcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSBhcyB1bmtub3duLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBsb2NhdGlvbjogTG9jYXRpb24gfCBzdHJpbmdcbikge1xuICBsZXQgc2VhcmNoID1cbiAgICB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKFxuICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJlxuICAgICFoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpXG4gICkge1xuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKC0yKVswXTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbjogTG9jYXRpb24gfCBzdHJpbmcpOiBVUkwge1xuICBsZXQgYmFzZSA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgIDogXCJ1bmtub3duOi8vdW5rbm93blwiO1xuICBsZXQgaHJlZiA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGxvY2F0aW9uIDogY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xufVxuLy8jZW5kcmVnaW9uXG4iXSwibmFtZXMiOlsiQWN0aW9uIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwib3B0aW9ucyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwidjVDb21wYXQiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJpbmRleCIsImNyZWF0ZU1lbW9yeUxvY2F0aW9uIiwic3RhdGUiLCJ1bmRlZmluZWQiLCJjbGFtcEluZGV4IiwibGVuZ3RoIiwiYWN0aW9uIiwiUG9wIiwibGlzdGVuZXIiLCJuIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRMb2NhdGlvbiIsInRvIiwia2V5IiwibG9jYXRpb24iLCJjcmVhdGVMb2NhdGlvbiIsInBhdGhuYW1lIiwid2FybmluZyIsImNoYXJBdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoaXN0b3J5IiwiY3JlYXRlSHJlZiIsImNyZWF0ZVBhdGgiLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsInJlcGxhY2UiLCJSZXBsYWNlIiwiZ28iLCJkZWx0YSIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5Iiwic2VhcmNoIiwiaGFzaCIsInVzciIsImNyZWF0ZUJyb3dzZXJIcmVmIiwiZ2V0VXJsQmFzZWRIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVIYXNoTG9jYXRpb24iLCJwYXJzZVBhdGgiLCJzdWJzdHIiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJjb25kIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiRXJyb3IiLCJlIiwiY3JlYXRlS2V5IiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRIaXN0b3J5U3RhdGUiLCJjdXJyZW50IiwicGF0aCIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCIsImdldExvY2F0aW9uIiwidmFsaWRhdGVMb2NhdGlvbiIsImRlZmF1bHRWaWV3IiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJhc3NpZ24iLCJyZXBsYWNlU3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc3VsdFR5cGUiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJwYXJlbnRQYXRoIiwiYWxsSWRzIiwiU2V0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJpbnZhcmlhbnQiLCJjaGlsZHJlbiIsImhhcyIsImFkZCIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInBhcmVudHNNZXRhIiwiZm9yRWFjaCIsIm1ldGEiLCJyZWxhdGl2ZVBhdGgiLCJjYXNlU2Vuc2l0aXZlIiwiY2hpbGRyZW5JbmRleCIsInN0YXJ0c1dpdGgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJzb3J0IiwiYSIsImIiLCJjb21wYXJlSW5kZXhlcyIsInBhcmFtUmUiLCJkeW5hbWljU2VnbWVudFZhbHVlIiwiaW5kZXhSb3V0ZVZhbHVlIiwiZW1wdHlTZWdtZW50VmFsdWUiLCJzdGF0aWNTZWdtZW50VmFsdWUiLCJzcGxhdFBlbmFsdHkiLCJpc1NwbGF0IiwicyIsInNlZ21lbnRzIiwic3BsaXQiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2giLCJtYXRjaFBhdGgiLCJPYmplY3QiLCJwYXJhbXMiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImdlbmVyYXRlUGF0aCIsIl8iLCJwcmVmaXgiLCJfXyIsInN0ciIsInN0YXIiLCJwYXR0ZXJuIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsImVuZHNXaXRoIiwicmVnZXhwU291cmNlIiwiUmVnRXhwIiwidmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsInJlc29sdmVQYXRoIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInJlc29sdmVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJyZWxhdGl2ZVNlZ21lbnRzIiwicG9wIiwiZ2V0SW52YWxpZFBhdGhFcnJvciIsImNoYXIiLCJmaWVsZCIsImRlc3QiLCJyZXNvbHZlVG8iLCJ0b0FyZyIsInJvdXRlUGF0aG5hbWVzIiwibG9jYXRpb25QYXRobmFtZSIsImlzUGF0aFJlbGF0aXZlIiwiaW5jbHVkZXMiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJkYXRhIiwiaW5pdCIsInJlc3BvbnNlSW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2V0IiwiUmVzcG9uc2UiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkRlZmVycmVkRGF0YSIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0tleXMiLCJzdWJzY3JpYmVyIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJ0cmFja1Byb21pc2UiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwiZG9uZSIsInN1YnNjcmliZSIsImNhbmNlbCIsImFib3J0IiwidiIsImsiLCJyZXNvbHZlRGF0YSIsInJlc29sdmUiLCJzaXplIiwidW53cmFwcGVkRGF0YSIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwiaXNUcmFja2VkUHJvbWlzZSIsIl90cmFja2VkIiwiX2Vycm9yIiwiX2RhdGEiLCJkZWZlciIsInJlZGlyZWN0IiwiRXJyb3JSZXNwb25zZSIsInN0YXR1c1RleHQiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsIklETEVfRkVUQ0hFUiIsImNyZWF0ZVJvdXRlciIsImRhdGFSb3V0ZXMiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzdWJzY3JpYmVycyIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbEVycm9ycyIsImdldE5vdEZvdW5kTWF0Y2hlcyIsImluaXRpYWxpemVkIiwibSIsImxvYWRlciIsImh5ZHJhdGlvbkRhdGEiLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImxvYWRlckRhdGEiLCJhY3Rpb25EYXRhIiwiZXJyb3JzIiwiZmV0Y2hlcnMiLCJNYXAiLCJwZW5kaW5nQWN0aW9uIiwiSGlzdG9yeUFjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJpc1JldmFsaWRhdGlvblJlcXVpcmVkIiwiY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMiLCJjYW5jZWxsZWRGZXRjaGVyTG9hZHMiLCJmZXRjaENvbnRyb2xsZXJzIiwiaW5jcmVtZW50aW5nTG9hZElkIiwicGVuZGluZ05hdmlnYXRpb25Mb2FkSWQiLCJmZXRjaFJlbG9hZElkcyIsImZldGNoUmVkaXJlY3RJZHMiLCJmZXRjaExvYWRNYXRjaGVzIiwiYWN0aXZlRGVmZXJyZWRzIiwiaW5pdGlhbGl6ZSIsInN0YXJ0TmF2aWdhdGlvbiIsImRpc3Bvc2UiLCJjbGVhciIsImRlbGV0ZUZldGNoZXIiLCJ1cGRhdGVTdGF0ZSIsIm5ld1N0YXRlIiwiY29tcGxldGVOYXZpZ2F0aW9uIiwiaXNBY3Rpb25SZWxvYWQiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VMb2FkZXJEYXRhIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwib3B0cyIsInN1Ym1pc3Npb24iLCJub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMiLCJwZW5kaW5nRXJyb3IiLCJyZXZhbGlkYXRlIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJvdmVycmlkZU5hdmlnYXRpb24iLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlUmVxdWVzdCIsInBlbmRpbmdBY3Rpb25EYXRhIiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvbk91dHB1dCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicGVuZGluZ0FjdGlvbkVycm9yIiwiaGFuZGxlTG9hZGVycyIsInJlc3VsdCIsImFjdGlvbk1hdGNoIiwiZ2V0VGFyZ2V0TWF0Y2giLCJnZXRNZXRob2ROb3RBbGxvd2VkUmVzdWx0IiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInJlZGlyZWN0TmF2aWdhdGlvbiIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwibWF0Y2hlc1RvTG9hZCIsInJldmFsaWRhdGluZ0ZldGNoZXJzIiwiZ2V0TWF0Y2hlc1RvTG9hZCIsInJvdXRlSWQiLCJmZXRjaGVyIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsInJlc3VsdHMiLCJsb2FkZXJSZXN1bHRzIiwiZmV0Y2hlclJlc3VsdHMiLCJjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEiLCJmaW5kUmVkaXJlY3QiLCJnZXRMb2FkZXJSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwiZGVmZXJyZWREYXRhIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwiZ2V0RmV0Y2hlciIsImZldGNoIiwiYWJvcnRGZXRjaGVyIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJleGlzdGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJhY3Rpb25SZXN1bHQiLCJsb2FkaW5nRmV0Y2hlciIsInJldmFsaWRhdGlvblJlcXVlc3QiLCJsb2FkSWQiLCJsb2FkRmV0Y2hlciIsInN0YWxlS2V5IiwiZG9uZUZldGNoZXIiLCJyZXNvbHZlRGVmZXJyZWREYXRhIiwicmVkaXJlY3RIaXN0b3J5QWN0aW9uIiwiY3VycmVudE1hdGNoZXMiLCJmZXRjaGVyc1RvTG9hZCIsImFsbCIsInJlc29sdmVEZWZlcnJlZFJlc3VsdHMiLCJtYXJrRmV0Y2hlcnNEb25lIiwia2V5cyIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsInVzZXJNYXRjaGVzIiwiY3JlYXRlVXNlTWF0Y2hlc01hdGNoIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsIl9pbnRlcm5hbEFjdGl2ZURlZmVycmVkcyIsInVuc3RhYmxlX2NyZWF0ZVN0YXRpY0hhbmRsZXIiLCJxdWVyeSIsInF1ZXJ5SW1wbCIsInF1ZXJ5Um91dGUiLCJ2YWx1ZXMiLCJyb3V0ZURhdGEiLCJmaW5kIiwibWV0aG9kIiwic2hvcnRDaXJjdWl0U3RhdGUiLCJtYXRjaFJlcXVlc3QiLCJzdWJtaXQiLCJsb2FkUm91dGVEYXRhIiwiYWN0aW9uSGVhZGVycyIsImlzUm91dGVSZXF1ZXN0IiwiVVJMIiwiTG9jYXRpb24iLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImNvbnRleHQiLCJnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeSIsInByb2Nlc3NSb3V0ZUxvYWRlckRhdGEiLCJyZXEiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaXNGZXRjaGVyIiwic2VhcmNoUGFyYW1zIiwiY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMiLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiZmluZEluZGV4IiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJjdXJyZW50UGF0aCIsImN1cnJlbnRMb2NhdGlvbiIsImN1cnJlbnRVcmwiLCJjcmVhdGVVUkwiLCJjdXJyZW50UGFyYW1zIiwibmV4dFVybCIsIm5leHRQYXJhbXMiLCJkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSIsInJvdXRlQ2hvaWNlIiwidHlwZSIsInNraXBSZWRpcmVjdHMiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJoYW5kbGVyIiwiY29udGVudFR5cGUiLCJ0ZXh0IiwiZGVmZXJyZWQiLCJ0b1VwcGVyQ2FzZSIsImJvZHkiLCJSZXF1ZXN0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZm91bmRFcnJvciIsIm1lcmdlZExvYWRlckRhdGEiLCJlbGlnaWJsZU1hdGNoZXMiLCJyZXZlcnNlIiwiaGFzRXJyb3JCb3VuZGFyeSIsImlzUmV2YWxpZGF0aW5nTG9hZGVyIiwidW53cmFwIiwiZ2V0QWxsIiwiaGFuZGxlIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@remix-run/router/dist/router.js\n");

/***/ }),

/***/ "../../../node_modules/react-router-dom/dist/index.js":
/*!************************************************************!*\
  !*** ../../../node_modules/react-router-dom/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),\n/* harmony export */   RouterProvider: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_DataStaticRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataStaticRouterContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_enhanceManualRouteObjects: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ \"../../../node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"../../../node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.4.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function _extends(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || _instanceof(init, URLSearchParams) ? init : Object.keys(init).reduce(function(memo, key) {\n        var value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map(function(v) {\n            return [\n                key,\n                v\n            ];\n        }) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    var searchParams = createSearchParams(locationSearch);\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        var _loop = function() {\n            var key = _step.value;\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach(function(value) {\n                    searchParams.append(key, value);\n                });\n            }\n        };\n        for(var _iterator = defaultSearchParams.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return searchParams;\n}\nfunction getFormSubmissionInfo(target, defaultAction, options) {\n    var method;\n    var action;\n    var encType;\n    var formData;\n    if (isFormElement(target)) {\n        var submissionTrigger = options.submissionTrigger;\n        method = options.method || target.getAttribute(\"method\") || defaultMethod;\n        action = options.action || target.getAttribute(\"action\") || defaultAction;\n        encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(target);\n        if (submissionTrigger && submissionTrigger.name) {\n            formData.append(submissionTrigger.name, submissionTrigger.value);\n        }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        var form = target.form;\n        if (form == null) {\n            throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n        } // <button>/<input type=\"submit\"> may override attributes of <form>\n        method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        action = options.action || target.getAttribute(\"formaction\") || form.getAttribute(\"action\") || defaultAction;\n        encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(form); // Include name + value from a <button>, appending in case the button name\n        // matches an existing input name\n        if (target.name) {\n            formData.append(target.name, target.value);\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n    } else {\n        method = options.method || defaultMethod;\n        action = options.action || defaultAction;\n        encType = options.encType || defaultEncType;\n        if (_instanceof(target, FormData)) {\n            formData = target;\n        } else {\n            formData = new FormData();\n            if (_instanceof(target, URLSearchParams)) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = target[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var _step_value = _sliced_to_array(_step.value, 2), name = _step_value[0], value = _step_value[1];\n                        formData.append(name, value);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                            _iterator.return();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            } else if (target != null) {\n                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n                try {\n                    for(var _iterator1 = Object.keys(target)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                        var name1 = _step1.value;\n                        formData.append(name1, target[name1]);\n                    }\n                } catch (err) {\n                    _didIteratorError1 = true;\n                    _iteratorError1 = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                            _iterator1.return();\n                        }\n                    } finally{\n                        if (_didIteratorError1) {\n                            throw _iteratorError1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    var _window_location = window.location, protocol = _window_location.protocol, host = _window_location.host;\n    var url = new URL(action, protocol + \"//\" + host);\n    return {\n        url: url,\n        method: method,\n        encType: encType,\n        formData: formData\n    };\n}\nvar _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"children\"\n], _excluded3 = [\n    \"reloadDocument\",\n    \"replace\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"fetcherKey\",\n    \"routeId\",\n    \"relative\"\n];\n//#region Routers\n////////////////////////////////////////////////////////////////////////////////\nfunction createBrowserRouter(routes, opts) {\n    var _window;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || ((_window = window) == null ? void 0 : _window.__staticRouterHydrationData),\n        routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    var _window2;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || ((_window2 = window) == null ? void 0 : _window2.__staticRouterHydrationData),\n        routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)\n    }).initialize();\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref) {\n    var basename = _ref.basename, children = _ref.children, window1 = _ref.window;\n    var historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _React_useState = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    }), 2), state = _React_useState[0], setState = _React_useState[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        return history.listen(setState);\n    }, [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref2) {\n    var basename = _ref2.basename, children = _ref2.children, window1 = _ref2.window;\n    var historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _React_useState = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    }), 2), state = _React_useState[0], setState = _React_useState[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        return history.listen(setState);\n    }, [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref3) {\n    var basename = _ref3.basename, children = _ref3.children, history = _ref3.history;\n    var _React_useState = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    }), 2), state = _React_useState[0], setState = _React_useState[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        return history.listen(setState);\n    }, [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n/**\n * The public API for rendering a history-aware <a>.\n */ var Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {\n    var onClick = _ref4.onClick, relative = _ref4.relative, reloadDocument = _ref4.reloadDocument, replace = _ref4.replace, state = _ref4.state, target = _ref4.target, to = _ref4.to, preventScrollReset = _ref4.preventScrollReset, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n    var href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {\n        relative: relative\n    });\n    var internalOnClick = useLinkClickHandler(to, {\n        replace: replace,\n        state: state,\n        target: target,\n        preventScrollReset: preventScrollReset,\n        relative: relative\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: href,\n        onClick: reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */ var NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref5, ref) {\n    var tmp = _ref5[\"aria-current\"], ariaCurrentProp = tmp === void 0 ? \"page\" : tmp, _ref5_caseSensitive = _ref5.caseSensitive, caseSensitive = _ref5_caseSensitive === void 0 ? false : _ref5_caseSensitive, tmp1 = _ref5.className, classNameProp = tmp1 === void 0 ? \"\" : tmp1, _ref5_end = _ref5.end, end = _ref5_end === void 0 ? false : _ref5_end, styleProp = _ref5.style, to = _ref5.to, children = _ref5.children, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n    var path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to);\n    var match = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch)({\n        path: path.pathname,\n        end: end,\n        caseSensitive: caseSensitive\n    });\n    var routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    var nextLocation = routerState == null ? void 0 : routerState.navigation.location;\n    var nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(nextLocation || \"\");\n    var nextMatch = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return nextLocation ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)({\n            path: path.pathname,\n            end: end,\n            caseSensitive: caseSensitive\n        }, nextPath.pathname) : null;\n    }, [\n        nextLocation,\n        path.pathname,\n        caseSensitive,\n        end,\n        nextPath.pathname\n    ]);\n    var isPending = nextMatch != null;\n    var isActive = match != null;\n    var ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    var className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp({\n            isActive: isActive,\n            isPending: isPending\n        });\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    var style = typeof styleProp === \"function\" ? styleProp({\n        isActive: isActive,\n        isPending: isPending\n    }) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to\n    }), typeof children === \"function\" ? children({\n        isActive: isActive,\n        isPending: isPending\n    }) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ var Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n        ref: ref\n    }));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\nvar FormImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(_ref6, forwardedRef) {\n    var reloadDocument = _ref6.reloadDocument, replace = _ref6.replace, _ref6_method = _ref6.method, method = _ref6_method === void 0 ? defaultMethod : _ref6_method, action = _ref6.action, onSubmit = _ref6.onSubmit, fetcherKey = _ref6.fetcherKey, routeId = _ref6.routeId, relative = _ref6.relative, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n    var submit = useSubmitImpl(fetcherKey, routeId);\n    var formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    var formAction = useFormAction(action, {\n        relative: relative\n    });\n    var submitHandler = function(event) {\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        var submitter = event.nativeEvent.submitter;\n        submit(submitter || event.currentTarget, {\n            method: method,\n            replace: replace,\n            relative: relative\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref7) {\n    var getKey = _ref7.getKey, storageKey = _ref7.storageKey;\n    useScrollRestoration({\n        getKey: getKey,\n        storageKey: storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmitImpl\"] = \"useSubmitImpl\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    var state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp, target = _ref.target, replaceProp = _ref.replace, state = _ref.state, preventScrollReset = _ref.preventScrollReset, relative = _ref.relative;\n    var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    var location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    var path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\n        relative: relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event) {\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            var replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n            navigate(to, {\n                replace: replace,\n                state: state,\n                preventScrollReset: preventScrollReset,\n                relative: relative\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    var defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    var location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    var searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return getSearchParamsForLocation(location.search, defaultSearchParamsRef.current);\n    }, [\n        location.search\n    ]);\n    var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    var setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(nextInit, navigateOptions) {\n        var newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    return useSubmitImpl();\n}\nfunction useSubmitImpl(fetcherKey, routeId) {\n    var router = useDataRouterContext(DataRouterHook.UseSubmitImpl).router;\n    var defaultAction = useFormAction();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        if (typeof document === \"undefined\") {\n            throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n        }\n        var _getFormSubmissionInfo = getFormSubmissionInfo(target, defaultAction, options), method = _getFormSubmissionInfo.method, encType = _getFormSubmissionInfo.encType, formData = _getFormSubmissionInfo.formData, url = _getFormSubmissionInfo.url;\n        var href = url.pathname + url.search;\n        var opts = {\n            replace: options.replace,\n            formData: formData,\n            formMethod: method,\n            formEncType: encType\n        };\n        if (fetcherKey) {\n            !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"No routeId available for useFetcher()\") : 0 : void 0;\n            router.fetch(fetcherKey, routeId, href, opts);\n        } else {\n            router.navigate(href, opts);\n        }\n    }, [\n        defaultAction,\n        router,\n        fetcherKey,\n        routeId\n    ]);\n}\nfunction useFormAction(action, _temp2) {\n    var relative = (_temp2 === void 0 ? {} : _temp2).relative;\n    var basename = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext).basename;\n    var routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    var _routeContext_matches_slice = _sliced_to_array(routeContext.matches.slice(-1), 1), match = _routeContext_matches_slice[0];\n    var resolvedAction = action != null ? action : \".\"; // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    var path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(resolvedAction, {\n        relative: relative\n    })); // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n    // URL. This is the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    var location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    if (action == null) {\n        // Safe to write to these directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        // or hash\n        path.search = location.search;\n        path.hash = location.hash; // When grabbing search params from the URL, remove the automatically\n        // inserted ?index param so we match the useResolvedPath search behavior\n        // which would not include ?index\n        if (match.route.index) {\n            var params = new URLSearchParams(path.search);\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n}\nfunction createFetcherForm(fetcherKey, routeId) {\n    var FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n            ref: ref,\n            fetcherKey: fetcherKey,\n            routeId: routeId\n        }));\n    });\n    if (true) {\n        FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n}\nvar fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher() {\n    var _route$matches;\n    var router = useDataRouterContext(DataRouterHook.UseFetcher).router;\n    var route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    var routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\n    var _React_useState = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return String(++fetcherId);\n    }), 1), fetcherKey = _React_useState[0];\n    var _React_useState1 = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"No routeId available for fetcher.Form()\") : 0 : void 0;\n        return createFetcherForm(fetcherKey, routeId);\n    }), 1), Form = _React_useState1[0];\n    var _React_useState2 = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return function(href) {\n            !router ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"No router available for fetcher.load()\") : 0 : void 0;\n            !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n            router.fetch(fetcherKey, routeId, href);\n        };\n    }), 1), load = _React_useState2[0];\n    var submit = useSubmitImpl(fetcherKey, routeId);\n    var fetcher = router.getFetcher(fetcherKey);\n    var fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return _extends({\n            Form: Form,\n            submit: submit,\n            load: load\n        }, fetcher);\n    }, [\n        fetcher,\n        Form,\n        submit,\n        load\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // Is this busted when the React team gets real weird and calls effects\n        // twice on mount?  We really just need to garbage collect here when this\n        // fetcher is no longer around.\n        return function() {\n            if (!router) {\n                console.warn(\"No fetcher available to clean up from useFetcher()\");\n                return;\n            }\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    var state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return _to_consumable_array(state.fetchers.values());\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp3) {\n    var _ref = _temp3 === void 0 ? {} : _temp3, getKey = _ref.getKey, storageKey = _ref.storageKey;\n    var router = useDataRouterContext(DataRouterHook.UseScrollRestoration).router;\n    var _useDataRouterState = useDataRouterState(DataRouterStateHook.UseScrollRestoration), restoreScrollPosition = _useDataRouterState.restoreScrollPosition, preventScrollReset = _useDataRouterState.preventScrollReset;\n    var location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    var matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();\n    var navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)(); // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        window.history.scrollRestoration = \"manual\";\n        return function() {\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []); // Save positions on unload\n    useBeforeUnload(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        if (navigation.state === \"idle\") {\n            var key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ])); // Read in any saved scroll locations\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        try {\n            var sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n            if (sessionPositions) {\n                savedScrollPositions = JSON.parse(sessionPositions);\n            }\n        } catch (e) {}\n    }, [\n        storageKey\n    ]); // Enable scroll restoration in the router\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        var disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, function() {\n            return window.scrollY;\n        }, getKey);\n        return function() {\n            return disableScrollRestoration && disableScrollRestoration();\n        };\n    }, [\n        router,\n        getKey\n    ]); // Restore scrolling when state.restoreScrollPosition changes\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        // Explicit false means don't do anything (used for submissions)\n        if (restoreScrollPosition === false) {\n            return;\n        } // been here before, scroll to it\n        if (typeof restoreScrollPosition === \"number\") {\n            window.scrollTo(0, restoreScrollPosition);\n            return;\n        } // try to scroll to the hash\n        if (location.hash) {\n            var el = document.getElementById(location.hash.slice(1));\n            if (el) {\n                el.scrollIntoView();\n                return;\n            }\n        } // Opt out of scroll reset if this link requested it\n        if (preventScrollReset === true) {\n            return;\n        } // otherwise go to the top on new locations\n        window.scrollTo(0, 0);\n    }, [\n        location,\n        restoreScrollPosition,\n        preventScrollReset\n    ]);\n}\nfunction useBeforeUnload(callback) {\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        window.addEventListener(\"beforeunload\", callback);\n        return function() {\n            window.removeEventListener(\"beforeunload\", callback);\n        };\n    }, [\n        callback\n    ]);\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Utils\n////////////////////////////////////////////////////////////////////////////////\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging React Router!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n} //#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR08sSUFBTUEsYUFBYSxHQUFHLEtBQXRCO0FBQ1AsSUFBTUMsY0FBYyxHQUFHLG1DQUF2QjtBQUVNLFNBQVVDLGFBQVYsQ0FBd0JDLE1BQXhCLEVBQW1DO0lBQ3ZDLE9BQU9BLE1BQU0sSUFBSSxJQUFWLElBQWtCLE9BQU9BLE1BQU0sQ0FBQ0MsT0FBZCxLQUEwQixRQUFuRDtBQUNEO0FBRUssU0FBVUMsZUFBVixDQUEwQkYsTUFBMUIsRUFBcUM7SUFDekMsT0FBT0QsYUFBYSxDQUFDQyxNQUFELENBQWIsSUFBeUJBLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRSxXQUFmLE9BQWlDLFFBQWpFO0FBQ0Q7QUFFSyxTQUFVQyxhQUFWLENBQXdCSixNQUF4QixFQUFtQztJQUN2QyxPQUFPRCxhQUFhLENBQUNDLE1BQUQsQ0FBYixJQUF5QkEsTUFBTSxDQUFDQyxPQUFQLENBQWVFLFdBQWYsT0FBaUMsTUFBakU7QUFDRDtBQUVLLFNBQVVFLGNBQVYsQ0FBeUJMLE1BQXpCLEVBQW9DO0lBQ3hDLE9BQU9ELGFBQWEsQ0FBQ0MsTUFBRCxDQUFiLElBQXlCQSxNQUFNLENBQUNDLE9BQVAsQ0FBZUUsV0FBZixPQUFpQyxPQUFqRTtBQUNEO0FBT0QsU0FBU0csZUFBVCxDQUF5QkMsS0FBekIsRUFBaUQ7SUFDL0MsT0FBTyxDQUFDLEVBQUVBLEtBQUssQ0FBQ0MsT0FBTixJQUFpQkQsS0FBSyxDQUFDRSxNQUF2QixJQUFpQ0YsS0FBSyxDQUFDRyxP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IjpbIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL2RvbS50cz9kNGE2Iiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vaW5kZXgudHN4PzczOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGb3JtRW5jVHlwZSwgRm9ybU1ldGhvZCB9IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHR5cGUgeyBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG5jb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MQnV0dG9uRWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEZvcm1FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxJbnB1dEVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cblxudHlwZSBMaW1pdGVkTW91c2VFdmVudCA9IFBpY2s8XG4gIE1vdXNlRXZlbnQsXG4gIFwiYnV0dG9uXCIgfCBcIm1ldGFLZXlcIiB8IFwiYWx0S2V5XCIgfCBcImN0cmxLZXlcIiB8IFwic2hpZnRLZXlcIlxuPjtcblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKFxuICBldmVudDogTGltaXRlZE1vdXNlRXZlbnQsXG4gIHRhcmdldD86IHN0cmluZ1xuKSB7XG4gIHJldHVybiAoXG4gICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICk7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgbG9jYXRpb25TZWFyY2g6IHN0cmluZyxcbiAgZGVmYXVsdFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG5cbiAgZm9yIChsZXQga2V5IG9mIGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpKSB7XG4gICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VibWl0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgSFRUUCBtZXRob2QgdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0uIE92ZXJyaWRlcyBgPGZvcm0gbWV0aG9kPmAuXG4gICAqIERlZmF1bHRzIHRvIFwiR0VUXCIuXG4gICAqL1xuICBtZXRob2Q/OiBGb3JtTWV0aG9kO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIFVSTCBwYXRoIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGFjdGlvbj5gLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCByb3V0ZS5cbiAgICpcbiAgICogTm90ZTogSXQgaXMgYXNzdW1lZCB0aGUgcGF0aCBpcyBhbHJlYWR5IHJlc29sdmVkLiBJZiB5b3UgbmVlZCB0byByZXNvbHZlIGFcbiAgICogcmVsYXRpdmUgcGF0aCwgdXNlIGB1c2VGb3JtQWN0aW9uYC5cbiAgICovXG4gIGFjdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFjdGlvbiBVUkwgdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0uIE92ZXJyaWRlcyBgPGZvcm0gZW5jVHlwZT5gLlxuICAgKiBEZWZhdWx0cyB0byBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLlxuICAgKi9cbiAgZW5jVHlwZT86IEZvcm1FbmNUeXBlO1xuXG4gIC8qKlxuICAgKiBTZXQgYHRydWVgIHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIGJyb3dzZXIncyBoaXN0b3J5IHN0YWNrXG4gICAqIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lIChpLmUuIHN0YXkgb24gXCJ0aGUgc2FtZSBwYWdlXCIpLiBEZWZhdWx0c1xuICAgKiB0byBgZmFsc2VgLlxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZm9ybSBhY3Rpb24gaXMgcmVsYXRpdmUgdG8gdGhlIHJvdXRlIGhpZXJhcmNoeSBvclxuICAgKiB0aGUgcGF0aG5hbWUuICBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBvcHQgb3V0IG9mIG5hdmlnYXRpbmcgdGhlIHJvdXRlXG4gICAqIGhpZXJhcmNoeSBhbmQgd2FudCB0byBpbnN0ZWFkIHJvdXRlIGJhc2VkIG9uIC8tZGVsaW1pdGVkIFVSTCBzZWdtZW50c1xuICAgKi9cbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICB0YXJnZXQ6XG4gICAgfCBIVE1MRm9ybUVsZW1lbnRcbiAgICB8IEhUTUxCdXR0b25FbGVtZW50XG4gICAgfCBIVE1MSW5wdXRFbGVtZW50XG4gICAgfCBGb3JtRGF0YVxuICAgIHwgVVJMU2VhcmNoUGFyYW1zXG4gICAgfCB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfVxuICAgIHwgbnVsbCxcbiAgZGVmYXVsdEFjdGlvbjogc3RyaW5nLFxuICBvcHRpb25zOiBTdWJtaXRPcHRpb25zXG4pOiB7XG4gIHVybDogVVJMO1xuICBtZXRob2Q6IHN0cmluZztcbiAgZW5jVHlwZTogc3RyaW5nO1xuICBmb3JtRGF0YTogRm9ybURhdGE7XG59IHtcbiAgbGV0IG1ldGhvZDogc3RyaW5nO1xuICBsZXQgYWN0aW9uOiBzdHJpbmc7XG4gIGxldCBlbmNUeXBlOiBzdHJpbmc7XG4gIGxldCBmb3JtRGF0YTogRm9ybURhdGE7XG5cbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBzdWJtaXNzaW9uVHJpZ2dlcjogSFRNTEJ1dHRvbkVsZW1lbnQgfCBIVE1MSW5wdXRFbGVtZW50ID0gKFxuICAgICAgb3B0aW9ucyBhcyBhbnlcbiAgICApLnN1Ym1pc3Npb25UcmlnZ2VyO1xuXG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHwgZGVmYXVsdEFjdGlvbjtcbiAgICBlbmNUeXBlID1cbiAgICAgIG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICBpZiAoc3VibWlzc2lvblRyaWdnZXIgJiYgc3VibWlzc2lvblRyaWdnZXIubmFtZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUsIHN1Ym1pc3Npb25UcmlnZ2VyLnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHxcbiAgICAoaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgICAgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKVxuICApIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG4gICAgbWV0aG9kID1cbiAgICAgIG9wdGlvbnMubWV0aG9kIHx8XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHxcbiAgICAgIGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID1cbiAgICAgIG9wdGlvbnMuYWN0aW9uIHx8XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHxcbiAgICAgIGRlZmF1bHRBY3Rpb247XG4gICAgZW5jVHlwZSA9XG4gICAgICBvcHRpb25zLmVuY1R5cGUgfHxcbiAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpIHx8XG4gICAgICBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xuXG4gICAgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+LCBhcHBlbmRpbmcgaW4gY2FzZSB0aGUgYnV0dG9uIG5hbWVcbiAgICAvLyBtYXRjaGVzIGFuIGV4aXN0aW5nIGlucHV0IG5hbWVcbiAgICBpZiAodGFyZ2V0Lm5hbWUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCh0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICtcbiAgICAgICAgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCBkZWZhdWx0QWN0aW9uO1xuICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgZGVmYXVsdEVuY1R5cGU7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRhcmdldCkpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB7IHByb3RvY29sLCBob3N0IH0gPSB3aW5kb3cubG9jYXRpb247XG4gIGxldCB1cmwgPSBuZXcgVVJMKGFjdGlvbiwgYCR7cHJvdG9jb2x9Ly8ke2hvc3R9YCk7XG5cbiAgcmV0dXJuIHsgdXJsLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhIH07XG59XG4iLCIvKipcbiAqIE5PVEU6IElmIHlvdSByZWZhY3RvciB0aGlzIHRvIHNwbGl0IHVwIHRoZSBtb2R1bGVzIGludG8gc2VwYXJhdGUgZmlsZXMsXG4gKiB5b3UnbGwgbmVlZCB0byB1cGRhdGUgdGhlIHJvbGx1cCBjb25maWcgZm9yIHJlYWN0LXJvdXRlci1kb20tdjUtY29tcGF0LlxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU9iamVjdCxcbiAgVG8sXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIFJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgdXNlSHJlZixcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQgYXMgRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IGFzIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCBhcyBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dCBhcyBSb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9lbmhhbmNlTWFudWFsUm91dGVPYmplY3RzIGFzIGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB0eXBlIHtcbiAgQnJvd3Nlckhpc3RvcnksXG4gIEZldGNoZXIsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBIYXNoSGlzdG9yeSxcbiAgSGlzdG9yeSxcbiAgSHlkcmF0aW9uU3RhdGUsXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBjcmVhdGVSb3V0ZXIsXG4gIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBjcmVhdGVIYXNoSGlzdG9yeSxcbiAgaW52YXJpYW50LFxuICBqb2luUGF0aHMsXG4gIG1hdGNoUGF0aCxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgU3VibWl0T3B0aW9ucyxcbiAgUGFyYW1LZXlWYWx1ZVBhaXIsXG4gIFVSTFNlYXJjaFBhcmFtc0luaXQsXG59IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0TWV0aG9kLFxuICBnZXRGb3JtU3VibWlzc2lvbkluZm8sXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uLFxuICBzaG91bGRQcm9jZXNzTGlua0NsaWNrLFxufSBmcm9tIFwiLi9kb21cIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSZS1leHBvcnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSB7XG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBQYXJhbUtleVZhbHVlUGFpcixcbiAgU3VibWl0T3B0aW9ucyxcbiAgVVJMU2VhcmNoUGFyYW1zSW5pdCxcbn07XG5leHBvcnQgeyBjcmVhdGVTZWFyY2hQYXJhbXMgfTtcblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEZldGNoZXIsXG4gIEhhc2gsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIEluZGV4Um91dGVQcm9wcyxcbiAgSnNvbkZ1bmN0aW9uLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdGlvbixcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhuYW1lLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFNlYXJjaCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBUbyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuZXhwb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBkZWZlcixcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGdlbmVyYXRlUGF0aCxcbiAganNvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFTdGF0aWNSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9lbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG4vLyNlbmRyZWdpb25cblxuZGVjbGFyZSBnbG9iYWwge1xuICB2YXIgX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhOiBIeWRyYXRpb25TdGF0ZSB8IHVuZGVmaW5lZDtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSb3V0ZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzoge1xuICAgIGJhc2VuYW1lPzogc3RyaW5nO1xuICAgIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgICB3aW5kb3c/OiBXaW5kb3c7XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCB3aW5kb3c/Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXM6IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSxcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzoge1xuICAgIGJhc2VuYW1lPzogc3RyaW5nO1xuICAgIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgICB3aW5kb3c/OiBXaW5kb3c7XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCB3aW5kb3c/Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXM6IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSxcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQ29tcG9uZW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93LFxufTogQnJvd3NlclJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEJyb3dzZXJIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdywgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdyB9OiBIYXNoUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8SGFzaEhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93LCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIGhpc3RvcnkgfTogSGlzdG9yeVJvdXRlclByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxSZWFjdC5BbmNob3JIVE1MQXR0cmlidXRlczxIVE1MQW5jaG9yRWxlbWVudD4sIFwiaHJlZlwiPiB7XG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG4gIHRvOiBUbztcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cbmV4cG9ydCBjb25zdCBMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgb25DbGljayxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKFxuICAgICAgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+XG4gICAgKSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgICAgPGFcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgIG9uQ2xpY2s9e3JlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgdGFyZ2V0PXt0YXJnZXR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PExpbmtQcm9wcywgXCJjbGFzc05hbWVcIiB8IFwic3R5bGVcIiB8IFwiY2hpbGRyZW5cIj4ge1xuICBjaGlsZHJlbj86XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW47IGlzUGVuZGluZzogYm9vbGVhbiB9KSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2xhc3NOYW1lPzpcbiAgICB8IHN0cmluZ1xuICAgIHwgKChwcm9wczoge1xuICAgICAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICAgICAgaXNQZW5kaW5nOiBib29sZWFuO1xuICAgICAgfSkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczoge1xuICAgICAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICAgICAgaXNQZW5kaW5nOiBib29sZWFuO1xuICAgICAgfSkgPT4gUmVhY3QuQ1NTUHJvcGVydGllcyB8IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTmF2TGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG4gICAgbGV0IG1hdGNoID0gdXNlTWF0Y2goeyBwYXRoOiBwYXRoLnBhdGhuYW1lLCBlbmQsIGNhc2VTZW5zaXRpdmUgfSk7XG5cbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSByb3V0ZXJTdGF0ZT8ubmF2aWdhdGlvbi5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dFBhdGggPSB1c2VSZXNvbHZlZFBhdGgobmV4dExvY2F0aW9uIHx8IFwiXCIpO1xuICAgIGxldCBuZXh0TWF0Y2ggPSBSZWFjdC51c2VNZW1vKFxuICAgICAgKCkgPT5cbiAgICAgICAgbmV4dExvY2F0aW9uXG4gICAgICAgICAgPyBtYXRjaFBhdGgoXG4gICAgICAgICAgICAgIHsgcGF0aDogcGF0aC5wYXRobmFtZSwgZW5kLCBjYXNlU2Vuc2l0aXZlIH0sXG4gICAgICAgICAgICAgIG5leHRQYXRoLnBhdGhuYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgW25leHRMb2NhdGlvbiwgcGF0aC5wYXRobmFtZSwgY2FzZVNlbnNpdGl2ZSwgZW5kLCBuZXh0UGF0aC5wYXRobmFtZV1cbiAgICApO1xuXG4gICAgbGV0IGlzUGVuZGluZyA9IG5leHRNYXRjaCAhPSBudWxsO1xuICAgIGxldCBpc0FjdGl2ZSA9IG1hdGNoICE9IG51bGw7XG5cbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcCh7IGlzQWN0aXZlLCBpc1BlbmRpbmcgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgICAgY2xhc3NOYW1lID0gW1xuICAgICAgICBjbGFzc05hbWVQcm9wLFxuICAgICAgICBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLFxuICAgICAgICBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIGxldCBzdHlsZSA9XG4gICAgICB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBzdHlsZVByb3AoeyBpc0FjdGl2ZSwgaXNQZW5kaW5nIH0pXG4gICAgICAgIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGNoaWxkcmVuKHsgaXNBY3RpdmUsIGlzUGVuZGluZyB9KVxuICAgICAgICAgIDogY2hpbGRyZW59XG4gICAgICA8L0xpbms+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1Qcm9wcyBleHRlbmRzIFJlYWN0LkZvcm1IVE1MQXR0cmlidXRlczxIVE1MRm9ybUVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgdG8gdXNlIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0LiBTdXBwb3J0cyBcImdldFwiLCBcInBvc3RcIixcbiAgICogXCJwdXRcIiwgXCJkZWxldGVcIiwgXCJwYXRjaFwiLlxuICAgKi9cbiAgbWV0aG9kPzogRm9ybU1ldGhvZDtcblxuICAvKipcbiAgICogTm9ybWFsIGA8Zm9ybSBhY3Rpb24+YCBidXQgc3VwcG9ydHMgUmVhY3QgUm91dGVyJ3MgcmVsYXRpdmUgcGF0aHMuXG4gICAqL1xuICBhY3Rpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIGZ1bGwgZG9jdW1lbnQgbmF2aWdhdGlvbiBpbnN0ZWFkIG9mIGEgZmV0Y2guXG4gICAqL1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3Rvcnkgc3RhY2sgd2hlbiB0aGUgZm9ybVxuICAgKiBuYXZpZ2F0ZXMuIFVzZSB0aGlzIGlmIHlvdSBkb24ndCB3YW50IHRoZSB1c2VyIHRvIGJlIGFibGUgdG8gY2xpY2sgXCJiYWNrXCJcbiAgICogdG8gdGhlIHBhZ2Ugd2l0aCB0aGUgZm9ybSBvbiBpdC5cbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0dGVkLiBJZiB5b3UgY2FsbFxuICAgKiBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgdGhlbiB0aGlzIGZvcm0gd2lsbCBub3QgZG8gYW55dGhpbmcuXG4gICAqL1xuICBvblN1Ym1pdD86IFJlYWN0LkZvcm1FdmVudEhhbmRsZXI8SFRNTEZvcm1FbGVtZW50Pjtcbn1cblxuLyoqXG4gKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgRm9ybSA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEZvcm1FbGVtZW50LCBGb3JtUHJvcHM+KFxuICAocHJvcHMsIHJlZikgPT4ge1xuICAgIHJldHVybiA8Rm9ybUltcGwgey4uLnByb3BzfSByZWY9e3JlZn0gLz47XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbn1cblxudHlwZSBIVE1MU3VibWl0RXZlbnQgPSBSZWFjdC5CYXNlU3ludGhldGljRXZlbnQ8XG4gIFN1Ym1pdEV2ZW50LFxuICBFdmVudCxcbiAgSFRNTEZvcm1FbGVtZW50XG4+O1xuXG50eXBlIEhUTUxGb3JtU3VibWl0dGVyID0gSFRNTEJ1dHRvbkVsZW1lbnQgfCBIVE1MSW5wdXRFbGVtZW50O1xuXG5pbnRlcmZhY2UgRm9ybUltcGxQcm9wcyBleHRlbmRzIEZvcm1Qcm9wcyB7XG4gIGZldGNoZXJLZXk/OiBzdHJpbmc7XG4gIHJvdXRlSWQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IEZvcm1JbXBsID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZvcm1JbXBsUHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICAgIGFjdGlvbixcbiAgICAgIG9uU3VibWl0LFxuICAgICAgZmV0Y2hlcktleSxcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hlcktleSwgcm91dGVJZCk7XG4gICAgbGV0IGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgPVxuICAgICAgbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgeyByZWxhdGl2ZSB9KTtcbiAgICBsZXQgc3VibWl0SGFuZGxlcjogUmVhY3QuRm9ybUV2ZW50SGFuZGxlcjxIVE1MRm9ybUVsZW1lbnQ+ID0gKGV2ZW50KSA9PiB7XG4gICAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbGV0IHN1Ym1pdHRlciA9IChldmVudCBhcyB1bmtub3duIGFzIEhUTUxTdWJtaXRFdmVudCkubmF0aXZlRXZlbnRcbiAgICAgICAgLnN1Ym1pdHRlciBhcyBIVE1MRm9ybVN1Ym1pdHRlciB8IG51bGw7XG5cbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwgeyBtZXRob2QsIHJlcGxhY2UsIHJlbGF0aXZlIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGZvcm1cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgIG1ldGhvZD17Zm9ybU1ldGhvZH1cbiAgICAgICAgYWN0aW9uPXtmb3JtQWN0aW9ufVxuICAgICAgICBvblN1Ym1pdD17cmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJ9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xufVxuXG5pbnRlcmZhY2UgU2Nyb2xsUmVzdG9yYXRpb25Qcm9wcyB7XG4gIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb247XG4gIHN0b3JhZ2VLZXk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXksXG59OiBTY3JvbGxSZXN0b3JhdGlvblByb3BzKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIb29rc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW51bSBEYXRhUm91dGVySG9vayB7XG4gIFVzZVNjcm9sbFJlc3RvcmF0aW9uID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiLFxuICBVc2VTdWJtaXRJbXBsID0gXCJ1c2VTdWJtaXRJbXBsXCIsXG4gIFVzZUZldGNoZXIgPSBcInVzZUZldGNoZXJcIixcbn1cblxuZW51bSBEYXRhUm91dGVyU3RhdGVIb29rIHtcbiAgVXNlRmV0Y2hlcnMgPSBcInVzZUZldGNoZXJzXCIsXG4gIFVzZVNjcm9sbFJlc3RvcmF0aW9uID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiLFxufVxuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKFxuICBob29rTmFtZTogRGF0YVJvdXRlckhvb2sgfCBEYXRhUm91dGVyU3RhdGVIb29rXG4pIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJIb29rKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXI8RSBleHRlbmRzIEVsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudD4oXG4gIHRvOiBUbyxcbiAge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICAgIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gICAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyByZXBsYWNlUHJvcFxuICAgICAgICAgICAgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSwgcHJldmVudFNjcm9sbFJlc2V0LCByZWxhdGl2ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICBwYXRoLFxuICAgICAgcmVwbGFjZVByb3AsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoXG4gIGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdFxuKTogW1VSTFNlYXJjaFBhcmFtcywgU2V0VVJMU2VhcmNoUGFyYW1zXSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKFxuICAgICAgICBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudFxuICAgICAgKSxcbiAgICBbbG9jYXRpb24uc2VhcmNoXVxuICApO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjazxTZXRVUkxTZWFyY2hQYXJhbXM+KFxuICAgIChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgIHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0XG4gICAgICApO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc11cbiAgKTtcblxuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cblxudHlwZSBTZXRVUkxTZWFyY2hQYXJhbXMgPSAoXG4gIG5leHRJbml0PzpcbiAgICB8IFVSTFNlYXJjaFBhcmFtc0luaXRcbiAgICB8ICgocHJldjogVVJMU2VhcmNoUGFyYW1zKSA9PiBVUkxTZWFyY2hQYXJhbXNJbml0KSxcbiAgbmF2aWdhdGVPcHRzPzogTmF2aWdhdGVPcHRpb25zXG4pID0+IHZvaWQ7XG5cbnR5cGUgU3VibWl0VGFyZ2V0ID1cbiAgfCBIVE1MRm9ybUVsZW1lbnRcbiAgfCBIVE1MQnV0dG9uRWxlbWVudFxuICB8IEhUTUxJbnB1dEVsZW1lbnRcbiAgfCBGb3JtRGF0YVxuICB8IFVSTFNlYXJjaFBhcmFtc1xuICB8IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9XG4gIHwgbnVsbDtcblxuLyoqXG4gKiBTdWJtaXRzIGEgSFRNTCBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdEZ1bmN0aW9uIHtcbiAgKFxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYDxmb3JtPmAgdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIsIGEgc3BlY2lmaWNcbiAgICAgKiBgPGJ1dHRvbj5gIG9yIGA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPmAgdG8gdXNlIHRvIHN1Ym1pdCB0aGUgZm9ybSwgb3Igc29tZVxuICAgICAqIGFyYml0cmFyeSBkYXRhIHRvIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdoZW4gdXNpbmcgYSBgPGJ1dHRvbj5gIGl0cyBgbmFtZWAgYW5kIGB2YWx1ZWAgd2lsbCBhbHNvIGJlXG4gICAgICogaW5jbHVkZWQgaW4gdGhlIGZvcm0gZGF0YSB0aGF0IGlzIHN1Ym1pdHRlZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdGhhdCBvdmVycmlkZSB0aGUgYDxmb3JtPmAncyBvd24gYXR0cmlidXRlcy4gUmVxdWlyZWQgd2hlblxuICAgICAqIHN1Ym1pdHRpbmcgYXJiaXRyYXJ5IGRhdGEgd2l0aG91dCBhIGJhY2tpbmcgYDxmb3JtPmAuXG4gICAgICovXG4gICAgb3B0aW9ucz86IFN1Ym1pdE9wdGlvbnNcbiAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VibWl0KCk6IFN1Ym1pdEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHVzZVN1Ym1pdEltcGwoKTtcbn1cblxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5Pzogc3RyaW5nLCByb3V0ZUlkPzogc3RyaW5nKTogU3VibWl0RnVuY3Rpb24ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVN1Ym1pdEltcGwpO1xuICBsZXQgZGVmYXVsdEFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRhcmdldCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArXG4gICAgICAgICAgICBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IG1ldGhvZCwgZW5jVHlwZSwgZm9ybURhdGEsIHVybCB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGRlZmF1bHRBY3Rpb24sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG5cbiAgICAgIGxldCBocmVmID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiBtZXRob2QgYXMgRm9ybU1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUsXG4gICAgICB9O1xuICAgICAgaWYgKGZldGNoZXJLZXkpIHtcbiAgICAgICAgaW52YXJpYW50KHJvdXRlSWQgIT0gbnVsbCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgdXNlRmV0Y2hlcigpXCIpO1xuICAgICAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUoaHJlZiwgb3B0cyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZGVmYXVsdEFjdGlvbiwgcm91dGVyLCBmZXRjaGVyS2V5LCByb3V0ZUlkXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihcbiAgYWN0aW9uPzogc3RyaW5nLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcblxuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgbGV0IHJlc29sdmVkQWN0aW9uID0gYWN0aW9uID8/IFwiLlwiO1xuICAvLyBTaGFsbG93IGNsb25lIHBhdGggc28gd2UgY2FuIG1vZGlmeSBpdCBiZWxvdywgb3RoZXJ3aXNlIHdlIG1vZGlmeSB0aGVcbiAgLy8gb2JqZWN0IHJlZmVyZW5jZWQgYnkgdXNlTWVtbyBpbnNpZGUgdXNlUmVzb2x2ZWRQYXRoXG4gIGxldCBwYXRoID0geyAuLi51c2VSZXNvbHZlZFBhdGgocmVzb2x2ZWRBY3Rpb24sIHsgcmVsYXRpdmUgfSkgfTtcblxuICAvLyBQcmV2aW91c2x5IHdlIHNldCB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gXCIuXCIuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0XG4gIC8vIGB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpYCBleGNsdWRlcyBzZWFyY2ggcGFyYW1zIGFuZCB0aGUgaGFzaCBvZiB0aGUgcmVzb2x2ZWRcbiAgLy8gVVJMLiBUaGlzIGlzIHRoZSBpbnRlbmRlZCBiZWhhdmlvciBvZiB3aGVuIFwiLlwiIGlzIHNwZWNpZmljYWxseSBwcm92aWRlZCBhc1xuICAvLyB0aGUgZm9ybSBhY3Rpb24sIGJ1dCBpbmNvbnNpc3RlbnQgdy8gYnJvd3NlcnMgd2hlbiB0aGUgYWN0aW9uIGlzIG9taXR0ZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBpZiAoYWN0aW9uID09IG51bGwpIHtcbiAgICAvLyBTYWZlIHRvIHdyaXRlIHRvIHRoZXNlIGRpcmVjdGx5IGhlcmUgc2luY2UgaWYgYWN0aW9uIHdhcyB1bmRlZmluZWQsIHdlXG4gICAgLy8gd291bGQgaGF2ZSBjYWxsZWQgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKSB3aGljaCB3aWxsIG5ldmVyIGluY2x1ZGUgYSBzZWFyY2hcbiAgICAvLyBvciBoYXNoXG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcblxuICAgIC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSB0aGUgYXV0b21hdGljYWxseVxuICAgIC8vIGluc2VydGVkID9pbmRleCBwYXJhbSBzbyB3ZSBtYXRjaCB0aGUgdXNlUmVzb2x2ZWRQYXRoIHNlYXJjaCBiZWhhdmlvclxuICAgIC8vIHdoaWNoIHdvdWxkIG5vdCBpbmNsdWRlID9pbmRleFxuICAgIGlmIChtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtwYXJhbXMudG9TdHJpbmcoKX1gIDogXCJcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoXG4gICAgICA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIilcbiAgICAgIDogXCI/aW5kZXhcIjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAvLyB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGVcbiAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPVxuICAgICAgcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaGVyRm9ybShmZXRjaGVyS2V5OiBzdHJpbmcsIHJvdXRlSWQ6IHN0cmluZykge1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRm9ybVByb3BzPihcbiAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEZvcm1JbXBsXG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgIGZldGNoZXJLZXk9e2ZldGNoZXJLZXl9XG4gICAgICAgICAgcm91dGVJZD17cm91dGVJZH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuICApO1xuICBpZiAoX19ERVZfXykge1xuICAgIEZldGNoZXJGb3JtLmRpc3BsYXlOYW1lID0gXCJmZXRjaGVyLkZvcm1cIjtcbiAgfVxuICByZXR1cm4gRmV0Y2hlckZvcm07XG59XG5cbmxldCBmZXRjaGVySWQgPSAwO1xuXG5leHBvcnQgdHlwZSBGZXRjaGVyV2l0aENvbXBvbmVudHM8VERhdGE+ID0gRmV0Y2hlcjxURGF0YT4gJiB7XG4gIEZvcm06IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUZldGNoZXJGb3JtPjtcbiAgc3VibWl0OiAoXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG4gICAgLy8gRmV0Y2hlcnMgY2Fubm90IHJlcGxhY2UgYmVjYXVzZSB0aGV5IGFyZSBub3QgbmF2aWdhdGlvbiBldmVudHNcbiAgICBvcHRpb25zPzogT21pdDxTdWJtaXRPcHRpb25zLCBcInJlcGxhY2VcIj5cbiAgKSA9PiB2b2lkO1xuICBsb2FkOiAoaHJlZjogc3RyaW5nKSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoZXI8VERhdGEgPSBhbnk+KCk6IEZldGNoZXJXaXRoQ29tcG9uZW50czxURGF0YT4ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuXG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG5cbiAgbGV0IHJvdXRlSWQgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0/LnJvdXRlLmlkO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG5cbiAgbGV0IFtmZXRjaGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2ZldGNoZXJJZCkpO1xuICBsZXQgW0Zvcm1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIGludmFyaWFudChyb3V0ZUlkLCBgTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIuRm9ybSgpYCk7XG4gICAgcmV0dXJuIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICB9KTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IChocmVmOiBzdHJpbmcpID0+IHtcbiAgICBpbnZhcmlhbnQocm91dGVyLCBcIk5vIHJvdXRlciBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgIGludmFyaWFudChyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZik7XG4gIH0pO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5LCByb3V0ZUlkKTtcblxuICBsZXQgZmV0Y2hlciA9IHJvdXRlci5nZXRGZXRjaGVyPFREYXRhPihmZXRjaGVyS2V5KTtcblxuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWQsXG4gICAgICAuLi5mZXRjaGVyLFxuICAgIH0pLFxuICAgIFtmZXRjaGVyLCBGb3JtLCBzdWJtaXQsIGxvYWRdXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGJ1c3RlZCB3aGVuIHRoZSBSZWFjdCB0ZWFtIGdldHMgcmVhbCB3ZWlyZCBhbmQgY2FsbHMgZWZmZWN0c1xuICAgIC8vIHR3aWNlIG9uIG1vdW50PyAgV2UgcmVhbGx5IGp1c3QgbmVlZCB0byBnYXJiYWdlIGNvbGxlY3QgaGVyZSB3aGVuIHRoaXNcbiAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gZmV0Y2hlciBhdmFpbGFibGUgdG8gY2xlYW4gdXAgZnJvbSB1c2VGZXRjaGVyKClgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgfTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuXG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoZXJzKCk6IEZldGNoZXJbXSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIFsuLi5zdGF0ZS5mZXRjaGVycy52YWx1ZXMoKV07XG59XG5cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4vKipcbiAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxufToge1xuICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uO1xuICBzdG9yYWdlS2V5Pzogc3RyaW5nO1xufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQgeyByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldCB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb25cbiAgKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuXG4gIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHVubG9hZFxuICB1c2VCZWZvcmVVbmxvYWQoXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKVxuICAgICAgKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKVxuICApO1xuXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgKTtcbiAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gICAgfVxuICB9LCBbc3RvcmFnZUtleV0pO1xuXG4gIC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXI/LmVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAoKSA9PiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgIGdldEtleVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgfSwgW3JvdXRlciwgZ2V0S2V5XSk7XG5cbiAgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0IGZhbHNlIG1lYW5zIGRvbid0IGRvIGFueXRoaW5nICh1c2VkIGZvciBzdWJtaXNzaW9ucylcbiAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJlZW4gaGVyZSBiZWZvcmUsIHNjcm9sbCB0byBpdFxuICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHQgb3V0IG9mIHNjcm9sbCByZXNldCBpZiB0aGlzIGxpbmsgcmVxdWVzdGVkIGl0XG4gICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBnbyB0byB0aGUgdG9wIG9uIG5ldyBsb2NhdGlvbnNcbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbn1cblxuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tdKTtcbn1cblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVXRpbHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG4vLyNlbmRyZWdpb25cbiJdLCJuYW1lcyI6WyJkZWZhdWx0TWV0aG9kIiwiZGVmYXVsdEVuY1R5cGUiLCJpc0h0bWxFbGVtZW50Iiwib2JqZWN0IiwidGFnTmFtZSIsImlzQnV0dG9uRWxlbWVudCIsInRvTG93ZXJDYXNlIiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsInRhcmdldCIsImJ1dHRvbiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImluaXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwibWVtbyIsImtleSIsInZhbHVlIiwiY29uY2F0IiwibWFwIiwidiIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiaGFzIiwiZ2V0QWxsIiwiZm9yRWFjaCIsImFwcGVuZCIsImdldEZvcm1TdWJtaXNzaW9uSW5mbyIsImRlZmF1bHRBY3Rpb24iLCJvcHRpb25zIiwibWV0aG9kIiwiYWN0aW9uIiwiZW5jVHlwZSIsImZvcm1EYXRhIiwic3VibWlzc2lvblRyaWdnZXIiLCJnZXRBdHRyaWJ1dGUiLCJGb3JtRGF0YSIsIm5hbWUiLCJ0eXBlIiwiZm9ybSIsIkVycm9yIiwicHJvdG9jb2wiLCJob3N0Iiwid2luZG93IiwibG9jYXRpb24iLCJ1cmwiLCJVUkwiLCJjcmVhdGVCcm93c2VyUm91dGVyIiwicm91dGVzIiwib3B0cyIsImNyZWF0ZVJvdXRlciIsImJhc2VuYW1lIiwiaGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiaHlkcmF0aW9uRGF0YSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMiLCJpbml0aWFsaXplIiwiY3JlYXRlSGFzaFJvdXRlciIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiQnJvd3NlclJvdXRlciIsImNoaWxkcmVuIiwiaGlzdG9yeVJlZiIsIlJlYWN0IiwidXNlUmVmIiwiY3VycmVudCIsInY1Q29tcGF0Iiwic3RhdGUiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwibGlzdGVuIiwiY3JlYXRlRWxlbWVudCIsIlJvdXRlciIsIm5hdmlnYXRpb25UeXBlIiwibmF2aWdhdG9yIiwiSGFzaFJvdXRlciIsIkhpc3RvcnlSb3V0ZXIiLCJkaXNwbGF5TmFtZSIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua1dpdGhSZWYiLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsInJlcGxhY2UiLCJ0byIsInByZXZlbnRTY3JvbGxSZXNldCIsInJlc3QiLCJocmVmIiwidXNlSHJlZiIsImludGVybmFsT25DbGljayIsInVzZUxpbmtDbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJOYXZMaW5rIiwiTmF2TGlua1dpdGhSZWYiLCJhcmlhQ3VycmVudFByb3AiLCJjYXNlU2Vuc2l0aXZlIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsImVuZCIsInN0eWxlIiwic3R5bGVQcm9wIiwicGF0aCIsInVzZVJlc29sdmVkUGF0aCIsIm1hdGNoIiwidXNlTWF0Y2giLCJwYXRobmFtZSIsInJvdXRlclN0YXRlIiwidXNlQ29udGV4dCIsIkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJuZXh0TG9jYXRpb24iLCJuYXZpZ2F0aW9uIiwibmV4dFBhdGgiLCJuZXh0TWF0Y2giLCJ1c2VNZW1vIiwibWF0Y2hQYXRoIiwiaXNQZW5kaW5nIiwiaXNBY3RpdmUiLCJhcmlhQ3VycmVudCIsInVuZGVmaW5lZCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiRm9ybSIsInByb3BzIiwiRm9ybUltcGwiLCJmb3J3YXJkZWRSZWYiLCJvblN1Ym1pdCIsImZldGNoZXJLZXkiLCJyb3V0ZUlkIiwic3VibWl0IiwidXNlU3VibWl0SW1wbCIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwidXNlRm9ybUFjdGlvbiIsInN1Ym1pdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInN1Ym1pdHRlciIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsIlNjcm9sbFJlc3RvcmF0aW9uIiwiZ2V0S2V5Iiwic3RvcmFnZUtleSIsInVzZVNjcm9sbFJlc3RvcmF0aW9uIiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJEYXRhUm91dGVyQ29udGV4dCIsImludmFyaWFudCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsInJlcGxhY2VQcm9wIiwibmF2aWdhdGUiLCJ1c2VOYXZpZ2F0ZSIsInVzZUxvY2F0aW9uIiwidXNlQ2FsbGJhY2siLCJjcmVhdGVQYXRoIiwidXNlU2VhcmNoUGFyYW1zIiwiZGVmYXVsdEluaXQiLCJ3YXJuaW5nIiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsInNlYXJjaCIsInNldFNlYXJjaFBhcmFtcyIsIm5leHRJbml0IiwibmF2aWdhdGVPcHRpb25zIiwibmV3U2VhcmNoUGFyYW1zIiwidXNlU3VibWl0Iiwicm91dGVyIiwiVXNlU3VibWl0SW1wbCIsImRvY3VtZW50IiwiZm9ybUVuY1R5cGUiLCJmZXRjaCIsIk5hdmlnYXRpb25Db250ZXh0Iiwicm91dGVDb250ZXh0IiwiUm91dGVDb250ZXh0IiwibWF0Y2hlcyIsInNsaWNlIiwicmVzb2x2ZWRBY3Rpb24iLCJoYXNoIiwicm91dGUiLCJpbmRleCIsInBhcmFtcyIsImRlbGV0ZSIsInRvU3RyaW5nIiwiam9pblBhdGhzIiwiY3JlYXRlRmV0Y2hlckZvcm0iLCJGZXRjaGVyRm9ybSIsImZldGNoZXJJZCIsInVzZUZldGNoZXIiLCJVc2VGZXRjaGVyIiwibGVuZ3RoIiwiaWQiLCJTdHJpbmciLCJsb2FkIiwiZmV0Y2hlciIsImdldEZldGNoZXIiLCJmZXRjaGVyV2l0aENvbXBvbmVudHMiLCJ1c2VFZmZlY3QiLCJjb25zb2xlIiwid2FybiIsImRlbGV0ZUZldGNoZXIiLCJ1c2VGZXRjaGVycyIsIlVzZUZldGNoZXJzIiwiZmV0Y2hlcnMiLCJ2YWx1ZXMiLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsIlVzZVNjcm9sbFJlc3RvcmF0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRpb24iLCJzY3JvbGxSZXN0b3JhdGlvbiIsInVzZUJlZm9yZVVubG9hZCIsInNjcm9sbFkiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5Iiwic2Vzc2lvblBvc2l0aW9ucyIsImdldEl0ZW0iLCJwYXJzZSIsImUiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwiY2FsbGJhY2siLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbmQiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/react-router-dom/dist/index.js\n");

/***/ }),

/***/ "../../../node_modules/react-router/dist/index.js":
/*!********************************************************!*\
  !*** ../../../node_modules/react-router/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_DataStaticRouterContext: () => (/* binding */ DataStaticRouterContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_enhanceManualRouteObjects: () => (/* binding */ enhanceManualRouteObjects),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.redirect),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remix-run/router */ \"../../../node_modules/@remix-run/router/dist/router.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * React Router v6.4.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _assert_this_initialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _call_super(_this, derived, args) {\n    derived = _get_prototype_of(derived);\n    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possible_constructor_return(self, call) {\n    if (call && (_type_of(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assert_this_initialized(self);\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function _extends(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function isPolyfill(x, y) {\n    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n    ;\n}\nvar is = typeof Object.is === \"function\" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic\n// dispatch for CommonJS interop named imports.\nvar useState = react__WEBPACK_IMPORTED_MODULE_1__.useState, useEffect = react__WEBPACK_IMPORTED_MODULE_1__.useEffect, useLayoutEffect = react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect, useDebugValue = react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\nfunction useSyncExternalStore$2(subscribe, getSnapshot, // React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n    if (true) {\n        if (!didWarnOld18Alpha) {\n            if (\"startTransition\" in react__WEBPACK_IMPORTED_MODULE_1__) {\n                didWarnOld18Alpha = true;\n                console.error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n            }\n        }\n    } // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    var value = getSnapshot();\n    if (true) {\n        if (!didWarnUncachedGetSnapshot) {\n            var cachedValue = getSnapshot();\n            if (!is(value, cachedValue)) {\n                console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n            }\n        }\n    } // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    var _useState = _sliced_to_array(useState({\n        inst: {\n            value: value,\n            getSnapshot: getSnapshot\n        }\n    }), 2), inst = _useState[0].inst, forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    useLayoutEffect(function() {\n        inst.value = value;\n        inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n            // Force a re-render.\n            forceUpdate({\n                inst: inst\n            });\n        } // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        subscribe,\n        value,\n        getSnapshot\n    ]);\n    useEffect(function() {\n        // Check for changes right before subscribing. Subsequent changes will be\n        // detected in the subscription handler.\n        if (checkIfSnapshotChanged(inst)) {\n            // Force a re-render.\n            forceUpdate({\n                inst: inst\n            });\n        }\n        var handleStoreChange = function() {\n            // TODO: Because there is no cross-renderer API for batching updates, it's\n            // up to the consumer of this library to wrap their subscription event\n            // with unstable_batchedUpdates. Should we try to detect when this isn't\n            // the case and print a warning in development?\n            // The store changed. Check if the snapshot changed since the last time we\n            // read from the store.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceUpdate({\n                    inst: inst\n                });\n            }\n        }; // Subscribe to the store and return a clean-up function.\n        return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        subscribe\n    ]);\n    useDebugValue(value);\n    return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n    var latestGetSnapshot = inst.getSnapshot;\n    var prevValue = inst.value;\n    try {\n        var nextValue = latestGetSnapshot();\n        return !is(prevValue, nextValue);\n    } catch (error) {\n        return true;\n    }\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */ function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n    // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n    // React do not expose a way to check if we're hydrating. So users of the shim\n    // will need to track that themselves and return the correct value\n    // from `getSnapshot`.\n    return getSnapshot();\n}\n/**\n * Inlined into the react-router repo since use-sync-external-store does not\n * provide a UMD-compatible package, so we need this to be able to distribute\n * UMD react-router bundles\n */ var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isServerEnvironment = !canUseDOM;\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;\nvar useSyncExternalStore = \"useSyncExternalStore\" in react__WEBPACK_IMPORTED_MODULE_1__ ? function(module) {\n    return module.useSyncExternalStore;\n}(react__WEBPACK_IMPORTED_MODULE_1__) : shim;\n// Contexts for data routers\nvar DataStaticRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    DataStaticRouterContext.displayName = \"DataStaticRouterContext\";\n}\nvar DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\nvar NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nvar RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext({\n    outlet: null,\n    matches: []\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-href\n */ function useHref(to, _temp) {\n    var relative = (_temp === void 0 ? {} : _temp).relative;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    var _React_useContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext), basename = _React_useContext.basename, navigator = _React_useContext.navigator;\n    var _useResolvedPath = useResolvedPath(to, {\n        relative: relative\n    }), hash = _useResolvedPath.hash, pathname = _useResolvedPath.pathname, search = _useResolvedPath.search;\n    var joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search: search,\n        hash: hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context\n */ function useInRouterContext() {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-location\n */ function useLocation() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigation-type\n */ function useNavigationType() {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).navigationType;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-match\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    var pathname = useLocation().pathname;\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath)(pattern, pathname);\n    }, [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ /**\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter(function(match, index) {\n        return index === 0 || !match.route.index && match.pathnameBase !== matches[index - 1].pathnameBase;\n    });\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate\n */ function useNavigate() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    var _React_useContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext), basename = _React_useContext.basename, navigator = _React_useContext.navigator;\n    var matches = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).matches;\n    var _useLocation = useLocation(), locationPathname = _useLocation.pathname;\n    var routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(function(match) {\n        return match.pathnameBase;\n    }));\n    var activeRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function() {\n        activeRef.current = true;\n    });\n    var navigate = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(activeRef.current, \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\") : 0;\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        var path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\"); // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history.  If this is a root navigation, then we\n        // navigate to the raw basename which allows the basename to have full\n        // control over the presence of a trailing slash on root links\n        if (basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname\n    ]);\n    return navigate;\n}\nvar OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet-context\n */ function useOutletContext() {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet\n */ function useOutlet(context) {\n    var outlet = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-params\n */ function useParams() {\n    var matches = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).matches;\n    var routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    var relative = (_temp2 === void 0 ? {} : _temp2).relative;\n    var matches = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).matches;\n    var _useLocation = useLocation(), locationPathname = _useLocation.pathname;\n    var routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(function(match) {\n        return match.pathnameBase;\n    }));\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\");\n    }, [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    var dataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);\n    var _React_useContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext), parentMatches = _React_useContext.matches;\n    var routeMatch = parentMatches[parentMatches.length - 1];\n    var parentParams = routeMatch ? routeMatch.params : {};\n    var parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    var parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        var parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n    }\n    var locationFromContext = useLocation();\n    var location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        var parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    var pathname = location.pathname || \"/\";\n    var remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    var matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(matches == null || matches[matches.length - 1].route.element !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" does not have an element. \" + \"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\") : 0;\n    }\n    var renderedMatches = _renderMatches(matches && matches.map(function(match) {\n        return Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([\n                parentPathnameBase,\n                match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([\n                parentPathnameBase,\n                match.pathnameBase\n            ])\n        });\n    }), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorElement() {\n    var error = useRouteError();\n    var message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : _instanceof(error, Error) ? error.message : JSON.stringify(error);\n    var stack = _instanceof(error, Error) ? error.stack : null;\n    var lightgrey = \"rgba(200,200,200, 0.5)\";\n    var preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    var codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"h2\", null, \"Unhandled Thrown Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own\\xA0\", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"code\", {\n        style: codeStyles\n    }, \"errorElement\"), \" props on\\xA0\", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"code\", {\n        style: codeStyles\n    }, \"<Route>\")));\n}\nvar RenderErrorBoundary = /*#__PURE__*/ function(_React_Component) {\n    \"use strict\";\n    _inherits(RenderErrorBoundary, _React_Component);\n    function RenderErrorBoundary(props) {\n        _class_call_check(this, RenderErrorBoundary);\n        var _this;\n        _this = _call_super(this, RenderErrorBoundary, [\n            props\n        ]);\n        _this.state = {\n            location: props.location,\n            error: props.error\n        };\n        return _this;\n    }\n    _create_class(RenderErrorBoundary, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(error, errorInfo) {\n                console.error(\"React Router caught the following error during render\", error, errorInfo);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                return this.state.error ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteErrorContext.Provider, {\n                    value: this.state.error,\n                    children: this.props.component\n                }) : this.props.children;\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromError\",\n            value: function getDerivedStateFromError(error) {\n                return {\n                    error: error\n                };\n            }\n        },\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(props, state) {\n                // When we get into an error state, the user will likely click \"back\" to the\n                // previous page that didn't have an error. Because this wraps the entire\n                // application, that will have no effect--the error page continues to display.\n                // This gives us a mechanism to recover from the error when the location changes.\n                //\n                // Whether we're in an error state or not, we update the location in state\n                // so that when we are in an error state, it gets reset when a new location\n                // comes in and the user recovers from the error.\n                if (state.location !== props.location) {\n                    return {\n                        error: props.error,\n                        location: props.location\n                    };\n                } // If we're not changing locations, preserve the location but still surface\n                // any new errors that may come through. We retain the existing error, we do\n                // this because the error provided from the app state may be cleared without\n                // the location changing.\n                return {\n                    error: props.error || state.error,\n                    location: state.location\n                };\n            }\n        }\n    ]);\n    return RenderErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nfunction RenderedRoute(_ref) {\n    var routeContext = _ref.routeContext, match = _ref.match, children = _ref.children;\n    var dataStaticRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataStaticRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataStaticRouterContext && match.route.errorElement) {\n        dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (matches == null) {\n        if (dataRouterState != null && dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    var renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary\n    var errors = dataRouterState == null ? void 0 : dataRouterState.errors;\n    if (errors != null) {\n        var errorIndex = renderedMatches.findIndex(function(m) {\n            return m.route.id && (errors == null ? void 0 : errors[m.route.id]);\n        });\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"Could not find a matching route for the current errors: \" + errors) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    return renderedMatches.reduceRight(function(outlet, match, index) {\n        var error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors\n        var errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(DefaultErrorElement, null) : null;\n        var getChildren = function() {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet: outlet,\n                    matches: parentMatches.concat(renderedMatches.slice(0, index + 1))\n                }\n            }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet);\n        }; // Only wrap in an error boundary within data router usages when we have an\n        // errorElement on this route.  Otherwise let it bubble up to an ancestor\n        // errorElement\n        return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            component: errorElement,\n            error: error,\n            children: getChildren()\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    var state = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    var state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    var dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    var state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return {\n        revalidate: dataRouterContext.router.revalidate,\n        state: state.revalidation\n    };\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    var _useDataRouterState = useDataRouterState(DataRouterStateHook.UseMatches), matches = _useDataRouterState.matches, loaderData = _useDataRouterState.loaderData;\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return matches.map(function(match) {\n            var pathname = match.pathname, params = match.params; // Note: This structure matches that created by createUseMatchesMatch\n            // in the @remix-run/router , so if you change this please also change\n            // that :)  Eventually we'll DRY this up\n            return {\n                id: match.route.id,\n                pathname: pathname,\n                params: params,\n                data: loaderData[match.route.id],\n                handle: match.route.handle\n            };\n        });\n    }, [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    var state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    var route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"useLoaderData must be used inside a RouteContext\") : 0 : void 0;\n    var thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"useLoaderData can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\n    return state.loaderData[thisRoute.route.id];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    var state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    var state = useDataRouterState(DataRouterStateHook.UseActionData);\n    var route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"useActionData must be used inside a RouteContext\") : 0 : void 0;\n    return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * errorElement to display a proper error message.\n */ function useRouteError() {\n    var _state$errors;\n    var error = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteErrorContext);\n    var state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    var route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);\n    var thisRoute = route.matches[route.matches.length - 1]; // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error) {\n        return error;\n    }\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"useRouteError must be used inside a RouteContext\") : 0 : void 0;\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"useRouteError can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0; // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];\n}\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */ function useAsyncValue() {\n    var value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */ function useAsyncError() {\n    var value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(false, message) : 0;\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    var fallbackElement = _ref.fallbackElement, router = _ref.router;\n    // Sync router state to our component state to force re-renders\n    var state = useSyncExternalStore(router.subscribe, function() {\n        return router.state;\n    }, // but we pass our serialized hydration data into the router so state here\n    // is already synced with what the server saw\n    function() {\n        return router.state;\n    });\n    var navigator = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return {\n            createHref: router.createHref,\n            go: function(n) {\n                return router.navigate(n);\n            },\n            push: function(to, state, opts) {\n                return router.navigate(to, {\n                    state: state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                });\n            },\n            replace: function(to, state, opts) {\n                return router.navigate(to, {\n                    replace: true,\n                    state: state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                });\n            }\n        };\n    }, [\n        router\n    ]);\n    var basename = router.basename || \"/\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterContext.Provider, {\n        value: {\n            router: router,\n            navigator: navigator,\n            static: false,\n            // Do we need this?\n            basename: basename\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {\n        basename: router.basename,\n        location: router.state.location,\n        navigationType: router.state.historyAction,\n        navigator: navigator\n    }, router.state.initialized ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Routes, null) : fallbackElement)));\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/memory-router\n */ function MemoryRouter(_ref2) {\n    var basename = _ref2.basename, children = _ref2.children, initialEntries = _ref2.initialEntries, initialIndex = _ref2.initialIndex;\n    var historyRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({\n            initialEntries: initialEntries,\n            initialIndex: initialIndex,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _React_useState = _sliced_to_array(react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        action: history.action,\n        location: history.location\n    }), 2), state = _React_useState[0], setState = _React_useState[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(function() {\n        return history.listen(setState);\n    }, [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/components/navigate\n */ function Navigate(_ref3) {\n    var to = _ref3.to, replace = _ref3.replace, state = _ref3.state, relative = _ref3.relative;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(!react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    var dataRouterState = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);\n    var navigate = useNavigate();\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function() {\n        // Avoid kicking off multiple navigations if we're in the middle of a\n        // data-router navigation, since components get re-rendered when we enter\n        // a submitting/loading state\n        if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n            return;\n        }\n        navigate(to, {\n            replace: replace,\n            state: state,\n            relative: relative\n        });\n    });\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/components/outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/router\n */ function Router(_ref4) {\n    var tmp = _ref4.basename, basenameProp = tmp === void 0 ? \"/\" : tmp, _ref4_children = _ref4.children, children = _ref4_children === void 0 ? null : _ref4_children, locationProp = _ref4.location, _ref4_navigationType = _ref4.navigationType, navigationType = _ref4_navigationType === void 0 ? _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop : _ref4_navigationType, navigator = _ref4.navigator, tmp1 = _ref4.static, staticProp = tmp1 === void 0 ? false : tmp1;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0; // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    var basename = basenameProp.replace(/^\\/*/, \"/\");\n    var navigationContext = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return {\n            basename: basename,\n            navigator: navigator,\n            static: staticProp\n        };\n    }, [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationProp);\n    }\n    var _locationProp_pathname = locationProp.pathname, pathname = _locationProp_pathname === void 0 ? \"/\" : _locationProp_pathname, _locationProp_search = locationProp.search, search = _locationProp_search === void 0 ? \"\" : _locationProp_search, _locationProp_hash = locationProp.hash, hash = _locationProp_hash === void 0 ? \"\" : _locationProp_hash, _locationProp_state = locationProp.state, state = _locationProp_state === void 0 ? null : _locationProp_state, _locationProp_key = locationProp.key, key = _locationProp_key === void 0 ? \"default\" : _locationProp_key;\n    var location = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        var trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            pathname: trailingPathname,\n            search: search,\n            hash: hash,\n            state: state,\n            key: key\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(location != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : 0;\n    if (location == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {\n        children: children,\n        value: {\n            location: location,\n            navigationType: navigationType\n        }\n    }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/components/routes\n */ function Routes(_ref5) {\n    var children = _ref5.children, location = _ref5.location;\n    var dataRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes\n    // directly.  If we have children, then we're in a descendant tree and we\n    // need to use child routes.\n    var routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);\n    return useRoutes(routes, location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref6) {\n    var children = _ref6.children, errorElement = _ref6.errorElement, resolve = _ref6.resolve;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus;\n(function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n})(AwaitRenderStatus || (AwaitRenderStatus = {}));\nvar neverSettledPromise = new Promise(function() {});\nvar AwaitErrorBoundary = /*#__PURE__*/ function(_React_Component) {\n    \"use strict\";\n    _inherits(AwaitErrorBoundary, _React_Component);\n    function AwaitErrorBoundary(props) {\n        _class_call_check(this, AwaitErrorBoundary);\n        var _this;\n        _this = _call_super(this, AwaitErrorBoundary, [\n            props\n        ]);\n        _this.state = {\n            error: null\n        };\n        return _this;\n    }\n    _create_class(AwaitErrorBoundary, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(error, errorInfo) {\n                console.error(\"<Await> caught the following error during render\", error, errorInfo);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this_props = this.props, children = _this_props.children, errorElement = _this_props.errorElement, resolve = _this_props.resolve;\n                var promise = null;\n                var status = AwaitRenderStatus.pending;\n                if (!_instanceof(resolve, Promise)) {\n                    // Didn't get a promise - provide as a resolved promise\n                    status = AwaitRenderStatus.success;\n                    promise = Promise.resolve();\n                    Object.defineProperty(promise, \"_tracked\", {\n                        get: function() {\n                            return true;\n                        }\n                    });\n                    Object.defineProperty(promise, \"_data\", {\n                        get: function() {\n                            return resolve;\n                        }\n                    });\n                } else if (this.state.error) {\n                    // Caught a render error, provide it as a rejected promise\n                    status = AwaitRenderStatus.error;\n                    var renderError = this.state.error;\n                    promise = Promise.reject().catch(function() {}); // Avoid unhandled rejection warnings\n                    Object.defineProperty(promise, \"_tracked\", {\n                        get: function() {\n                            return true;\n                        }\n                    });\n                    Object.defineProperty(promise, \"_error\", {\n                        get: function() {\n                            return renderError;\n                        }\n                    });\n                } else if (resolve._tracked) {\n                    // Already tracked promise - check contents\n                    promise = resolve;\n                    status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n                } else {\n                    // Raw (untracked) promise - track it\n                    status = AwaitRenderStatus.pending;\n                    Object.defineProperty(resolve, \"_tracked\", {\n                        get: function() {\n                            return true;\n                        }\n                    });\n                    promise = resolve.then(function(data) {\n                        return Object.defineProperty(resolve, \"_data\", {\n                            get: function() {\n                                return data;\n                            }\n                        });\n                    }, function(error) {\n                        return Object.defineProperty(resolve, \"_error\", {\n                            get: function() {\n                                return error;\n                            }\n                        });\n                    });\n                }\n                if (status === AwaitRenderStatus.error && _instanceof(promise._error, _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError)) {\n                    // Freeze the UI by throwing a never resolved promise\n                    throw neverSettledPromise;\n                }\n                if (status === AwaitRenderStatus.error && !errorElement) {\n                    // No errorElement, throw to the nearest route-level error boundary\n                    throw promise._error;\n                }\n                if (status === AwaitRenderStatus.error) {\n                    // Render via our errorElement\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {\n                        value: promise,\n                        children: errorElement\n                    });\n                }\n                if (status === AwaitRenderStatus.success) {\n                    // Render children with resolved value\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {\n                        value: promise,\n                        children: children\n                    });\n                } // Throw to the suspense boundary\n                throw promise;\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromError\",\n            value: function getDerivedStateFromError(error) {\n                return {\n                    error: error\n                };\n            }\n        }\n    ]);\n    return AwaitErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */ function ResolveAwait(_ref7) {\n    var children = _ref7.children;\n    var data = useAsyncValue();\n    if (typeof children === \"function\") {\n        return children(data);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children);\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    var routes = [];\n    react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, function(element, index) {\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        var treePath = _to_consumable_array(parentPath).concat([\n            index\n        ]);\n        var route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            hasErrorBoundary: element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\n/**\n * @private\n * Walk the route tree and add hasErrorBoundary if it's not provided, so that\n * users providing manual route arrays can just specify errorElement\n */ function enhanceManualRouteObjects(routes) {\n    return routes.map(function(route) {\n        var routeClone = _extends({}, route);\n        if (routeClone.hasErrorBoundary == null) {\n            routeClone.hasErrorBoundary = routeClone.errorElement != null;\n        }\n        if (routeClone.children) {\n            routeClone.children = enhanceManualRouteObjects(routeClone.children);\n        }\n        return routeClone;\n    });\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes: enhanceManualRouteObjects(routes)\n    }).initialize();\n} ///////////////////////////////////////////////////////////////////////////////\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0EsR0FJQTs7O0NBR0EsR0FDQSxTQUFTQSxVQUFULENBQW9CQyxDQUFwQixFQUE0QkMsQ0FBNUIsRUFBb0M7SUFDbEMsT0FDR0QsQ0FBQyxLQUFLQyxDQUFOLEtBQVlELENBQUMsS0FBSyxDQUFOLElBQVcsSUFBSUEsQ0FBSixLQUFVLEtBQUlDLENBQXJDLENBQUQsR0FBOENELENBQUMsS0FBS0EsQ0FBTixJQUFXQyxDQUFDLEtBQUtBLENBRGpFOztBQUdEO0FBRUQsSUFBTUMsRUFBK0IsR0FDbkMsT0FBT0MsTUFBTSxDQUFDRCxFQUFkLEtBQXFCLFVBQXJCLEdBQWtDQyxNQUFNLENBQUNELEVBQXpDLEdBQThDSCxVQURoRDtBQUlBO0FBQ0EsTUFBTSxzTUFBMERTLGdEQUFsQkQ7QUFFOUMsSUFBSUUsaUJBQWlCLEdBQUcsS0FBeEI7QUFDQSxJQUFJQywwQkFBMEIsR0FBRyxLQUFqQztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLHNCQUFULENBQ0xDLFNBREssRUFFTEMsV0FGSyxFQUlMO0FBQ0E7QUFDQTtBQUNBQyxpQkFQSyxFQVFGO0lBQ0gsSUFBYTtRQUNYLElBQUksQ0FBQ0wsaUJBQUwsRUFBd0I7WUFDdEIsSUFBSSx1REFBSixFQUFnQztnQkFDOUJBLGlCQUFpQixHQUFHLElB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O1FBT2xCN0ssTUFBTSxFQUFFeUsseUJBQXlCLENBQUN6SyxNQUFEO0tBUGhCLENBQVosQ0FRSjhLLFVBUkksRUFBUDtBQVNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi9saWIvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS91c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1DbGllbnQudHM/YTViNyIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL2xpYi91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbVNlcnZlci50cz8wZjI4Iiwid2VicGFjazovL0BvcGVubXJzL2VzbS1hcHAtc2hlbGwvLi4vbGliL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vaW5kZXgudHM/ZTRjYSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL2xpYi9jb250ZXh0LnRzPzQxY2MiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi9saWIvaG9va3MudHN4PzE2NTMiLCJ3ZWJwYWNrOi8vQG9wZW5tcnMvZXNtLWFwcC1zaGVsbC8uLi9saWIvY29tcG9uZW50cy50c3g/ZTQ0OSIsIndlYnBhY2s6Ly9Ab3Blbm1ycy9lc20tYXBwLXNoZWxsLy4uL2luZGV4LnRzPzczMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXNQb2x5ZmlsbCh4OiBhbnksIHk6IGFueSkge1xuICByZXR1cm4gKFxuICAgICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICk7XG59XG5cbmNvbnN0IGlzOiAoeDogYW55LCB5OiBhbnkpID0+IGJvb2xlYW4gPVxuICB0eXBlb2YgT2JqZWN0LmlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBpc1BvbHlmaWxsO1xuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHVzZXMgZHluYW1pY1xuLy8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cbmNvbnN0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlIH0gPSBSZWFjdDtcblxubGV0IGRpZFdhcm5PbGQxOEFscGhhID0gZmFsc2U7XG5sZXQgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTtcblxuLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncbi8vIGJlY2F1c2Ugb2YgYSB2ZXJ5IHBhcnRpY3VsYXIgc2V0IG9mIGltcGxlbWVudGF0aW9uIGRldGFpbHMgYW5kIGFzc3VtcHRpb25zXG4vLyAtLSBjaGFuZ2UgYW55IG9uZSBvZiB0aGVtIGFuZCBpdCB3aWxsIGJyZWFrLiBUaGUgbW9zdCBpbXBvcnRhbnQgYXNzdW1wdGlvblxuLy8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcbi8vIG9ubHkgYXZhaWxhYmxlIGluIHZlcnNpb25zIG9mIFJlYWN0IHRoYXQgYWxzbyBoYXZlIGEgYnVpbHQtaW5cbi8vIHVzZVN5bmNFeHRlcm5hbFN0b3JlIEFQSS4gQW5kIHdlIG9ubHkgdXNlIHRoaXMgc2hpbSB3aGVuIHRoZSBidWlsdC1pbiBBUElcbi8vIGRvZXMgbm90IGV4aXN0LlxuLy9cbi8vIERvIG5vdCBhc3N1bWUgdGhhdCB0aGUgY2xldmVyIGhhY2tzIHVzZWQgYnkgdGhpcyBob29rIGFsc28gd29yayBpbiBnZW5lcmFsLlxuLy8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmU8VD4oXG4gIHN1YnNjcmliZTogKGZuOiAoKSA9PiB2b2lkKSA9PiAoKSA9PiB2b2lkLFxuICBnZXRTbmFwc2hvdDogKCkgPT4gVCxcbiAgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbiAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGZyb20gYGdldFNuYXBzaG90YC5cbiAgZ2V0U2VydmVyU25hcHNob3Q/OiAoKSA9PiBUXG4pOiBUIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCkge1xuICAgICAgICBkaWRXYXJuT2xkMThBbHBoYSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0IFwiICtcbiAgICAgICAgICAgIFwiZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlIFwiICtcbiAgICAgICAgICAgIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSBcIiArXG4gICAgICAgICAgICBcInRvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gQWdhaW4sIHRoaXNcbiAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG1vc3QgaW1wb3J0YW50bHkgdGhhdCB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG4gIGNvbnN0IHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICBjb25zdCBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG4gICAgICBpZiAoIWlzKHZhbHVlLCBjYWNoZWRWYWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuICBjb25zdCBbeyBpbnN0IH0sIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHsgaW5zdDogeyB2YWx1ZSwgZ2V0U25hcHNob3QgfSB9KTtcblxuICAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAvLyBpbiB0aGUgbGF5b3V0IHBoYXNlIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSB0ZWFyaW5nIGNoZWNrIHRoYXRcbiAgLy8gaGFwcGVucyBvbiBzdWJzY3JpYmUuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcblxuICAgIC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgcmlnaHQgYmVmb3JlIHN1YnNjcmliaW5nLiBTdWJzZXF1ZW50IGNoYW5nZXMgd2lsbCBiZVxuICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVVwZGF0ZSh7IGluc3QgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVN0b3JlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cblxuICAgICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0IH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbc3Vic2NyaWJlXSk7XG5cbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0OiBhbnkpIHtcbiAgY29uc3QgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICBjb25zdCBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuICB0cnkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFpcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmU8VD4oXG4gIHN1YnNjcmliZTogKGZuOiAoKSA9PiB2b2lkKSA9PiAoKSA9PiB2b2lkLFxuICBnZXRTbmFwc2hvdDogKCkgPT4gVCxcbiAgZ2V0U2VydmVyU25hcHNob3Q/OiAoKSA9PiBUXG4pOiBUIHtcbiAgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbiAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGZyb20gYGdldFNuYXBzaG90YC5cbiAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG59XG4iLCIvKipcbiAqIElubGluZWQgaW50byB0aGUgcmVhY3Qtcm91dGVyIHJlcG8gc2luY2UgdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgZG9lcyBub3RcbiAqIHByb3ZpZGUgYSBVTUQtY29tcGF0aWJsZSBwYWNrYWdlLCBzbyB3ZSBuZWVkIHRoaXMgdG8gYmUgYWJsZSB0byBkaXN0cmlidXRlXG4gKiBVTUQgcmVhY3Qtcm91dGVyIGJ1bmRsZXNcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIGNsaWVudCB9IGZyb20gXCIuL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbUNsaWVudFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgc2VydmVyIH0gZnJvbSBcIi4vdXNlU3luY0V4dGVybmFsU3RvcmVTaGltU2VydmVyXCI7XG5cbmNvbnN0IGNhblVzZURPTTogYm9vbGVhbiA9ICEhKFxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiXG4pO1xuY29uc3QgaXNTZXJ2ZXJFbnZpcm9ubWVudCA9ICFjYW5Vc2VET007XG5jb25zdCBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHNlcnZlciA6IGNsaWVudDtcblxuZXhwb3J0IGNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID1cbiAgXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiIGluIFJlYWN0XG4gICAgPyAoKG1vZHVsZSkgPT4gbW9kdWxlLnVzZVN5bmNFeHRlcm5hbFN0b3JlKShSZWFjdClcbiAgICA6IHNoaW07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQWdub3N0aWNSb3V0ZU1hdGNoLFxuICBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QsXG4gIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgSGlzdG9yeSxcbiAgTG9jYXRpb24sXG4gIFJvdXRlcixcbiAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIFRvLFxuICBUcmFja2VkUHJvbWlzZSxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSB9IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG4vLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cbi8vIGV4cG9ydCBmcm9tIHJlYWN0LXJvdXRlclxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsb2FkZXI/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4OiB0cnVlO1xuICBjaGlsZHJlbj86IHVuZGVmaW5lZDtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9uSW5kZXhSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleD86IGZhbHNlO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBSb3V0ZU9iamVjdCA9IEluZGV4Um91dGVPYmplY3QgfCBOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBEYXRhUm91dGVPYmplY3QgPSBSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIFJvdXRlT2JqZWN0ID0gUm91dGVPYmplY3Rcbj4gZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT4ge31cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhUm91dGVNYXRjaCBleHRlbmRzIFJvdXRlTWF0Y2g8c3RyaW5nLCBEYXRhUm91dGVPYmplY3Q+IHt9XG5cbi8vIENvbnRleHRzIGZvciBkYXRhIHJvdXRlcnNcbmV4cG9ydCBjb25zdCBEYXRhU3RhdGljUm91dGVyQ29udGV4dCA9XG4gIFJlYWN0LmNyZWF0ZUNvbnRleHQ8U3RhdGljSGFuZGxlckNvbnRleHQgfCBudWxsPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIERhdGFTdGF0aWNSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhU3RhdGljUm91dGVyQ29udGV4dFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFSb3V0ZXJDb250ZXh0T2JqZWN0IGV4dGVuZHMgTmF2aWdhdGlvbkNvbnRleHRPYmplY3Qge1xuICByb3V0ZXI6IFJvdXRlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERhdGFSb3V0ZXJDb250ZXh0ID1cbiAgUmVhY3QuY3JlYXRlQ29udGV4dDxEYXRhUm91dGVyQ29udGV4dE9iamVjdCB8IG51bGw+KG51bGwpO1xuaWYgKF9fREVWX18pIHtcbiAgRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IGNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBSb3V0ZXJbXCJzdGF0ZVwiXSB8IG51bGxcbj4obnVsbCk7XG5pZiAoX19ERVZfXykge1xuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbn1cblxuZXhwb3J0IGNvbnN0IEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8VHJhY2tlZFByb21pc2UgfCBudWxsPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIEF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbn1cblxuZXhwb3J0IHR5cGUgUmVsYXRpdmVSb3V0aW5nVHlwZSA9IFwicm91dGVcIiB8IFwicGF0aFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlT3B0aW9ucyB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xufVxuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCA8Um91dGVyPiBBUElcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICogYW5kL29yIGxvY2F0aW9uIHdlcmUgdG8gYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBoaXN0b3J5IGluc3RhbmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRvciB7XG4gIGNyZWF0ZUhyZWY6IEhpc3RvcnlbXCJjcmVhdGVIcmVmXCJdO1xuICBnbzogSGlzdG9yeVtcImdvXCJdO1xuICBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnksIG9wdHM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnksIG9wdHM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgTmF2aWdhdGlvbkNvbnRleHRPYmplY3Qge1xuICBiYXNlbmFtZTogc3RyaW5nO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5hdmlnYXRpb25Db250ZXh0T2JqZWN0PihcbiAgbnVsbCFcbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG59XG5cbmludGVyZmFjZSBMb2NhdGlvbkNvbnRleHRPYmplY3Qge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIG5hdmlnYXRpb25UeXBlOiBOYXZpZ2F0aW9uVHlwZTtcbn1cblxuZXhwb3J0IGNvbnN0IExvY2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TG9jYXRpb25Db250ZXh0T2JqZWN0PihcbiAgbnVsbCFcbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZUNvbnRleHRPYmplY3Qge1xuICBvdXRsZXQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGw7XG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXTtcbn1cblxuZXhwb3J0IGNvbnN0IFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Um91dGVDb250ZXh0T2JqZWN0Pih7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW10sXG59KTtcblxuaWYgKF9fREVWX18pIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuXG5leHBvcnQgY29uc3QgUm91dGVFcnJvckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PGFueT4obnVsbCk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgTG9jYXRpb24sXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhcmFtcyxcbiAgUGF0aCxcbiAgUGF0aE1hdGNoLFxuICBQYXRoUGF0dGVybixcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBUbyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGludmFyaWFudCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZXNvbHZlVG8sXG4gIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUm91dGVDb250ZXh0T2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0LFxuICBSb3V0ZUNvbnRleHQsXG4gIFJvdXRlRXJyb3JDb250ZXh0LFxuICBBd2FpdENvbnRleHQsXG4gIERhdGFTdGF0aWNSb3V0ZXJDb250ZXh0LFxufSBmcm9tIFwiLi9jb250ZXh0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9ob29rcy91c2UtaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZihcbiAgdG86IFRvLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPVxuICAgICAgcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHsgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZXI+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2hvb2tzL3VzZS1uYXZpZ2F0aW9uLXR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCk6IE5hdmlnYXRpb25UeXBlIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFVSTCBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZSBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvaG9va3MvdXNlLW1hdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCk6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hQYXRoPFBhcmFtS2V5LCBQYXRoPihwYXR0ZXJuLCBwYXRobmFtZSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgKHRvOiBUbywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWQ7XG4gIChkZWx0YTogbnVtYmVyKTogdm9pZDtcbn1cblxuLyoqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSkge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8XG4gICAgICAoIW1hdGNoLnJvdXRlLmluZGV4ICYmXG4gICAgICAgIG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gbWF0Y2hlc1tpbmRleCAtIDFdLnBhdGhuYW1lQmFzZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2hvb2tzL3VzZS1uYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGUoKTogTmF2aWdhdGVGdW5jdGlvbiB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpLm1hcCgobWF0Y2gpID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuXG4gIGxldCBuYXZpZ2F0ZTogTmF2aWdhdGVGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh0bzogVG8gfCBudW1iZXIsIG9wdGlvbnM6IE5hdmlnYXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgICAgYFlvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIGAgK1xuICAgICAgICAgIGB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gXG4gICAgICApO1xuXG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgICAgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgICAgICk7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgICAgIC8vIHRvIGhhbmRpbmcgb2ZmIHRvIGhpc3RvcnkuICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIHdlXG4gICAgICAvLyBuYXZpZ2F0ZSB0byB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsXG4gICAgICAvLyBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICAgICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgICAgICBwYXRoLnBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICAgICAgPyBiYXNlbmFtZVxuICAgICAgICAgICAgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZV1cbiAgKTtcblxuICByZXR1cm4gbmF2aWdhdGU7XG59XG5cbmNvbnN0IE91dGxldENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVua25vd24+KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IDxPdXRsZXQ+IHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0PzogdW5rbm93bik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0bGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e291dGxldH08L091dGxldENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9ob29rcy91c2UtcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8XG4gIFBhcmFtc09yS2V5IGV4dGVuZHMgc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHN0cmluZ1xuPigpOiBSZWFkb25seTxcbiAgW1BhcmFtc09yS2V5XSBleHRlbmRzIFtzdHJpbmddID8gUGFyYW1zPFBhcmFtc09yS2V5PiA6IFBhcnRpYWw8UGFyYW1zT3JLZXk+XG4+IHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyAocm91dGVNYXRjaC5wYXJhbXMgYXMgYW55KSA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKFxuICB0bzogVG8sXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBQYXRoIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2hvb2tzL3VzZS1yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IGRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IGAgK1xuICAgICAgICBgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgYCArXG4gICAgICAgIGBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGAgK1xuICAgICAgICBgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgYCArXG4gICAgICAgIGByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuYCArXG4gICAgICAgIGBQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBgICtcbiAgICAgICAgYHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cblxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPVxuICAgICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fFxuICAgICAgICBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCBgICtcbiAgICAgICAgYHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBgICtcbiAgICAgICAgYG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBgICtcbiAgICAgICAgYGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICA/IHBhdGhuYW1lXG4gICAgICA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuXG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcblxuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHxcbiAgICAgICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQuIGAgK1xuICAgICAgICBgVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFwiZW1wdHlcIiBwYWdlLmBcbiAgICApO1xuICB9XG5cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKFxuICAgIG1hdGNoZXMgJiZcbiAgICAgIG1hdGNoZXMubWFwKChtYXRjaCkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICAgICAgcGF0aG5hbWVCYXNlOlxuICAgICAgICAgICAgbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgICAgICAgICA/IHBhcmVudFBhdGhuYW1lQmFzZVxuICAgICAgICAgICAgICA6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZUJhc2VdKSxcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgcGFyZW50TWF0Y2hlcyxcbiAgICBkYXRhUm91dGVyU3RhdGVDb250ZXh0IHx8IHVuZGVmaW5lZFxuICApO1xuXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgLy8gdG8gdXNlIHRoZSBzY29wZWQgbG9jYXRpb24gaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGUuUG9wLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7cmVuZGVyZWRNYXRjaGVzfVxuICAgICAgPC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckVsZW1lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcilcbiAgICA/IGAke2Vycm9yLnN0YXR1c30gJHtlcnJvci5zdGF0dXNUZXh0fWBcbiAgICA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0geyBwYWRkaW5nOiBcIjAuNXJlbVwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHsgcGFkZGluZzogXCIycHggNHB4XCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoMj5VbmhhbmRsZWQgVGhyb3duIEVycm9yITwvaDI+XG4gICAgICA8aDMgc3R5bGU9e3sgZm9udFN0eWxlOiBcIml0YWxpY1wiIH19PnttZXNzYWdlfTwvaDM+XG4gICAgICB7c3RhY2sgPyA8cHJlIHN0eWxlPXtwcmVTdHlsZXN9PntzdGFja308L3ByZT4gOiBudWxsfVxuICAgICAgPHA+8J+SvyBIZXkgZGV2ZWxvcGVyIPCfkYs8L3A+XG4gICAgICA8cD5cbiAgICAgICAgWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5XG4gICAgICAgIHByb3ZpZGluZyB5b3VyIG93biZuYnNwO1xuICAgICAgICA8Y29kZSBzdHlsZT17Y29kZVN0eWxlc30+ZXJyb3JFbGVtZW50PC9jb2RlPiBwcm9wcyBvbiZuYnNwO1xuICAgICAgICA8Y29kZSBzdHlsZT17Y29kZVN0eWxlc30+Jmx0O1JvdXRlJmd0OzwvY29kZT5cbiAgICAgIDwvcD5cbiAgICA8Lz5cbiAgKTtcbn1cblxudHlwZSBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMgPSBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgZXJyb3I6IGFueTtcbiAgY29tcG9uZW50OiBSZWFjdC5SZWFjdE5vZGU7XG59PjtcblxudHlwZSBSZW5kZXJFcnJvckJvdW5kYXJ5U3RhdGUgPSB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgZXJyb3I6IGFueTtcbn07XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIFJlbmRlckVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgIHByb3BzOiBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMsXG4gICAgc3RhdGU6IFJlbmRlckVycm9yQm91bmRhcnlTdGF0ZVxuICApIHtcbiAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcbiAgICAvLyBwcmV2aW91cyBwYWdlIHRoYXQgZGlkbid0IGhhdmUgYW4gZXJyb3IuIEJlY2F1c2UgdGhpcyB3cmFwcyB0aGUgZW50aXJlXG4gICAgLy8gYXBwbGljYXRpb24sIHRoYXQgd2lsbCBoYXZlIG5vIGVmZmVjdC0tdGhlIGVycm9yIHBhZ2UgY29udGludWVzIHRvIGRpc3BsYXkuXG4gICAgLy8gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgLy9cbiAgICAvLyBXaGV0aGVyIHdlJ3JlIGluIGFuIGVycm9yIHN0YXRlIG9yIG5vdCwgd2UgdXBkYXRlIHRoZSBsb2NhdGlvbiBpbiBzdGF0ZVxuICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxuICAgIC8vIGNvbWVzIGluIGFuZCB0aGUgdXNlciByZWNvdmVycyBmcm9tIHRoZSBlcnJvci5cbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gKFxuICAgICAgPFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmVycm9yfVxuICAgICAgICBjaGlsZHJlbj17dGhpcy5wcm9wcy5jb21wb25lbnR9XG4gICAgICAvPlxuICAgICkgOiAoXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVuZGVyZWRSb3V0ZVByb3BzIHtcbiAgcm91dGVDb250ZXh0OiBSb3V0ZUNvbnRleHRPYmplY3Q7XG4gIG1hdGNoOiBSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3Q+O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZSh7IHJvdXRlQ29udGV4dCwgbWF0Y2gsIGNoaWxkcmVuIH06IFJlbmRlcmVkUm91dGVQcm9wcykge1xuICBsZXQgZGF0YVN0YXRpY1JvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFTdGF0aWNSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoZGF0YVN0YXRpY1JvdXRlckNvbnRleHQgJiYgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgZGF0YVN0YXRpY1JvdXRlckNvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cm91dGVDb250ZXh0fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1JvdXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsLFxuICBwYXJlbnRNYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXSxcbiAgZGF0YVJvdXRlclN0YXRlPzogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlPy5lcnJvcnMpIHtcbiAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMgYXMgRGF0YVJvdXRlTWF0Y2hbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG5cbiAgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XG4gIGxldCBlcnJvcnMgPSBkYXRhUm91dGVyU3RhdGU/LmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgJiYgZXJyb3JzPy5bbS5yb3V0ZS5pZF1cbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGVycm9ySW5kZXggPj0gMCxcbiAgICAgIGBDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciB0aGUgY3VycmVudCBlcnJvcnM6ICR7ZXJyb3JzfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBtYXRjaC5yb3V0ZS5pZCA/IGVycm9ycz8uW21hdGNoLnJvdXRlLmlkXSA6IG51bGw7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9yc1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBkYXRhUm91dGVyU3RhdGVcbiAgICAgID8gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IDxEZWZhdWx0RXJyb3JFbGVtZW50IC8+XG4gICAgICA6IG51bGw7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4gKFxuICAgICAgPFJlbmRlcmVkUm91dGVcbiAgICAgICAgbWF0Y2g9e21hdGNofVxuICAgICAgICByb3V0ZUNvbnRleHQ9e3tcbiAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7ZXJyb3JcbiAgICAgICAgICA/IGVycm9yRWxlbWVudFxuICAgICAgICAgIDogbWF0Y2gucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBtYXRjaC5yb3V0ZS5lbGVtZW50XG4gICAgICAgICAgOiBvdXRsZXR9XG4gICAgICA8L1JlbmRlcmVkUm91dGU+XG4gICAgKTtcbiAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAvLyBlcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvIGFuIGFuY2VzdG9yXG4gICAgLy8gZXJyb3JFbGVtZW50XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IChcbiAgICAgIDxSZW5kZXJFcnJvckJvdW5kYXJ5XG4gICAgICAgIGxvY2F0aW9uPXtkYXRhUm91dGVyU3RhdGUubG9jYXRpb259XG4gICAgICAgIGNvbXBvbmVudD17ZXJyb3JFbGVtZW50fVxuICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgIGNoaWxkcmVuPXtnZXRDaGlsZHJlbigpfVxuICAgICAgLz5cbiAgICApIDogKFxuICAgICAgZ2V0Q2hpbGRyZW4oKVxuICAgICk7XG4gIH0sIG51bGwgYXMgUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCk7XG59XG5cbmVudW0gRGF0YVJvdXRlckhvb2sge1xuICBVc2VSZXZhbGlkYXRvciA9IFwidXNlUmV2YWxpZGF0b3JcIixcbn1cblxuZW51bSBEYXRhUm91dGVyU3RhdGVIb29rIHtcbiAgVXNlTG9hZGVyRGF0YSA9IFwidXNlTG9hZGVyRGF0YVwiLFxuICBVc2VBY3Rpb25EYXRhID0gXCJ1c2VBY3Rpb25EYXRhXCIsXG4gIFVzZVJvdXRlRXJyb3IgPSBcInVzZVJvdXRlRXJyb3JcIixcbiAgVXNlTmF2aWdhdGlvbiA9IFwidXNlTmF2aWdhdGlvblwiLFxuICBVc2VSb3V0ZUxvYWRlckRhdGEgPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiLFxuICBVc2VNYXRjaGVzID0gXCJ1c2VNYXRjaGVzXCIsXG4gIFVzZVJldmFsaWRhdG9yID0gXCJ1c2VSZXZhbGlkYXRvclwiLFxufVxuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKFxuICBob29rTmFtZTogRGF0YVJvdXRlckhvb2sgfCBEYXRhUm91dGVyU3RhdGVIb29rXG4pIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJIb29rKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24sIGRlZmF1bHRpbmcgdG8gYW4gXCJpZGxlXCIgbmF2aWdhdGlvbiB3aGVuXG4gKiBubyBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJldmFsaWRhdGUgZnVuY3Rpb24gZm9yIG1hbnVhbGx5IHRyaWdnZXJpbmcgcmV2YWxpZGF0aW9uLCBhcyB3ZWxsXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgcmV0dXJuIHtcbiAgICByZXZhbGlkYXRlOiBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSxcbiAgICBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uLFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICogcGFyZW50L2NoaWxkIHJvdXRlcyBvciB0aGUgcm91dGUgXCJoYW5kbGVcIiBwcm9wZXJ0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHsgbWF0Y2hlcywgbG9hZGVyRGF0YSB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTWF0Y2hlc1xuICApO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICAgICAgICAvLyBOb3RlOiBUaGlzIHN0cnVjdHVyZSBtYXRjaGVzIHRoYXQgY3JlYXRlZCBieSBjcmVhdGVVc2VNYXRjaGVzTWF0Y2hcbiAgICAgICAgLy8gaW4gdGhlIEByZW1peC1ydW4vcm91dGVyICwgc28gaWYgeW91IGNoYW5nZSB0aGlzIHBsZWFzZSBhbHNvIGNoYW5nZVxuICAgICAgICAvLyB0aGF0IDopICBFdmVudHVhbGx5IHdlJ2xsIERSWSB0aGlzIHVwXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBkYXRhOiBsb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSBhcyB1bmtub3duLFxuICAgICAgICAgIGhhbmRsZTogbWF0Y2gucm91dGUuaGFuZGxlIGFzIHVua25vd24sXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICBbbWF0Y2hlcywgbG9hZGVyRGF0YV1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXIgZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgbG9hZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCk6IHVua25vd24ge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcblxuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUxvYWRlckRhdGEgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuXG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYHVzZUxvYWRlckRhdGEgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcblxuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVt0aGlzUm91dGUucm91dGUuaWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlckRhdGEgZm9yIHRoZSBnaXZlbiByb3V0ZUlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZDogc3RyaW5nKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuXG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlQWN0aW9uRGF0YSBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG5cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGU/LmFjdGlvbkRhdGEgfHwge30pWzBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxuICogZXJyb3Igb3IgYSByZW5kZXIgZXJyb3IuICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXJcbiAqIGVycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCk6IHVua25vd24ge1xuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIGludmFyaWFudChyb3V0ZSwgYHVzZVJvdXRlRXJyb3IgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuICBpbnZhcmlhbnQoXG4gICAgdGhpc1JvdXRlLnJvdXRlLmlkLFxuICAgIGB1c2VSb3V0ZUVycm9yIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bdGhpc1JvdXRlLnJvdXRlLmlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciA8QXdhaXQgLz4gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKTogdW5rbm93biB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIDxBd2FpdCAvPiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpOiB1bmtub3duIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9lcnJvcjtcbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcblxuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5OiBzdHJpbmcsIGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBUcmFja2VkUHJvbWlzZSxcbiAgSW5pdGlhbEVudHJ5LFxuICBMb2NhdGlvbixcbiAgTWVtb3J5SGlzdG9yeSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBSb3V0ZXJTdGF0ZSxcbiAgVG8sXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgaW52YXJpYW50LFxuICBwYXJzZVBhdGgsXG4gIHN0cmlwQmFzZW5hbWUsXG4gIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltIH0gZnJvbSBcIi4vdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbVwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIE5hdmlnYXRvcixcbiAgTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIEF3YWl0Q29udGV4dCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VSb3V0ZXMsXG4gIF9yZW5kZXJNYXRjaGVzLFxufSBmcm9tIFwiLi9ob29rc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclByb3ZpZGVyUHJvcHMge1xuICBmYWxsYmFja0VsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJvdXRlcjogUmVtaXhSb3V0ZXI7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHtcbiAgZmFsbGJhY2tFbGVtZW50LFxuICByb3V0ZXIsXG59OiBSb3V0ZXJQcm92aWRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgLy8gU3luYyByb3V0ZXIgc3RhdGUgdG8gb3VyIGNvbXBvbmVudCBzdGF0ZSB0byBmb3JjZSByZS1yZW5kZXJzXG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW0oXG4gICAgcm91dGVyLnN1YnNjcmliZSxcbiAgICAoKSA9PiByb3V0ZXIuc3RhdGUsXG4gICAgLy8gV2UgaGF2ZSB0byBwcm92aWRlIHRoaXMgc28gUmVhY3RAMTggZG9lc24ndCBjb21wbGFpbiBkdXJpbmcgaHlkcmF0aW9uLFxuICAgIC8vIGJ1dCB3ZSBwYXNzIG91ciBzZXJpYWxpemVkIGh5ZHJhdGlvbiBkYXRhIGludG8gdGhlIHJvdXRlciBzbyBzdGF0ZSBoZXJlXG4gICAgLy8gaXMgYWxyZWFkeSBzeW5jZWQgd2l0aCB3aGF0IHRoZSBzZXJ2ZXIgc2F3XG4gICAgKCkgPT4gcm91dGVyLnN0YXRlXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCk6IE5hdmlnYXRvciA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZ286IChuKSA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB9KSxcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG5cbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuXG4gIHJldHVybiAoXG4gICAgPERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIG5hdmlnYXRvcixcbiAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0aGlzP1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3N0YXRlfT5cbiAgICAgICAgPFJvdXRlclxuICAgICAgICAgIGJhc2VuYW1lPXtyb3V0ZXIuYmFzZW5hbWV9XG4gICAgICAgICAgbG9jYXRpb249e3JvdXRlci5zdGF0ZS5sb2NhdGlvbn1cbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZT17cm91dGVyLnN0YXRlLmhpc3RvcnlBY3Rpb259XG4gICAgICAgICAgbmF2aWdhdG9yPXtuYXZpZ2F0b3J9XG4gICAgICAgID5cbiAgICAgICAgICB7cm91dGVyLnN0YXRlLmluaXRpYWxpemVkID8gPFJvdXRlcyAvPiA6IGZhbGxiYWNrRWxlbWVudH1cbiAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICA8L0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9EYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9yb3V0ZXJzL21lbW9yeS1yb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleCxcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlUHJvcHMge1xuICB0bzogVG87XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2NvbXBvbmVudHMvbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2UsXG4gIHN0YXRlLFxuICByZWxhdGl2ZSxcbn06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEF2b2lkIGtpY2tpbmcgb2ZmIG11bHRpcGxlIG5hdmlnYXRpb25zIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYVxuICAgIC8vIGRhdGEtcm91dGVyIG5hdmlnYXRpb24sIHNpbmNlIGNvbXBvbmVudHMgZ2V0IHJlLXJlbmRlcmVkIHdoZW4gd2UgZW50ZXJcbiAgICAvLyBhIHN1Ym1pdHRpbmcvbG9hZGluZyBzdGF0ZVxuICAgIGlmIChkYXRhUm91dGVyU3RhdGUgJiYgZGF0YVJvdXRlclN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlLCByZWxhdGl2ZSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0bGV0UHJvcHMge1xuICBjb250ZXh0PzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvY29tcG9uZW50cy9vdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE91dGxldChwcm9wczogT3V0bGV0UHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IE5vbkluZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IE5vbkluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImxvYWRlclwiXTtcbiAgYWN0aW9uPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcInNob3VsZFJldmFsaWRhdGVcIl07XG4gIGhhbmRsZT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4PzogZmFsc2U7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRSb3V0ZVByb3BzIGV4dGVuZHMgUGF0aFJvdXRlUHJvcHMge31cblxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBJbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBJbmRleFJvdXRlT2JqZWN0W1wiaWRcIl07XG4gIGxvYWRlcj86IEluZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IEluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBJbmRleFJvdXRlT2JqZWN0W1wiaGFzRXJyb3JCb3VuZGFyeVwiXTtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IEluZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBJbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleDogdHJ1ZTtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBSb3V0ZVByb3BzID0gUGF0aFJvdXRlUHJvcHMgfCBMYXlvdXRSb3V0ZVByb3BzIHwgSW5kZXhSb3V0ZVByb3BzO1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9jb21wb25lbnRzL3JvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZShfcHJvcHM6IFJvdXRlUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIGAgK1xuICAgICAgYG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbiAgbmF2aWdhdGlvblR5cGU/OiBOYXZpZ2F0aW9uVHlwZTtcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSA8Um91dGVyPiBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIDxCcm93c2VyUm91dGVyPlxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgPFN0YXRpY1JvdXRlcj4gZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L3JvdXRlcnMvcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBOYXZpZ2F0aW9uVHlwZS5Qb3AsXG4gIG5hdmlnYXRvcixcbiAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2UsXG59OiBSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LmAgK1xuICAgICAgYCBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG5cbiAgLy8gUHJlc2VydmUgdHJhaWxpbmcgc2xhc2hlcyBvbiBiYXNlbmFtZSwgc28gd2UgY2FuIGxldCB0aGUgdXNlciBjb250cm9sXG4gIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuICBsZXQgYmFzZW5hbWUgPSBiYXNlbmFtZVByb3AucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljOiBzdGF0aWNQcm9wIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCIsXG4gIH0gPSBsb2NhdGlvblByb3A7XG5cbiAgbGV0IGxvY2F0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXksXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5XSk7XG5cbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbiAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmF2aWdhdGlvbkNvbnRleHR9PlxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICAgIHZhbHVlPXt7IGxvY2F0aW9uLCBuYXZpZ2F0aW9uVHlwZSB9fVxuICAgICAgLz5cbiAgICA8L05hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlc1Byb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2NvbXBvbmVudHMvcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb24sXG59OiBSb3V0ZXNQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgLy8gV2hlbiBpbiBhIERhdGFSb3V0ZXJDb250ZXh0IF93aXRob3V0XyBjaGlsZHJlbiwgd2UgdXNlIHRoZSByb3V0ZXIgcm91dGVzXG4gIC8vIGRpcmVjdGx5LiAgSWYgd2UgaGF2ZSBjaGlsZHJlbiwgdGhlbiB3ZSdyZSBpbiBhIGRlc2NlbmRhbnQgdHJlZSBhbmQgd2VcbiAgLy8gbmVlZCB0byB1c2UgY2hpbGQgcm91dGVzLlxuICBsZXQgcm91dGVzID1cbiAgICBkYXRhUm91dGVyQ29udGV4dCAmJiAhY2hpbGRyZW5cbiAgICAgID8gKGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yb3V0ZXMgYXMgRGF0YVJvdXRlT2JqZWN0W10pXG4gICAgICA6IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbik7XG4gIHJldHVybiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXdhaXRSZXNvbHZlUmVuZGVyRnVuY3Rpb24ge1xuICAoZGF0YTogQXdhaXRlZDxhbnk+KTogUmVhY3QuUmVhY3RFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF3YWl0UHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgQXdhaXRSZXNvbHZlUmVuZGVyRnVuY3Rpb247XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcmVzb2x2ZTogVHJhY2tlZFByb21pc2UgfCBhbnk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gQXdhaXQoeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH06IEF3YWl0UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8QXdhaXRFcnJvckJvdW5kYXJ5IHJlc29sdmU9e3Jlc29sdmV9IGVycm9yRWxlbWVudD17ZXJyb3JFbGVtZW50fT5cbiAgICAgIDxSZXNvbHZlQXdhaXQ+e2NoaWxkcmVufTwvUmVzb2x2ZUF3YWl0PlxuICAgIDwvQXdhaXRFcnJvckJvdW5kYXJ5PlxuICApO1xufVxuXG50eXBlIEF3YWl0RXJyb3JCb3VuZGFyeVByb3BzID0gUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6IFRyYWNrZWRQcm9taXNlIHwgYW55O1xufT47XG5cbnR5cGUgQXdhaXRFcnJvckJvdW5kYXJ5U3RhdGUgPSB7XG4gIGVycm9yOiBhbnk7XG59O1xuXG5lbnVtIEF3YWl0UmVuZGVyU3RhdHVzIHtcbiAgcGVuZGluZyxcbiAgc3VjY2VzcyxcbiAgZXJyb3IsXG59XG5cbmNvbnN0IG5ldmVyU2V0dGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEF3YWl0RXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEF3YWl0RXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgbGV0IHByb21pc2U6IFRyYWNrZWRQcm9taXNlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHN0YXR1czogQXdhaXRSZW5kZXJTdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuXG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gcmVzb2x2ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIC8vIENhdWdodCBhIHJlbmRlciBlcnJvciwgcHJvdmlkZSBpdCBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbiB3YXJuaW5nc1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHJlbmRlckVycm9yIH0pO1xuICAgIH0gZWxzZSBpZiAoKHJlc29sdmUgYXMgVHJhY2tlZFByb21pc2UpLl90cmFja2VkKSB7XG4gICAgICAvLyBBbHJlYWR5IHRyYWNrZWQgcHJvbWlzZSAtIGNoZWNrIGNvbnRlbnRzXG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9XG4gICAgICAgIHByb21pc2UuX2Vycm9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yXG4gICAgICAgICAgOiBwcm9taXNlLl9kYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3NcbiAgICAgICAgICA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oXG4gICAgICAgIChkYXRhOiBhbnkpID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEgfSksXG4gICAgICAgIChlcnJvcjogYW55KSA9PlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJlxuICAgICAgcHJvbWlzZS5fZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgLy8gRnJlZXplIHRoZSBVSSBieSB0aHJvd2luZyBhIG5ldmVyIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgLy8gTm8gZXJyb3JFbGVtZW50LCB0aHJvdyB0byB0aGUgbmVhcmVzdCByb3V0ZS1sZXZlbCBlcnJvciBib3VuZGFyeVxuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIDxBd2FpdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Byb21pc2V9IGNoaWxkcmVuPXtlcnJvckVsZW1lbnR9IC8+O1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICByZXR1cm4gPEF3YWl0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHJvbWlzZX0gY2hpbGRyZW49e2NoaWxkcmVufSAvPjtcbiAgICB9XG5cbiAgICAvLyBUaHJvdyB0byB0aGUgc3VzcGVuc2UgYm91bmRhcnlcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEluZGlyZWN0aW9uIHRvIGxldmVyYWdlIHVzZUFzeW5jVmFsdWUgZm9yIGEgcmVuZGVyLXByb3AgQVBJIG9uIDxBd2FpdD5cbiAqL1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KHtcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbjtcbn0pIHtcbiAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjaGlsZHJlbihkYXRhKTtcbiAgfVxuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L3V0aWxzL2NyZWF0ZS1yb3V0ZXMtZnJvbS1jaGlsZHJlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgbGV0IHJvdXRlczogUm91dGVPYmplY3RbXSA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHBhcmVudFBhdGgpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7XG4gICAgICAgIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZVxuICAgICAgfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIlxuICAgICk7XG5cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGxldCByb3V0ZTogUm91dGVPYmplY3QgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgbG9hZGVyOiBlbGVtZW50LnByb3BzLmxvYWRlcixcbiAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIGhhbmRsZTogZWxlbWVudC5wcm9wcy5oYW5kbGUsXG4gICAgfTtcblxuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgdHJlZVBhdGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBXYWxrIHRoZSByb3V0ZSB0cmVlIGFuZCBhZGQgaGFzRXJyb3JCb3VuZGFyeSBpZiBpdCdzIG5vdCBwcm92aWRlZCwgc28gdGhhdFxuICogdXNlcnMgcHJvdmlkaW5nIG1hbnVhbCByb3V0ZSBhcnJheXMgY2FuIGp1c3Qgc3BlY2lmeSBlcnJvckVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXVxuKTogUm91dGVPYmplY3RbXSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSkgPT4ge1xuICAgIGxldCByb3V0ZUNsb25lID0geyAuLi5yb3V0ZSB9O1xuICAgIGlmIChyb3V0ZUNsb25lLmhhc0Vycm9yQm91bmRhcnkgPT0gbnVsbCkge1xuICAgICAgcm91dGVDbG9uZS5oYXNFcnJvckJvdW5kYXJ5ID0gcm91dGVDbG9uZS5lcnJvckVsZW1lbnQgIT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJvdXRlQ2xvbmUuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlQ2xvbmUuY2hpbGRyZW4gPSBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzKHJvdXRlQ2xvbmUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVDbG9uZTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEZldGNoZXIsXG4gIEh5ZHJhdGlvblN0YXRlLFxuICBKc29uRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBOYXZpZ2F0aW9uLFxuICBQYXJhbXMsXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhdHRlcm4sXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBUbyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGRlZmVyLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZXNvbHZlUGF0aCxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgQXdhaXRQcm9wcyxcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlUHJvcHMsXG4gIE91dGxldFByb3BzLFxuICBSb3V0ZVByb3BzLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQge1xuICBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIHJlbmRlck1hdGNoZXMsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIE5hdmlnYXRvcixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbn0gZnJvbSBcIi4vbGliL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBEYXRhU3RhdGljUm91dGVyQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxufSBmcm9tIFwiLi9saWIvY29udGV4dFwiO1xuaW1wb3J0IHR5cGUgeyBOYXZpZ2F0ZUZ1bmN0aW9uIH0gZnJvbSBcIi4vbGliL2hvb2tzXCI7XG5pbXBvcnQge1xuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG59IGZyb20gXCIuL2xpYi9ob29rc1wiO1xuXG4vLyBFeHBvcnRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJ1dCBub3QgYmVpbmcgdXNlZCBpbnRlcm5hbGx5IGFueW1vcmVcbnR5cGUgSGFzaCA9IHN0cmluZztcbnR5cGUgUGF0aG5hbWUgPSBzdHJpbmc7XG50eXBlIFNlYXJjaCA9IHN0cmluZztcblxuLy8gRXhwb3NlIHJlYWN0LXJvdXRlciBwdWJsaWMgQVBJXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEZldGNoZXIsXG4gIEhhc2gsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIEluZGV4Um91dGVQcm9wcyxcbiAgSnNvbkZ1bmN0aW9uLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdGlvbixcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhuYW1lLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFNlYXJjaCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBUbyxcbn07XG5leHBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQXdhaXQsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgZGVmZXIsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGpzb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIG9wdHM/OiB7XG4gICAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gICAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICAgIGluaXRpYWxFbnRyaWVzPzogc3RyaW5nW107XG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB9XG4pOiBSZW1peFJvdXRlciB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzPy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cz8uaW5pdGlhbEluZGV4LFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEsXG4gICAgcm91dGVzOiBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzKHJvdXRlcyksXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIERhdGFTdGF0aWNSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhU3RhdGljUm91dGVyQ29udGV4dCxcbiAgZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyBhcyBVTlNBRkVfZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyxcbn07XG4iXSwibmFtZXMiOlsiaXNQb2x5ZmlsbCIsIngiLCJ5IiwiaXMiLCJPYmplY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJSZWFjdCIsImRpZFdhcm5PbGQxOEFscGhhIiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJjb25zb2xlIiwiZXJyb3IiLCJ2YWx1ZSIsImNhY2hlZFZhbHVlIiwiaW5zdCIsImZvcmNlVXBkYXRlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlckVudmlyb25tZW50Iiwic2hpbSIsInNlcnZlciIsImNsaWVudCIsIm1vZHVsZSIsIkRhdGFTdGF0aWNSb3V0ZXJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwiRGF0YVJvdXRlckNvbnRleHQiLCJEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiQXdhaXRDb250ZXh0IiwiTmF2aWdhdGlvbkNvbnRleHQiLCJMb2NhdGlvbkNvbnRleHQiLCJSb3V0ZUNvbnRleHQiLCJvdXRsZXQiLCJtYXRjaGVzIiwiUm91dGVFcnJvckNvbnRleHQiLCJ1c2VIcmVmIiwidG8iLCJyZWxhdGl2ZSIsInVzZUluUm91dGVyQ29udGV4dCIsImludmFyaWFudCIsImJhc2VuYW1lIiwibmF2aWdhdG9yIiwidXNlQ29udGV4dCIsImhhc2giLCJwYXRobmFtZSIsInNlYXJjaCIsInVzZVJlc29sdmVkUGF0aCIsImpvaW5lZFBhdGhuYW1lIiwiam9pblBhdGhzIiwiY3JlYXRlSHJlZiIsInVzZUxvY2F0aW9uIiwibG9jYXRpb24iLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsIm5hdmlnYXRpb25UeXBlIiwidXNlTWF0Y2giLCJwYXR0ZXJuIiwidXNlTWVtbyIsIm1hdGNoUGF0aCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwiZmlsdGVyIiwibWF0Y2giLCJpbmRleCIsInJvdXRlIiwicGF0aG5hbWVCYXNlIiwidXNlTmF2aWdhdGUiLCJsb2NhdGlvblBhdGhuYW1lIiwicm91dGVQYXRobmFtZXNKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsImFjdGl2ZVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJuYXZpZ2F0ZSIsInVzZUNhbGxiYWNrIiwib3B0aW9ucyIsIndhcm5pbmciLCJnbyIsInBhdGgiLCJyZXNvbHZlVG8iLCJwYXJzZSIsInJlcGxhY2UiLCJwdXNoIiwic3RhdGUiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsImNvbnRleHQiLCJ1c2VQYXJhbXMiLCJyb3V0ZU1hdGNoIiwibGVuZ3RoIiwicGFyYW1zIiwidXNlUm91dGVzIiwicm91dGVzIiwibG9jYXRpb25BcmciLCJkYXRhUm91dGVyU3RhdGVDb250ZXh0IiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJwYXJlbnRQYXRoIiwid2FybmluZ09uY2UiLCJlbmRzV2l0aCIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJwYXJzZWRMb2NhdGlvbkFyZyIsInBhcnNlUGF0aCIsInN0YXJ0c1dpdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInNsaWNlIiwibWF0Y2hSb3V0ZXMiLCJlbGVtZW50IiwidW5kZWZpbmVkIiwicmVuZGVyZWRNYXRjaGVzIiwiX3JlbmRlck1hdGNoZXMiLCJhc3NpZ24iLCJrZXkiLCJOYXZpZ2F0aW9uVHlwZSIsIlBvcCIsIkRlZmF1bHRFcnJvckVsZW1lbnQiLCJ1c2VSb3V0ZUVycm9yIiwibWVzc2FnZSIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwic3RhY2siLCJsaWdodGdyZXkiLCJwcmVTdHlsZXMiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiY29kZVN0eWxlcyIsImZvbnRTdHlsZSIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJjb21wb25lbnQiLCJjaGlsZHJlbiIsIlJlbmRlcmVkUm91dGUiLCJyb3V0ZUNvbnRleHQiLCJkYXRhU3RhdGljUm91dGVyQ29udGV4dCIsImVycm9yRWxlbWVudCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaWQiLCJkYXRhUm91dGVyU3RhdGUiLCJlcnJvcnMiLCJlcnJvckluZGV4IiwiZmluZEluZGV4IiwibSIsIk1hdGgiLCJtaW4iLCJyZWR1Y2VSaWdodCIsImdldENoaWxkcmVuIiwiY29uY2F0IiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJ1c2VOYXZpZ2F0aW9uIiwiVXNlTmF2aWdhdGlvbiIsIm5hdmlnYXRpb24iLCJ1c2VSZXZhbGlkYXRvciIsImRhdGFSb3V0ZXJDb250ZXh0IiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwicmV2YWxpZGF0aW9uIiwidXNlTWF0Y2hlcyIsImxvYWRlckRhdGEiLCJVc2VNYXRjaGVzIiwiZGF0YSIsImhhbmRsZSIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwidGhpc1JvdXRlIiwidXNlUm91dGVMb2FkZXJEYXRhIiwicm91dGVJZCIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwidmFsdWVzIiwiYWN0aW9uRGF0YSIsIlVzZVJvdXRlRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwiX2RhdGEiLCJ1c2VBc3luY0Vycm9yIiwiX2Vycm9yIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJSb3V0ZXJQcm92aWRlciIsImZhbGxiYWNrRWxlbWVudCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbSIsIm4iLCJvcHRzIiwicHJldmVudFNjcm9sbFJlc2V0Iiwic3RhdGljIiwiaGlzdG9yeUFjdGlvbiIsImluaXRpYWxpemVkIiwiTWVtb3J5Um91dGVyIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJoaXN0b3J5UmVmIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsInY1Q29tcGF0IiwiaGlzdG9yeSIsInNldFN0YXRlIiwiYWN0aW9uIiwibGlzdGVuIiwiTmF2aWdhdGUiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIlJvdXRlciIsImJhc2VuYW1lUHJvcCIsImxvY2F0aW9uUHJvcCIsInN0YXRpY1Byb3AiLCJuYXZpZ2F0aW9uQ29udGV4dCIsInRyYWlsaW5nUGF0aG5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiUm91dGVzIiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJyZXNvbHZlIiwiQXdhaXRSZW5kZXJTdGF0dXMiLCJuZXZlclNldHRsZWRQcm9taXNlIiwiUHJvbWlzZSIsIkF3YWl0RXJyb3JCb3VuZGFyeSIsInByb21pc2UiLCJwZW5kaW5nIiwic3VjY2VzcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwicmVuZGVyRXJyb3IiLCJyZWplY3QiLCJjYXRjaCIsIl90cmFja2VkIiwidGhlbiIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiUmVzb2x2ZUF3YWl0IiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwiaXNWYWxpZEVsZW1lbnQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJhcHBseSIsIm5hbWUiLCJ0cmVlUGF0aCIsImpvaW4iLCJjYXNlU2Vuc2l0aXZlIiwibG9hZGVyIiwiaGFzRXJyb3JCb3VuZGFyeSIsInNob3VsZFJldmFsaWRhdGUiLCJyZW5kZXJNYXRjaGVzIiwiZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyIsInJvdXRlQ2xvbmUiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVSb3V0ZXIiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbGl6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/react-router/dist/index.js\n");

/***/ })

}]);