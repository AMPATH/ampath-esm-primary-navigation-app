/** @module @category API */ import { reportError } from "@openmrs/esm-error-handling";
import { createGlobalStore } from "@openmrs/esm-state";
import { isUndefined } from "lodash-es";
import { Observable } from "rxjs";
import { openmrsFetch, restBaseUrl, sessionEndpoint } from "./openmrs-fetch.js";
/** @internal */ export const sessionStore = createGlobalStore('session', {
    loaded: false,
    session: null
});
let lastFetchTimeMillis = 0;
function getCurrentUser(opts = {
    includeAuthStatus: true
}) {
    if (lastFetchTimeMillis < Date.now() - 1000 * 60 || !sessionStore.getState().loaded) {
        refetchCurrentUser();
    }
    return new Observable((subscriber)=>{
        const handler = (state)=>{
            if (state.loaded) {
                if (opts.includeAuthStatus) {
                    subscriber.next(state.session);
                } else {
                    subscriber.next(state.session?.user);
                }
            }
        };
        handler(sessionStore.getState());
        // The observable subscribe function should return an unsubscribe function,
        // which happens to be exactly what `subscribe` returns.
        return sessionStore.subscribe(handler);
    });
}
export { getCurrentUser };
export function getSessionStore() {
    if (lastFetchTimeMillis < Date.now() - 1000 * 60 || !sessionStore.getState().loaded) {
        refetchCurrentUser();
    }
    return sessionStore;
}
// NB locale is string only if this returns true
function isValidLocale(locale) {
    if (locale === undefined || typeof locale !== 'string') {
        return false;
    }
    try {
        new Intl.Locale(locale);
    } catch (e) {
        return false;
    }
    return true;
}
export function setUserLanguage(data) {
    let locale = data.locale ?? data.user?.userProperties?.defaultLocale;
    if (locale && locale.includes('_')) {
        locale = locale.replaceAll('_', '-');
    }
    if (isValidLocale(locale) && locale !== document.documentElement.getAttribute('lang')) {
        document.documentElement.setAttribute('lang', locale);
    }
}
sessionStore.subscribe((state)=>{
    if (state.loaded && state.session) {
        setUserLanguage(state.session);
    }
});
function userHasPrivilege(requiredPrivilege, user) {
    if (typeof requiredPrivilege === 'string') {
        return !isUndefined(user.privileges.find((p)=>requiredPrivilege === p.display));
    } else if (Array.isArray(requiredPrivilege)) {
        return requiredPrivilege.every((rp)=>!isUndefined(user.privileges.find((p)=>rp === p.display)));
    } else if (!isUndefined(requiredPrivilege)) {
        console.error(`Could not understand privileges "${requiredPrivilege}"`);
    }
    return true;
}
function isSuperUser(user) {
    return !isUndefined(user.roles.find((role)=>role.display === 'System Developer'));
}
/**
 * The `refetchCurrentUser` function causes a network request to redownload
 * the user. All subscribers to the current user will be notified of the
 * new users once the new version of the user object is downloaded.
 *
 * @returns The same observable as returned by [[getCurrentUser]].
 *
 * #### Example
 * ```js
 * import { refetchCurrentUser } from '@openmrs/esm-api'
 * refetchCurrentUser()
 * ```
 */ export function refetchCurrentUser(username, password) {
    lastFetchTimeMillis = Date.now();
    let headers = {};
    if (username && password) {
        headers['Authorization'] = `Basic ${window.btoa(`${username}:${password}`)}`;
    }
    return handleSessionResponse(openmrsFetch(sessionEndpoint, {
        headers
    }));
}
export function clearCurrentUser() {
    sessionStore.setState({
        loaded: true,
        session: {
            authenticated: false,
            sessionId: ''
        }
    });
}
export function userHasAccess(requiredPrivilege, user) {
    if (user === undefined) {
        // if the user hasn't been loaded, then return false iff there is a required privilege
        return !Boolean(requiredPrivilege);
    }
    if (!Boolean(requiredPrivilege)) {
        // if user exists but no requiredPrivilege is defined
        return true;
    }
    return userHasPrivilege(requiredPrivilege, user) || isSuperUser(user);
}
export function getLoggedInUser() {
    let user;
    let unsubscribe;
    return new Promise((res)=>{
        const handler = (state)=>{
            if (state.loaded && state.session.user) {
                user = state.session.user;
                res(state.session.user);
                if (unsubscribe) {
                    unsubscribe();
                }
            }
        };
        handler(sessionStore.getState());
        if (!user) {
            unsubscribe = sessionStore.subscribe(handler);
        }
    });
}
export function getSessionLocation() {
    return new Promise((res, rej)=>{
        const sub = getCurrentUser().subscribe((session)=>{
            res(session.sessionLocation);
        }, rej);
        sub.unsubscribe();
    });
}
export async function setSessionLocation(locationUuid, abortController) {
    return handleSessionResponse(openmrsFetch(sessionEndpoint, {
        method: 'POST',
        body: {
            sessionLocation: locationUuid
        },
        headers: {
            'Content-Type': 'application/json'
        },
        signal: abortController.signal
    }));
}
export async function setUserProperties(userUuid, userProperties, abortController) {
    if (!abortController) {
        abortController = new AbortController();
    }
    await openmrsFetch(`${restBaseUrl}/user/${userUuid}`, {
        method: 'POST',
        body: {
            userProperties
        },
        headers: {
            'Content-Type': 'application/json'
        },
        signal: abortController.signal
    });
    return refetchCurrentUser();
}
function handleSessionResponse(result) {
    return new Promise((resolve, reject)=>{
        result.then((res)=>{
            let nextState;
            if (typeof res?.data === 'object') {
                nextState = {
                    loaded: true,
                    session: res.data
                };
                sessionStore.setState(nextState);
                resolve(nextState);
            } else {
                nextState = {
                    loaded: false,
                    session: null
                };
                sessionStore.setState(nextState);
                reject(nextState);
            }
        }).catch((err)=>{
            reportError(`Failed to fetch new session information: ${err}`);
            const nextState = {
                loaded: false,
                session: null
            };
            sessionStore.setState(nextState);
            reject(nextState);
        });
    });
}
