import type { StoreApi } from 'zustand';
export type ActionFunction<T> = (state: T, ...args: any[]) => Partial<T>;
type ActionFunctionsRecord<T> = Record<string, ActionFunction<T>>;
export type Actions<T> = ((store: StoreApi<T>) => ActionFunctionsRecord<T>) | ActionFunctionsRecord<T>;
export type BoundActions<T, A extends Actions<T>> = A extends ActionFunctionsRecord<T> ? BindFunctionsIn<A> : A extends (store: StoreApi<T>) => ActionFunctionsRecord<T> ? BindFunctionsIn<ActionFunctionsRecord<T>> : never;
type Bind<F extends (...args: any[]) => any> = F extends (firstArg: any, ...restArgs: infer RestArgsType) => any ? (...args: RestArgsType) => void : never;
type BindFunctionsIn<R extends Record<string, (...args: any[]) => any>> = {
    [Prop in keyof R]: Bind<R[Prop]>;
};
declare function useStore<T>(store: StoreApi<T>): T;
declare function useStore<T, U>(store: StoreApi<T>, select: (state: T) => U): U;
declare function useStore<T, U, A extends Actions<T>>(store: StoreApi<T>, select: undefined, actions: A): T & BoundActions<T, A>;
declare function useStore<T, U, A extends Actions<T>>(store: StoreApi<T>, select: (state: T) => U, actions: A): U & BoundActions<T, A>;
/**
 *
 * @param store A zustand store
 * @param actions
 * @returns
 */
declare function useStoreWithActions<T, A extends Actions<T>>(store: StoreApi<T>, actions: A): T & BoundActions<T, A>;
/**
 * Whenever possible, use `useStore(yourStore)` instead. This function is for creating a
 * custom hook for a specific store.
 */
declare function createUseStore<T>(store: StoreApi<T>): {
    (): T;
    <A extends Actions<T>>(actions: A): T & BoundActions<T, A>;
    <A extends Actions<T>>(actions?: A): T & BoundActions<T, A>;
};
export { createUseStore, useStore, useStoreWithActions };
//# sourceMappingURL=useStore.d.ts.map