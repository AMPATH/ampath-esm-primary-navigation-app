"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkImportmapJson = checkImportmapJson;
exports.checkRoutesJson = checkRoutesJson;
exports.runProject = runProject;
exports.mergeImportmapAndRoutes = mergeImportmapAndRoutes;
exports.getImportmapAndRoutes = getImportmapAndRoutes;
exports.getImportMap = getImportMap;
exports.getRoutes = getRoutes;
exports.proxyImportmapAndRoutes = proxyImportmapAndRoutes;
const axios_1 = __importDefault(require("axios"));
const glob_1 = __importDefault(require("glob"));
const node_url_1 = require("node:url");
const node_path_1 = require("node:path");
const node_fs_1 = require("node:fs");
const child_process_1 = require("child_process");
const logger_1 = require("./logger");
const devserver_1 = require("./devserver");
const dependencies_1 = require("./dependencies");
const port_1 = require("./port");
async function readImportmap(path, backend, spaPath) {
    if (path.startsWith('http://') || path.startsWith('https://')) {
        return fetchRemoteImportmap(path);
    }
    else if (path === 'importmap.json') {
        if (backend && spaPath) {
            try {
                return await fetchRemoteImportmap(`${backend}${spaPath}importmap.json`);
            }
            catch (e) {
                (0, logger_1.logWarn)(`Could not read importmap from ${backend}${spaPath}importmap.json. Falling back to import map from https://dev3.openmrs.org/openmrs/spa/importmap.json: ${e}`);
            }
        }
        return fetchRemoteImportmap('https://dev3.openmrs.org/openmrs/spa/importmap.json');
    }
    return '{"imports":{}}';
}
async function readRoutes(path, backend, spaPath) {
    if (path.startsWith('http://') || path.startsWith('https://')) {
        return fetchRemoteRoutes(path);
    }
    else if (path === 'routes.registry.json') {
        if (backend && spaPath) {
            try {
                return await fetchRemoteRoutes(`${backend}${spaPath}routes.registry.json`);
            }
            catch (e) {
                (0, logger_1.logWarn)(`Could not read routes registry from ${backend}${spaPath}routes.registry.json. Falling back to routes registry from https://dev3.openmrs.org/openmrs/spa/routes.registry.json: ${e}`);
            }
        }
        return fetchRemoteRoutes('https://dev3.openmrs.org/openmrs/spa/routes.registry.json');
    }
    return '{}';
}
async function fetchRemoteImportmap(fetchUrl) {
    return await axios_1.default
        .get(fetchUrl)
        .then((res) => res.data)
        .then((m) => (typeof m === 'string' ? JSON.parse(m) : m))
        .then((m) => {
        if (typeof m === 'object' && 'imports' in m) {
            Object.keys(m.imports).forEach((key) => {
                const url = m.imports[key];
                if (typeof url === 'string') {
                    m.imports[key] = new node_url_1.URL(url, fetchUrl).href;
                }
            });
        }
        return m;
    })
        .then((m) => JSON.stringify(m));
}
async function fetchRemoteRoutes(fetchUrl) {
    return await axios_1.default
        .get(fetchUrl)
        .then((res) => res.data)
        .then((m) => (typeof m === 'string' ? JSON.parse(m) : m))
        .then((m) => JSON.stringify(m));
}
function checkImportmapJson(value) {
    try {
        const content = JSON.parse(value);
        return typeof content === 'object' && typeof content.imports === 'object';
    }
    catch {
        return false;
    }
}
function checkRoutesJson(value) {
    try {
        const content = JSON.parse(value);
        return (typeof content === 'object' &&
            Object.entries(content).every(([key, value]) => typeof key === 'string' && typeof value === 'object'));
    }
    catch {
        return false;
    }
}
async function matchAny(baseDir, patterns) {
    const matches = [];
    await Promise.all(patterns.map((pattern) => new Promise((resolve, reject) => {
        (0, glob_1.default)(pattern, {
            cwd: baseDir,
        }, (err, files) => {
            if (err) {
                reject(err);
            }
            else {
                matches.push(...files);
                resolve();
            }
        });
    })));
    return matches;
}
const defaultConfigPath = (0, node_path_1.resolve)(__dirname, '..', '..', 'default-webpack-config.js');
function runProjectDevServer(configPath, port, project, sourceDirectory, importMap, routes, useRspack = false) {
    const bundle = (0, dependencies_1.getMainBundle)(project);
    const host = `http://localhost:${port}`;
    (0, devserver_1.startDevServer)(configPath, port, sourceDirectory, useRspack);
    importMap[project.name] = `${host}/${bundle.name}`;
    routes[project.name] = (0, dependencies_1.getAppRoutes)(sourceDirectory, project);
}
async function runProject(basePort, sourceDirectoryPatterns, useRspack) {
    const baseDir = process.cwd();
    const sourceDirectories = await matchAny(baseDir, sourceDirectoryPatterns);
    const importMap = {};
    const routes = {};
    const watchedRoutesPaths = {};
    // Track the starting port, which is one more than the last used port
    let nextPortToCheck = basePort + 1;
    (0, logger_1.logInfo)('Loading dynamic import map and routes ...');
    for (const sourceDir of sourceDirectories) {
        const sourceDirectory = (0, node_path_1.resolve)(baseDir, sourceDir);
        const projectFile = (0, node_path_1.resolve)(sourceDirectory, 'package.json');
        const routesFile = (0, node_path_1.resolve)(sourceDirectory, 'src', 'routes.json');
        const configPath = (0, node_path_1.resolve)(sourceDirectory, 'webpack.config.js');
        const rspackConfigPath = (0, node_path_1.resolve)(sourceDirectory, 'rspack.config.js');
        const hasConfig = typeof useRspack !== 'undefined' ? !useRspack : (0, node_fs_1.existsSync)(configPath);
        const hasRspackConfig = typeof useRspack !== 'undefined' ? useRspack : (0, node_fs_1.existsSync)(rspackConfigPath);
        (0, logger_1.logInfo)(`Looking in directory "${sourceDirectory}" ...`);
        if (!(0, node_fs_1.existsSync)(projectFile)) {
            (0, logger_1.logFail)(`No "package.json" found in directory "${sourceDirectory}". Skipping ...`);
            continue;
        }
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const project = require(projectFile);
        const startup = project['openmrs:develop'];
        if ((0, node_fs_1.existsSync)(routesFile)) {
            watchedRoutesPaths[project.name] = routesFile;
        }
        if (typeof startup === 'object') {
            // detected specialized startup command
            const cp = (0, child_process_1.exec)(startup.command, {
                cwd: sourceDirectory,
            });
            cp.stdout?.pipe(process.stdout);
            cp.stderr?.pipe(process.stderr);
            // connect to either startup.url or a computed value based on startup.host
            importMap[project.name] = startup.url || `${startup.host}/${(0, node_path_1.basename)(project.browser)}`;
        }
        else if (!hasConfig && !hasRspackConfig) {
            // try to locate and run via default webpack
            (0, logger_1.logWarn)(`No "webpack.config.js" found in directory "${sourceDirectory}". Trying to use default config ...`);
            // Find next available port
            const port = await (0, port_1.getAvailablePort)(nextPortToCheck);
            nextPortToCheck = port + 1;
            runProjectDevServer(defaultConfigPath, port, project, sourceDirectory, importMap, routes);
        }
        else {
            // Find next available port
            const port = await (0, port_1.getAvailablePort)(nextPortToCheck);
            nextPortToCheck = port + 1;
            if (hasConfig) {
                // run via specialized webpack.config.js
                runProjectDevServer(configPath, port, project, sourceDirectory, importMap, routes);
            }
            else {
                runProjectDevServer(rspackConfigPath, port, project, sourceDirectory, importMap, routes, true);
            }
        }
    }
    (0, logger_1.logInfo)(`Assembled dynamic import map and routes for packages (${Object.keys(importMap).join(', ')}).`);
    return { importMap, routes, watchedRoutesPaths };
}
/**
 * @param importAndRoutes An ImportmapAndRoutes object that holds the current import map and routes registries
 * @param additionalImportsAndRoutes An object containing any import map entries, routes, and watched route files to add to the setup
 * @param backend The URL for the backend
 * @param spaPath The spaPath for this instance
 * @returns The import map declaration with the new imports added in. If
 *   there are new imports to add, and if the original import map declaration
 *   had type "url", it is downloaded and resolved to one of type "inline".
 */
async function mergeImportmapAndRoutes(importAndRoutes, additionalImportsAndRoutes, backend, spaPath) {
    const { importMap: importDecl, routes: routesDecl } = importAndRoutes;
    const { importMap: additionalImports, routes: additionalRoutes, watchedRoutesPaths = {}, } = additionalImportsAndRoutes || {};
    if (additionalImports && Object.keys(additionalImports).length > 0) {
        if (importDecl.type === 'url') {
            importDecl.type = 'inline';
            importDecl.value = await readImportmap(importDecl.value, backend, spaPath);
        }
        const map = JSON.parse(importDecl.value);
        importDecl.value = JSON.stringify({
            imports: {
                ...map.imports,
                ...additionalImports,
            },
        });
    }
    if (additionalRoutes && Object.keys(additionalRoutes).length > 0) {
        if (routesDecl.type === 'url') {
            routesDecl.type = 'inline';
            routesDecl.value = await readRoutes(routesDecl.value, backend, spaPath);
        }
        const routes = JSON.parse(routesDecl.value);
        routesDecl.value = JSON.stringify({
            ...routes,
            ...additionalRoutes,
        });
    }
    return { importMap: importDecl, routes: routesDecl, watchedRoutesPaths };
}
async function getImportmapAndRoutes(importMapPath, routesPath, basePort) {
    return Promise.all([getImportMap(importMapPath, basePort), getRoutes(routesPath)]).then(([importMap, routes]) => {
        return { importMap, routes };
    });
}
async function getImportMap(importMapPath, basePort) {
    if (importMapPath === '@' && basePort) {
        (0, logger_1.logWarn)('Using the "@" import map is deprecated. Switch to use the "--run-project" flag.');
        const imports = await runProject(basePort, ['.']);
        return {
            type: 'inline',
            value: JSON.stringify({
                imports,
            }),
        };
    }
    else if (!/https?:\/\//.test(importMapPath)) {
        const path = (0, node_path_1.resolve)(process.cwd(), importMapPath);
        if ((0, node_fs_1.existsSync)(path)) {
            const content = (0, node_fs_1.readFileSync)(path, 'utf8');
            const valid = checkImportmapJson(content);
            if (!valid) {
                (0, logger_1.logWarn)(`The import map provided in "${importMapPath}" does not seem right. Skipping.`);
            }
            return {
                type: 'inline',
                value: valid ? content : '',
            };
        }
        else if (checkImportmapJson(importMapPath)) {
            return {
                type: 'inline',
                value: importMapPath,
            };
        }
    }
    return {
        type: 'url',
        value: importMapPath,
    };
}
async function getRoutes(routesPath) {
    if (!/https?:\/\//.test(routesPath)) {
        const path = (0, node_path_1.resolve)(process.cwd(), routesPath);
        if ((0, node_fs_1.existsSync)(path)) {
            const content = (0, node_fs_1.readFileSync)(path, 'utf8');
            const valid = checkRoutesJson(content);
            if (!valid) {
                (0, logger_1.logWarn)(`The routes provided provided in "${routesPath}" does not seem right. Skipping.`);
            }
            return {
                type: 'inline',
                value: valid ? content : '',
            };
        }
        else if (checkRoutesJson(routesPath)) {
            return {
                type: 'inline',
                value: routesPath,
            };
        }
    }
    return {
        type: 'url',
        value: routesPath,
    };
}
/**
 * @param importmapAndRoutes An ImportmapAndRoutes object that holds the import map and routes registry
 * @param backend The URL for the backend
 * @param spaPath The spaPath for this instance
 * @returns The same import map declaration but with all imports changed to the appropriate path
 */
function proxyImportmapAndRoutes(importmapAndRoutes, backend, spaPath) {
    const { importMap: importMapDecl, routes: routesDecl, watchedRoutesPaths } = importmapAndRoutes;
    if (importMapDecl.type != 'inline') {
        throw new Error('proxyImportmapAndRoutes called on non-inline import map. This is a programming error. Value: ' +
            importMapDecl.value);
    }
    if (routesDecl.type != 'inline') {
        throw new Error('proxyImportmapAndRoutes called on non-inline routes. This is a programming error. Value: ' + routesDecl.value);
    }
    const backendUrl = new node_url_1.URL(backend);
    const importmap = JSON.parse(importMapDecl.value);
    const spaPathRegEx = new RegExp('^' + spaPath.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d'));
    Object.keys(importmap.imports).forEach((key) => {
        const url = new node_url_1.URL(importmap.imports[key], backendUrl);
        if (url.protocol === backendUrl.protocol && url.host === backendUrl.host) {
            importmap.imports[key] = `./${url.pathname.replace(spaPathRegEx, '')}${url.search}${url.hash}`;
        }
    });
    importMapDecl.value = JSON.stringify(importmap);
    return { importmap: importMapDecl, routes: routesDecl, watchedRoutesPaths };
}
