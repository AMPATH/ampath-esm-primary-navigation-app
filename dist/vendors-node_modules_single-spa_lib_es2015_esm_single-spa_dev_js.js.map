{"version":3,"file":"vendors-node_modules_single-spa_lib_es2015_esm_single-spa_dev_js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,8BAA8B,6BAA6B;AAC3D,8BAA8B,6BAA6B;AAC3D,0BAA0B,yBAAyB;AACnD,4BAA4B,2BAA2B;AACvD,2BAA2B,0BAA0B;AACrD,8BAA8B,6BAA6B;AAC3D,gCAAgC,+BAA+B;AAC/D,yBAAyB,wBAAwB;AACjD,uBAAuB,sBAAsB;AAC7C,4BAA4B,2BAA2B;AACvD,iCAAiC,gCAAgC;AACjE,sBAAsB,qBAAqB;AAC3C,2BAA2B,0BAA0B;AACrD,wBAAwB,uBAAuB;AAC/C,0BAA0B,yBAAyB;AACnD,2BAA2B,0BAA0B;AACrD,0BAA0B,yBAAyB;AACnD,6BAA6B,4BAA4B;AACzD,0BAA0B,yBAAyB;AACnD,qBAAqB,oBAAoB;AACzC,8BAA8B,6BAA6B;AAC3D,2BAA2B,0BAA0B;AACrD,wBAAwB,uBAAuB;AAC/C,sBAAsB,qBAAqB;AAC3C,mBAAmB,kBAAkB;AACrC,mBAAmB,kBAAkB;AACrC,qBAAqB,oBAAoB;AACzC,kBAAkB,iBAAiB;AACnC,oBAAoB,mBAAmB;AACvC,qBAAqB,oBAAoB;AACzC,8BAA8B;AAC9B,CAAC;;AAED,sHAAsH,UAAM,mBAAmB,UAAM;;AAErJ;;AAEA;AACA;AACA,2CAA2C,UAAU,cAAc;AACnE;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,yCAAyC,KAAK,IAAI,qBAAqB,4CAA4C,KAAK,EAAE,sBAAsB,mBAAmB,OAAO;AAC1K;AACA;AACA,uBAAuB,yBAAyB,GAAG,oBAAoB,mBAAmB,mBAAmB;AAC7G;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,iDAAiD,mBAAmB,KAAK,oBAAoB;;AAE7F;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,MAAM,EAAE,KAAK,2BAA2B,WAAW,iBAAiB,OAAO;AAC1L,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sCAAsC;AAChD;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,oBAAoB;AACtF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA,8FAA8F,mBAAmB;AACjH;;AAEA;AACA,sCAAsC,GAAG;;AAEzC;AACA,gDAAgD,MAAM,6DAA6D,mBAAmB;AACtI;;AAEA;AACA,gDAAgD,MAAM;AACtD;;AAEA;AACA,sGAAsG;;AAEtG;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,KAAK,kBAAkB,eAAe;AAC5G;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA,KAAK;;AAEL,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,GAAG;;AAEvC;AACA;AACA,kDAAkD,MAAM;AACxD;;AAEA;AACA,mDAAmD,MAAM;AACzD;;AAEA;AACA,mDAAmD,MAAM;AACzD;;AAEA;AACA,mDAAmD,MAAM;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,qEAAqE,KAAK,kBAAkB,eAAe;AAC3G,UAAU;;;AAGV;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,KAAK,0DAA0D,YAAY;AAClI;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,gEAAgE,WAAW,MAAM,MAAM,EAAE,qBAAqB,0CAA0C,sBAAsB;;AAE9K;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,mCAAmC;AACnC;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,2BAA2B,2DAA2D;AACtF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sJAAsJ,oBAAoB;AAC1K;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;;AAEZ,qGAAqG,MAAM,GAAG,oBAAoB;AAClI;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,sDAAsD;;AAEtD;AACA,mDAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,0IAA0I,kBAAkB;AAC5J;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,QAAQ;AACjF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA,wEAAwE,QAAQ;AAChF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6GAA6G,qBAAqB,kBAAkB,uBAAuB;AAC3K;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB,IAAI,cAAc;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,yBAAyB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,0DAA0D,SAAS,EAAE,OAAO,QAAQ,SAAS,IAAI,OAAO;AACxG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,6HAA6H,IAAI;AACjI,yBAAyB;;AAEzB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,kHAAkH;;AAElH,sCAAsC;;AAEtC;;AAEA;AACA;AACA,YAAY;;;AAGZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEkiB;AACliB","sources":["webpack://@openmrs/esm-primary-navigation-app/./node_modules/single-spa/lib/es2015/esm/single-spa.dev.js"],"sourcesContent":["/* single-spa@6.0.3 - ES2015 - dev */\nvar singleSpa = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tget start () { return start; },\n\tget ensureJQuerySupport () { return ensureJQuerySupport; },\n\tget setBootstrapMaxTime () { return setBootstrapMaxTime; },\n\tget setMountMaxTime () { return setMountMaxTime; },\n\tget setUnmountMaxTime () { return setUnmountMaxTime; },\n\tget setUnloadMaxTime () { return setUnloadMaxTime; },\n\tget registerApplication () { return registerApplication; },\n\tget unregisterApplication () { return unregisterApplication; },\n\tget getMountedApps () { return getMountedApps; },\n\tget getAppStatus () { return getAppStatus; },\n\tget unloadApplication () { return unloadApplication; },\n\tget checkActivityFunctions () { return checkActivityFunctions; },\n\tget getAppNames () { return getAppNames; },\n\tget pathToActiveWhen () { return pathToActiveWhen; },\n\tget navigateToUrl () { return navigateToUrl; },\n\tget patchHistoryApi () { return patchHistoryApi; },\n\tget triggerAppChange () { return triggerAppChange; },\n\tget addErrorHandler () { return addErrorHandler; },\n\tget removeErrorHandler () { return removeErrorHandler; },\n\tget mountRootParcel () { return mountRootParcel; },\n\tget NOT_LOADED () { return NOT_LOADED; },\n\tget LOADING_SOURCE_CODE () { return LOADING_SOURCE_CODE; },\n\tget NOT_BOOTSTRAPPED () { return NOT_BOOTSTRAPPED; },\n\tget BOOTSTRAPPING () { return BOOTSTRAPPING; },\n\tget NOT_MOUNTED () { return NOT_MOUNTED; },\n\tget MOUNTING () { return MOUNTING; },\n\tget UPDATING () { return UPDATING; },\n\tget LOAD_ERROR () { return LOAD_ERROR; },\n\tget MOUNTED () { return MOUNTED; },\n\tget UNLOADING () { return UNLOADING; },\n\tget UNMOUNTING () { return UNMOUNTING; },\n\tget SKIP_BECAUSE_BROKEN () { return SKIP_BECAUSE_BROKEN; }\n});\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar NativeCustomEvent = commonjsGlobal.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nvar customEvent = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n};\n\nlet errorHandlers = [];\nfunction handleAppError(err, app, newStatus) {\n  const transformedErr = transformErr(err, app, newStatus);\n\n  if (errorHandlers.length) {\n    errorHandlers.forEach(handler => handler(transformedErr));\n  } else {\n    setTimeout(() => {\n      throw transformedErr;\n    });\n  }\n}\nfunction addErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(formatErrorMessage(28, \"a single-spa error handler must be a function\"));\n  }\n\n  errorHandlers.push(handler);\n}\nfunction removeErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(formatErrorMessage(29, \"a single-spa error handler must be a function\"));\n  }\n\n  let removedSomething = false;\n  errorHandlers = errorHandlers.filter(h => {\n    const isHandler = h === handler;\n    removedSomething = removedSomething || isHandler;\n    return !isHandler;\n  });\n  return removedSomething;\n}\nfunction formatErrorMessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${msg ? msg + \" \" : \"\"}See https://single-spa.js.org/error/?code=${code}${args.length ? `&arg=${args.join(\"&arg=\")}` : \"\"}`;\n}\nfunction transformErr(ogErr, appOrParcel, newStatus) {\n  const errPrefix = `${objectType(appOrParcel)} '${toName(appOrParcel)}' died in status ${appOrParcel.status}: `;\n  let result;\n\n  if (ogErr instanceof Error) {\n    try {\n      ogErr.message = errPrefix + ogErr.message;\n    } catch (err) {\n      /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */\n    }\n\n    result = ogErr;\n  } else {\n    console.warn(formatErrorMessage(30, `While ${appOrParcel.status}, '${toName(appOrParcel)}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`, appOrParcel.status, toName(appOrParcel)));\n\n    try {\n      result = Error(errPrefix + JSON.stringify(ogErr));\n    } catch (err) {\n      // If it's not an Error and you can't stringify it, then what else can you even do to it?\n      result = ogErr;\n    }\n  }\n\n  result.appOrParcelName = toName(appOrParcel); // We set the status after transforming the error so that the error message\n  // references the state the application was in before the status change.\n\n  appOrParcel.status = newStatus;\n  return result;\n}\n\nconst NOT_LOADED = \"NOT_LOADED\";\nconst LOADING_SOURCE_CODE = \"LOADING_SOURCE_CODE\";\nconst NOT_BOOTSTRAPPED = \"NOT_BOOTSTRAPPED\";\nconst BOOTSTRAPPING = \"BOOTSTRAPPING\";\nconst NOT_MOUNTED = \"NOT_MOUNTED\";\nconst MOUNTING = \"MOUNTING\";\nconst MOUNTED = \"MOUNTED\";\nconst UPDATING = \"UPDATING\";\nconst UNMOUNTING = \"UNMOUNTING\";\nconst UNLOADING = \"UNLOADING\";\nconst LOAD_ERROR = \"LOAD_ERROR\";\nconst SKIP_BECAUSE_BROKEN = \"SKIP_BECAUSE_BROKEN\";\nfunction isActive(app) {\n  return app.status === MOUNTED;\n}\nfunction shouldBeActive(app) {\n  try {\n    return app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n    return false;\n  }\n}\nfunction toName(app) {\n  return app.name;\n}\nfunction isParcel(appOrParcel) {\n  return Boolean(appOrParcel.unmountThisParcel);\n}\nfunction objectType(appOrParcel) {\n  return isParcel(appOrParcel) ? \"parcel\" : \"application\";\n}\n\n// Object.assign() is not available in IE11. And the babel compiled output for object spread\n// syntax checks a bunch of Symbol stuff and is almost a kb. So this function is the smaller replacement.\nfunction assign() {\n  for (let i = arguments.length - 1; i > 0; i--) {\n    for (let key in arguments[i]) {\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      arguments[i - 1][key] = arguments[i][key];\n    }\n  }\n\n  return arguments[0];\n}\n\n/* the array.prototype.find polyfill on npmjs.com is ~20kb (not worth it)\n * and lodash is ~200kb (not worth it)\n */\nfunction find(arr, func) {\n  for (let i = 0; i < arr.length; i++) {\n    if (func(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nfunction validLifecycleFn(fn) {\n  return fn && (typeof fn === \"function\" || isArrayOfFns(fn));\n\n  function isArrayOfFns(arr) {\n    return Array.isArray(arr) && !find(arr, item => typeof item !== \"function\");\n  }\n}\nfunction flattenFnArray(appOrParcel, lifecycle) {\n  let fns = appOrParcel[lifecycle] || [];\n  fns = Array.isArray(fns) ? fns : [fns];\n\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  const type = objectType(appOrParcel);\n  const name = toName(appOrParcel);\n  return function (props) {\n    return fns.reduce((resultPromise, fn, index) => {\n      return resultPromise.then(() => {\n        const thisPromise = fn(props);\n        return smellsLikeAPromise(thisPromise) ? thisPromise : Promise.reject(formatErrorMessage(15, `Within ${type} ${name}, the lifecycle function ${lifecycle} at array index ${index} did not return a promise`, type, name, lifecycle, index));\n      });\n    }, Promise.resolve());\n  };\n}\nfunction smellsLikeAPromise(promise) {\n  return promise && typeof promise.then === \"function\" && typeof promise.catch === \"function\";\n}\n\nlet profileEntries = [];\nfunction getProfilerData() {\n  return profileEntries;\n}\n/**\n *\n * @type {'application' | 'parcel' | 'routing'} ProfileType\n *\n * @param {ProfileType} type\n * @param {String} name\n * @param {number} start\n * @param {number} end\n */\n\nfunction addProfileEntry(type, name, kind, start, end, operationSucceeded) {\n  profileEntries.push({\n    type,\n    name,\n    start,\n    end,\n    kind,\n    operationSucceeded\n  });\n}\n\nfunction toBootstrapPromise(appOrParcel, hardFail) {\n  let startTime, profileEventType;\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n\n    {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    appOrParcel.status = BOOTSTRAPPING;\n\n    if (!appOrParcel.bootstrap) {\n      // Default implementation of bootstrap\n      return Promise.resolve().then(successfulBootstrap);\n    }\n\n    return reasonableTime(appOrParcel, \"bootstrap\").then(successfulBootstrap).catch(err => {\n      {\n        addProfileEntry(profileEventType, toName(appOrParcel), \"bootstrap\", startTime, performance.now(), false);\n      }\n\n      if (hardFail) {\n        throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n      } else {\n        handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        return appOrParcel;\n      }\n    });\n  });\n\n  function successfulBootstrap() {\n    appOrParcel.status = NOT_MOUNTED;\n\n    {\n      addProfileEntry(profileEventType, toName(appOrParcel), \"bootstrap\", startTime, performance.now(), true);\n    }\n\n    return appOrParcel;\n  }\n}\n\nfunction toUnmountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime, profileEventType;\n\n    {\n      startTime = performance.now();\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n    }\n\n    appOrParcel.status = UNMOUNTING;\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(parcelId => appOrParcel.parcels[parcelId].unmountThisParcel());\n    return Promise.all(unmountChildrenParcels).then(unmountAppOrParcel, parcelError => {\n      // There is a parcel unmount error\n      return unmountAppOrParcel().then(() => {\n        // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n        const parentError = Error(parcelError.message);\n\n        if (hardFail) {\n          throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n        } else {\n          handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n        }\n      });\n    }).then(() => appOrParcel);\n\n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel, \"unmount\").then(() => {\n        // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n        {\n          appOrParcel.status = NOT_MOUNTED;\n        }\n\n        {\n          addProfileEntry(profileEventType, toName(appOrParcel), \"unmount\", startTime, performance.now(), true);\n        }\n      }, err => {\n        {\n          addProfileEntry(profileEventType, toName(appOrParcel), \"unmount\", startTime, performance.now(), false);\n        }\n\n        if (hardFail) {\n          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        } else {\n          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        }\n      });\n    }\n  });\n}\n\nlet beforeFirstMountFired = false;\nlet firstMountFired = false;\nfunction toMountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime, profileEventType;\n\n    {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new customEvent(\"single-spa:before-first-mount\"));\n      beforeFirstMountFired = true;\n    }\n\n    appOrParcel.status = MOUNTING;\n    return reasonableTime(appOrParcel, \"mount\").then(() => {\n      appOrParcel.status = MOUNTED;\n\n      if (!firstMountFired) {\n        window.dispatchEvent(new customEvent(\"single-spa:first-mount\"));\n        firstMountFired = true;\n      }\n\n      {\n        addProfileEntry(profileEventType, toName(appOrParcel), \"mount\", startTime, performance.now(), true);\n      }\n\n      return appOrParcel;\n    }).catch(err => {\n      // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n      // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n      // instead of just doing a no-op.\n      appOrParcel.status = MOUNTED;\n      return toUnmountPromise(appOrParcel, true).then(setSkipBecauseBroken, setSkipBecauseBroken);\n\n      function setSkipBecauseBroken() {\n        {\n          addProfileEntry(profileEventType, toName(appOrParcel), \"mount\", startTime, performance.now(), false);\n        }\n\n        if (!hardFail) {\n          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          return appOrParcel;\n        } else {\n          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        }\n      }\n    });\n  });\n}\n\nfunction toUpdatePromise(appOrParcel) {\n  return Promise.resolve().then(() => {\n    let startTime, profileEventType;\n\n    {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (appOrParcel.status !== MOUNTED) {\n      throw Error(formatErrorMessage(32, `Cannot update parcel '${toName(appOrParcel)}' because it is not mounted`, toName(appOrParcel)));\n    }\n\n    appOrParcel.status = UPDATING;\n    return reasonableTime(appOrParcel, \"update\").then(() => {\n      appOrParcel.status = MOUNTED;\n\n      {\n        addProfileEntry(profileEventType, toName(appOrParcel), \"update\", startTime, performance.now(), true);\n      }\n\n      return appOrParcel;\n    }).catch(err => {\n      {\n        addProfileEntry(profileEventType, toName(appOrParcel), \"update\", startTime, performance.now(), false);\n      }\n\n      throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n    });\n  });\n}\n\nlet parcelCount = 0;\nconst rootParcels = {\n  parcels: {}\n}; // This is a public api, exported to users of single-spa\n\nfunction mountRootParcel() {\n  return mountParcel.apply(rootParcels, arguments);\n}\nfunction mountParcel(config, customProps) {\n  const owningAppOrParcel = this; // Validate inputs\n\n  if (!config || typeof config !== \"object\" && typeof config !== \"function\") {\n    throw Error(formatErrorMessage(2, \"Cannot mount parcel without a config object or config loading function\"));\n  }\n\n  if (config.name && typeof config.name !== \"string\") {\n    throw Error(formatErrorMessage(3, `Parcel name must be a string, if provided. Was given ${typeof config.name}`, typeof config.name));\n  }\n\n  const id = parcelCount++;\n  let name = config.name || `parcel-${id}`;\n\n  if (typeof customProps !== \"object\") {\n    throw Error(formatErrorMessage(4, `Parcel ${name} has invalid customProps -- must be an object but was given ${typeof customProps}`, name, typeof customProps));\n  }\n\n  if (!customProps.domElement) {\n    throw Error(formatErrorMessage(5, `Parcel ${name} cannot be mounted without a domElement provided as a prop`, name));\n  }\n\n  const passedConfigLoadingFunction = typeof config === \"function\";\n  const configLoadingFunction = passedConfigLoadingFunction ? config : () => Promise.resolve(config); // Internal representation\n\n  const parcel = {\n    id,\n    parcels: {},\n    status: passedConfigLoadingFunction ? LOADING_SOURCE_CODE : NOT_BOOTSTRAPPED,\n    customProps,\n    parentName: toName(owningAppOrParcel),\n\n    unmountThisParcel() {\n      return mountPromise.then(() => {\n        if (parcel.status !== MOUNTED) {\n          throw Error(formatErrorMessage(6, `Cannot unmount parcel '${name}' -- it is in a ${parcel.status} status`, name, parcel.status));\n        }\n\n        return toUnmountPromise(parcel, true);\n      }).then(value => {\n        if (parcel.parentName) {\n          delete owningAppOrParcel.parcels[parcel.id];\n        }\n\n        return value;\n      }).then(value => {\n        resolveUnmount(value);\n        return value;\n      }).catch(err => {\n        parcel.status = SKIP_BECAUSE_BROKEN;\n        rejectUnmount(err);\n        throw err;\n      });\n    }\n\n  }; // We return an external representation\n\n  let externalRepresentation; // Add to owning app or parcel\n\n  owningAppOrParcel.parcels[id] = parcel;\n  let loadPromise = configLoadingFunction();\n\n  if (!loadPromise || typeof loadPromise.then !== \"function\") {\n    throw Error(formatErrorMessage(7, `When mounting a parcel, the config loading function must return a promise that resolves with the parcel config`));\n  }\n\n  loadPromise = loadPromise.then(config => {\n    if (!config) {\n      throw Error(formatErrorMessage(8, `When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config`));\n    }\n\n    name = config.name || `parcel-${id}`;\n\n    if ( // ES Module objects don't have the object prototype\n    Object.prototype.hasOwnProperty.call(config, \"bootstrap\") && !validLifecycleFn(config.bootstrap)) {\n      throw Error(formatErrorMessage(9, `Parcel ${name} provided an invalid bootstrap function`, name));\n    }\n\n    if (!validLifecycleFn(config.mount)) {\n      throw Error(formatErrorMessage(10, `Parcel ${name} must have a valid mount function`, name));\n    }\n\n    if (!validLifecycleFn(config.unmount)) {\n      throw Error(formatErrorMessage(11, `Parcel ${name} must have a valid unmount function`, name));\n    }\n\n    if (config.update && !validLifecycleFn(config.update)) {\n      throw Error(formatErrorMessage(12, `Parcel ${name} provided an invalid update function`, name));\n    }\n\n    const bootstrap = flattenFnArray(config, \"bootstrap\");\n    const mount = flattenFnArray(config, \"mount\");\n    const unmount = flattenFnArray(config, \"unmount\");\n    parcel.status = NOT_BOOTSTRAPPED;\n    parcel.name = name;\n    parcel.bootstrap = bootstrap;\n    parcel.mount = mount;\n    parcel.unmount = unmount;\n    parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n\n    if (config.update) {\n      parcel.update = flattenFnArray(config, \"update\");\n\n      externalRepresentation.update = function (customProps) {\n        parcel.customProps = customProps;\n        return promiseWithoutReturnValue(toUpdatePromise(parcel));\n      };\n    }\n  }); // Start bootstrapping and mounting\n  // The .then() causes the work to be put on the event loop instead of happening immediately\n\n  const bootstrapPromise = loadPromise.then(() => toBootstrapPromise(parcel, true));\n  const mountPromise = bootstrapPromise.then(() => toMountPromise(parcel, true));\n  let resolveUnmount, rejectUnmount;\n  const unmountPromise = new Promise((resolve, reject) => {\n    resolveUnmount = resolve;\n    rejectUnmount = reject;\n  });\n  externalRepresentation = {\n    mount() {\n      return promiseWithoutReturnValue(Promise.resolve().then(() => {\n        if (parcel.status !== NOT_MOUNTED) {\n          throw Error(formatErrorMessage(13, `Cannot mount parcel '${name}' -- it is in a ${parcel.status} status`, name, parcel.status));\n        } // Add to owning app or parcel\n\n\n        owningAppOrParcel.parcels[id] = parcel;\n        return toMountPromise(parcel);\n      }));\n    },\n\n    unmount() {\n      return promiseWithoutReturnValue(parcel.unmountThisParcel());\n    },\n\n    getStatus() {\n      return parcel.status;\n    },\n\n    loadPromise: promiseWithoutReturnValue(loadPromise),\n    bootstrapPromise: promiseWithoutReturnValue(bootstrapPromise),\n    mountPromise: promiseWithoutReturnValue(mountPromise),\n    unmountPromise: promiseWithoutReturnValue(unmountPromise)\n  };\n  return externalRepresentation;\n}\n\nfunction promiseWithoutReturnValue(promise) {\n  return promise.then(() => null);\n}\n\nfunction getProps(appOrParcel) {\n  const name = toName(appOrParcel);\n  let customProps = typeof appOrParcel.customProps === \"function\" ? appOrParcel.customProps(name, window.location) : appOrParcel.customProps;\n\n  if (typeof customProps !== \"object\" || customProps === null || Array.isArray(customProps)) {\n    customProps = {};\n    console.warn(formatErrorMessage(40, `single-spa: ${name}'s customProps function must return an object. Received ${customProps}`), name, customProps);\n  }\n\n  const result = assign({}, customProps, {\n    name,\n    mountParcel: mountParcel.bind(appOrParcel),\n    singleSpa\n  });\n\n  if (isParcel(appOrParcel)) {\n    result.unmountSelf = appOrParcel.unmountThisParcel;\n  }\n\n  return result;\n}\n\nconst defaultWarningMillis = 1000;\nconst globalTimeoutConfig = {\n  bootstrap: {\n    millis: 4000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis\n  },\n  update: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis\n  }\n};\nfunction setBootstrapMaxTime(time, dieOnTimeout, warningMillis) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(formatErrorMessage(16, `bootstrap max time must be a positive integer number of milliseconds`));\n  }\n\n  globalTimeoutConfig.bootstrap = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis\n  };\n}\nfunction setMountMaxTime(time, dieOnTimeout, warningMillis) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(formatErrorMessage(17, `mount max time must be a positive integer number of milliseconds`));\n  }\n\n  globalTimeoutConfig.mount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis\n  };\n}\nfunction setUnmountMaxTime(time, dieOnTimeout, warningMillis) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(formatErrorMessage(18, `unmount max time must be a positive integer number of milliseconds`));\n  }\n\n  globalTimeoutConfig.unmount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis\n  };\n}\nfunction setUnloadMaxTime(time, dieOnTimeout, warningMillis) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(formatErrorMessage(19, `unload max time must be a positive integer number of milliseconds`));\n  }\n\n  globalTimeoutConfig.unload = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis\n  };\n}\nfunction reasonableTime(appOrParcel, lifecycle) {\n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  const warningPeriod = timeoutConfig.warningMillis;\n  const type = objectType(appOrParcel);\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n    appOrParcel[lifecycle](getProps(appOrParcel)).then(val => {\n      finished = true;\n      resolve(val);\n    }).catch(val => {\n      finished = true;\n      reject(val);\n    });\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n    const errMsg = formatErrorMessage(31, `Lifecycle function ${lifecycle} for ${type} ${toName(appOrParcel)} lifecycle did not resolve or reject for ${timeoutConfig.millis} ms.`, lifecycle, type, toName(appOrParcel), timeoutConfig.millis);\n\n    function maybeTimingOut(shouldError) {\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n\n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            console.error(errMsg); //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\nfunction ensureValidAppTimeouts(timeouts) {\n  const result = {};\n\n  for (let key in globalTimeoutConfig) {\n    result[key] = assign({}, globalTimeoutConfig[key], timeouts && timeouts[key] || {});\n  }\n\n  return result;\n}\n\nfunction toLoadPromise(appOrParcel) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.loadPromise) {\n      return appOrParcel.loadPromise;\n    }\n\n    if (appOrParcel.status !== NOT_LOADED && appOrParcel.status !== LOAD_ERROR) {\n      return appOrParcel;\n    }\n\n    let startTime;\n\n    {\n      startTime = performance.now();\n    }\n\n    appOrParcel.status = LOADING_SOURCE_CODE;\n    let appOpts, isUserErr;\n    return appOrParcel.loadPromise = Promise.resolve().then(() => {\n      const loadPromise = appOrParcel.loadApp(getProps(appOrParcel));\n\n      if (!smellsLikeAPromise(loadPromise)) {\n        // The name of the app will be prepended to this error message inside of the handleAppError function\n        isUserErr = true;\n        throw Error(formatErrorMessage(33, `single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(appOrParcel)}', loadingFunction, activityFunction)`, toName(appOrParcel)));\n      }\n\n      return loadPromise.then(val => {\n        appOrParcel.loadErrorTime = null;\n        appOpts = val;\n        let validationErrMessage, validationErrCode;\n\n        if (typeof appOpts !== \"object\") {\n          validationErrCode = 34;\n\n          {\n            validationErrMessage = `does not export anything`;\n          }\n        }\n\n        if ( // ES Modules don't have the Object prototype\n        Object.prototype.hasOwnProperty.call(appOpts, \"bootstrap\") && !validLifecycleFn(appOpts.bootstrap)) {\n          validationErrCode = 35;\n\n          {\n            validationErrMessage = `does not export a valid bootstrap function or array of functions`;\n          }\n        }\n\n        if (!validLifecycleFn(appOpts.mount)) {\n          validationErrCode = 36;\n\n          {\n            validationErrMessage = `does not export a mount function or array of functions`;\n          }\n        }\n\n        if (!validLifecycleFn(appOpts.unmount)) {\n          validationErrCode = 37;\n\n          {\n            validationErrMessage = `does not export a unmount function or array of functions`;\n          }\n        }\n\n        const type = objectType(appOpts);\n\n        if (validationErrCode) {\n          let appOptsStr;\n\n          try {\n            appOptsStr = JSON.stringify(appOpts);\n          } catch (_unused) {}\n\n          console.error(formatErrorMessage(validationErrCode, `The loading function for single-spa ${type} '${toName(appOrParcel)}' resolved with the following, which does not have bootstrap, mount, and unmount functions`, type, toName(appOrParcel), appOptsStr), appOpts);\n          handleAppError(validationErrMessage, appOrParcel, SKIP_BECAUSE_BROKEN);\n          return appOrParcel;\n        }\n\n        if (appOpts.devtools && appOpts.devtools.overlays) {\n          appOrParcel.devtools.overlays = assign({}, appOrParcel.devtools.overlays, appOpts.devtools.overlays);\n        }\n\n        appOrParcel.status = NOT_BOOTSTRAPPED;\n        appOrParcel.bootstrap = flattenFnArray(appOpts, \"bootstrap\");\n        appOrParcel.mount = flattenFnArray(appOpts, \"mount\");\n        appOrParcel.unmount = flattenFnArray(appOpts, \"unmount\");\n        appOrParcel.unload = flattenFnArray(appOpts, \"unload\");\n        appOrParcel.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n        delete appOrParcel.loadPromise;\n\n        {\n          addProfileEntry(\"application\", toName(appOrParcel), \"load\", startTime, performance.now(), true);\n        }\n\n        return appOrParcel;\n      });\n    }).catch(err => {\n      delete appOrParcel.loadPromise;\n      let newStatus;\n\n      if (isUserErr) {\n        newStatus = SKIP_BECAUSE_BROKEN;\n      } else {\n        newStatus = LOAD_ERROR;\n        appOrParcel.loadErrorTime = new Date().getTime();\n      }\n\n      handleAppError(err, appOrParcel, newStatus);\n\n      {\n        addProfileEntry(\"application\", toName(appOrParcel), \"load\", startTime, performance.now(), false);\n      }\n\n      return appOrParcel;\n    });\n  });\n}\n\nconst isInBrowser = typeof window !== \"undefined\";\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\n\nconst capturedEventListeners = {\n  hashchange: [],\n  popstate: []\n};\nconst routingEventsListeningTo = [\"hashchange\", \"popstate\"];\nfunction navigateToUrl(obj) {\n  let url;\n\n  if (typeof obj === \"string\") {\n    url = obj;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (obj && obj.currentTarget && obj.currentTarget.href && obj.preventDefault) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(formatErrorMessage(14, `singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`));\n  }\n\n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n\n  if (url.indexOf(\"#\") === 0) {\n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    {\n      window.location.href = url;\n    }\n  } else if (destination.pathname === current.pathname && destination.search === current.search) {\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\nfunction callCapturedEventListeners(eventArguments) {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      capturedEventListeners[eventType].forEach(listener => {\n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\nlet urlRerouteOnly;\n\nfunction urlReroute() {\n  reroute([], arguments);\n}\n\nfunction patchedUpdateState(updateState, methodName) {\n  return function () {\n    const urlBefore = window.location.href;\n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n\n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      // fire an artificial popstate event so that\n      // single-spa applications know about routing that\n      // occurs in a different application\n      window.dispatchEvent(createPopStateEvent(window.history.state, methodName));\n    }\n\n    return result;\n  };\n}\n\nfunction createPopStateEvent(state, originalMethodName) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn't do one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt;\n\n  try {\n    evt = new PopStateEvent(\"popstate\", {\n      state\n    });\n  } catch (err) {\n    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createEvent(\"PopStateEvent\");\n    evt.initPopStateEvent(\"popstate\", false, false, state);\n  }\n\n  evt.singleSpa = true;\n  evt.singleSpaTrigger = originalMethodName;\n  return evt;\n}\n\nlet originalReplaceState = null;\nlet historyApiIsPatched = false; // We patch the history API so single-spa is notified of all calls to pushState/replaceState.\n// We patch addEventListener/removeEventListener so we can capture all popstate/hashchange event listeners,\n// and delay calling them until single-spa has finished mounting/unmounting applications\n\nfunction patchHistoryApi(opts) {\n  if (historyApiIsPatched) {\n    throw Error(formatErrorMessage(43, `single-spa: patchHistoryApi() was called after the history api was already patched.`));\n  } // True by default, as a performance optimization that reduces\n  // the number of extraneous popstate events\n\n\n  urlRerouteOnly = opts && opts.hasOwnProperty(\"urlRerouteOnly\") ? opts.urlRerouteOnly : true;\n  historyApiIsPatched = true;\n  originalReplaceState = window.history.replaceState; // We will trigger an app change for any routing events.\n\n  window.addEventListener(\"hashchange\", urlReroute);\n  window.addEventListener(\"popstate\", urlReroute); // Monkeypatch addEventListener so that we can ensure correct timing\n\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n\n  window.addEventListener = function (eventName, fn) {\n    if (typeof fn === \"function\") {\n      if (routingEventsListeningTo.indexOf(eventName) >= 0 && !find(capturedEventListeners[eventName], listener => listener === fn)) {\n        capturedEventListeners[eventName].push(fn);\n        return;\n      }\n    }\n\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === \"function\") {\n      if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n        capturedEventListeners[eventName] = capturedEventListeners[eventName].filter(fn => fn !== listenerFn);\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n\n  window.history.pushState = patchedUpdateState(window.history.pushState, \"pushState\");\n  window.history.replaceState = patchedUpdateState(originalReplaceState, \"replaceState\");\n} // Detect if single-spa has already been loaded on the page.\n// If so, warn because this can result in lots of problems, including\n// lots of extraneous popstate events and unexpected results for\n// apis like getAppNames().\n\nif (isInBrowser) {\n  if (window.singleSpaNavigate) {\n    console.warn(formatErrorMessage(41, \"single-spa has been loaded twice on the page. This can result in unexpected behavior.\"));\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag's href is.\n     */\n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n\nfunction parseUri(str) {\n  const anchor = document.createElement(\"a\");\n  anchor.href = str;\n  return anchor;\n}\n\nlet hasInitialized = false;\nfunction ensureJQuerySupport(jQuery = window.jQuery) {\n  if (!jQuery) {\n    if (window.$ && window.$.fn && window.$.fn.jquery) {\n      jQuery = window.$;\n    }\n  }\n\n  if (jQuery && !hasInitialized) {\n    const originalJQueryOn = jQuery.fn.on;\n    const originalJQueryOff = jQuery.fn.off;\n\n    jQuery.fn.on = function (eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOn, window.addEventListener, eventString, fn, arguments);\n    };\n\n    jQuery.fn.off = function (eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOff, window.removeEventListener, eventString, fn, arguments);\n    };\n\n    hasInitialized = true;\n  }\n}\n\nfunction captureRoutingEvents(originalJQueryFunction, nativeFunctionToCall, eventString, fn, originalArgs) {\n  if (typeof eventString !== \"string\") {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n\n  const eventNames = eventString.split(/\\s+/);\n  eventNames.forEach(eventName => {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      nativeFunctionToCall(eventName, fn);\n      eventString = eventString.replace(eventName, \"\");\n    }\n  });\n\n  if (eventString.trim() === \"\") {\n    return this;\n  } else {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n}\n\nconst appsToUnload = {};\nfunction toUnloadPromise(appOrParcel) {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[toName(appOrParcel)];\n\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return appOrParcel;\n    }\n\n    if (appOrParcel.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(appOrParcel, unloadInfo);\n      return appOrParcel;\n    }\n\n    if (appOrParcel.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise.then(() => appOrParcel);\n    }\n\n    if (appOrParcel.status !== NOT_MOUNTED && appOrParcel.status !== LOAD_ERROR) {\n      /* The app cannot be unloaded until it is unmounted.\n       */\n      return appOrParcel;\n    }\n\n    let startTime;\n\n    {\n      startTime = performance.now();\n    }\n\n    const unloadPromise = appOrParcel.status === LOAD_ERROR ? Promise.resolve() : reasonableTime(appOrParcel, \"unload\");\n    appOrParcel.status = UNLOADING;\n    return unloadPromise.then(() => {\n      {\n        addProfileEntry(\"application\", toName(appOrParcel), \"unload\", startTime, performance.now(), true);\n      }\n\n      finishUnloadingApp(appOrParcel, unloadInfo);\n      return appOrParcel;\n    }).catch(err => {\n      {\n        addProfileEntry(\"application\", toName(appOrParcel), \"unload\", startTime, performance.now(), false);\n      }\n\n      errorUnloadingApp(appOrParcel, unloadInfo, err);\n      return appOrParcel;\n    });\n  });\n}\n\nfunction finishUnloadingApp(app, unloadInfo) {\n  delete appsToUnload[toName(app)]; // Unloaded apps don't have lifecycles\n\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  app.status = NOT_LOADED;\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[toName(app)]; // Unloaded apps don't have lifecycles\n\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n  unloadInfo.reject(err);\n}\n\nfunction addAppToUnload(app, promiseGetter, resolve, reject) {\n  appsToUnload[toName(app)] = {\n    app,\n    resolve,\n    reject\n  };\n  Object.defineProperty(appsToUnload[toName(app)], \"promise\", {\n    get: promiseGetter\n  });\n}\nfunction getAppUnloadInfo(appName) {\n  return appsToUnload[appName];\n}\n\nconst apps = [];\nfunction getAppChanges() {\n  const appsToUnload = [],\n        appsToUnmount = [],\n        appsToLoad = [],\n        appsToMount = []; // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n\n  const currentTime = new Date().getTime();\n  apps.forEach(app => {\n    const appShouldBeActive = app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n\n    switch (app.status) {\n      case LOAD_ERROR:\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n\n        break;\n\n      case NOT_LOADED:\n      case LOADING_SOURCE_CODE:\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n\n        break;\n\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          appsToMount.push(app);\n        }\n\n        break;\n\n      case MOUNTED:\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n\n        break;\n      // all other statuses are ignored\n    }\n  });\n  return {\n    appsToUnload,\n    appsToUnmount,\n    appsToLoad,\n    appsToMount\n  };\n}\nfunction getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\nfunction getAppNames() {\n  return apps.map(toName);\n} // used in devtools, not (currently) exposed as a single-spa API\n\nfunction getRawAppData() {\n  return [...apps];\n}\nfunction getAppStatus(appName) {\n  const app = find(apps, app => toName(app) === appName);\n  return app ? app.status : null;\n}\nlet startWarningInitialized = false;\nfunction registerApplication(appNameOrConfig, appOrLoadApp, activeWhen, customProps) {\n  const registration = sanitizeArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps);\n\n  if (!isStarted() && !startWarningInitialized) {\n    startWarningInitialized = true;\n    setTimeout(() => {\n      if (!isStarted()) {\n        console.warn(formatErrorMessage(1, `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted.`));\n      }\n    }, 5000);\n  }\n\n  if (getAppNames().indexOf(registration.name) !== -1) throw Error(formatErrorMessage(21, `There is already an app registered with name ${registration.name}`, registration.name));\n  apps.push(assign({\n    loadErrorTime: null,\n    status: NOT_LOADED,\n    parcels: {},\n    devtools: {\n      overlays: {\n        options: {},\n        selectors: []\n      }\n    }\n  }, registration));\n\n  if (isInBrowser) {\n    ensureJQuerySupport();\n    reroute();\n  }\n}\nfunction checkActivityFunctions(location = window.location) {\n  return apps.filter(app => app.activeWhen(location)).map(toName);\n}\nfunction unregisterApplication(appName) {\n  if (apps.filter(app => toName(app) === appName).length === 0) {\n    throw Error(formatErrorMessage(25, `Cannot unregister application '${appName}' because no such application has been registered`, appName));\n  }\n\n  const unloadPromise = isInBrowser ? // See https://github.com/single-spa/single-spa/issues/871 for why waitForUnmount is false\n  unloadApplication(appName, {\n    waitForUnmount: false\n  }) : Promise.resolve();\n  return unloadPromise.then(() => {\n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\nfunction unloadApplication(appName, opts = {\n  waitForUnmount: false\n}) {\n  if (typeof appName !== \"string\") {\n    throw Error(formatErrorMessage(26, `unloadApplication requires a string 'appName'`));\n  }\n\n  const app = find(apps, App => toName(App) === appName);\n\n  if (!app) {\n    throw Error(formatErrorMessage(27, `Could not unload application '${appName}' because no such application has been registered`, appName));\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n    let resultPromise;\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  Promise.resolve().then(() => {\n    // Before unmounting the application, we first must wait for it to finish mounting\n    // Otherwise, the test for issue 871 in unregister-application.spec.js fails because\n    // the application isn't really unmounted.\n    if (find(checkActivityFunctions(), activeApp => activeApp === toName(app))) {\n      return triggerAppChange();\n    }\n  }).then(() => {\n    return toUnmountPromise(app).then(toUnloadPromise).then(() => {\n      resolve();\n      setTimeout(() => {\n        // reroute, but the unload promise is done\n        reroute();\n      });\n    });\n  }).catch(reject);\n}\n\nfunction validateRegisterWithArguments(name, appOrLoadApp, activeWhen, customProps) {\n  if (typeof name !== \"string\" || name.length === 0) throw Error(formatErrorMessage(20, `The 1st argument to registerApplication must be a non-empty string 'appName'`));\n  if (!appOrLoadApp) throw Error(formatErrorMessage(23, \"The 2nd argument to registerApplication must be an application or loading application function\"));\n  if (typeof activeWhen !== \"function\") throw Error(formatErrorMessage(24, \"The 3rd argument to registerApplication must be an activeWhen function\"));\n  if (!validCustomProps(customProps)) throw Error(formatErrorMessage(22, \"The optional 4th argument is a customProps and must be an object\"));\n}\n\nfunction validateRegisterWithConfig(config) {\n  if (Array.isArray(config) || config === null) throw Error(formatErrorMessage(39, \"Configuration object can't be an Array or null!\"));\n  const validKeys = [\"name\", \"app\", \"activeWhen\", \"customProps\"];\n  const invalidKeys = Object.keys(config).reduce((invalidKeys, prop) => validKeys.indexOf(prop) >= 0 ? invalidKeys : invalidKeys.concat(prop), []);\n  if (invalidKeys.length !== 0) throw Error(formatErrorMessage(38, `The configuration object accepts only: ${validKeys.join(\", \")}. Invalid keys: ${invalidKeys.join(\", \")}.`, validKeys.join(\", \"), invalidKeys.join(\", \")));\n  if (typeof config.name !== \"string\" || config.name.length === 0) throw Error(formatErrorMessage(20, \"The config.name on registerApplication must be a non-empty string\"));\n  if (typeof config.app !== \"object\" && typeof config.app !== \"function\") throw Error(formatErrorMessage(20, \"The config.app on registerApplication must be an application or a loading function\"));\n\n  const allowsStringAndFunction = activeWhen => typeof activeWhen === \"string\" || typeof activeWhen === \"function\";\n\n  if (!allowsStringAndFunction(config.activeWhen) && !(Array.isArray(config.activeWhen) && config.activeWhen.every(allowsStringAndFunction))) throw Error(formatErrorMessage(24, \"The config.activeWhen on registerApplication must be a string, function or an array with both\"));\n  if (!validCustomProps(config.customProps)) throw Error(formatErrorMessage(22, \"The optional config.customProps must be an object\"));\n}\n\nfunction validCustomProps(customProps) {\n  return !customProps || typeof customProps === \"function\" || typeof customProps === \"object\" && customProps !== null && !Array.isArray(customProps);\n}\n\nfunction sanitizeArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps) {\n  const usingObjectAPI = typeof appNameOrConfig === \"object\";\n  const registration = {\n    name: null,\n    loadApp: null,\n    activeWhen: null,\n    customProps: null\n  };\n\n  if (usingObjectAPI) {\n    validateRegisterWithConfig(appNameOrConfig);\n    registration.name = appNameOrConfig.name;\n    registration.loadApp = appNameOrConfig.app;\n    registration.activeWhen = appNameOrConfig.activeWhen;\n    registration.customProps = appNameOrConfig.customProps;\n  } else {\n    validateRegisterWithArguments(appNameOrConfig, appOrLoadApp, activeWhen, customProps);\n    registration.name = appNameOrConfig;\n    registration.loadApp = appOrLoadApp;\n    registration.activeWhen = activeWhen;\n    registration.customProps = customProps;\n  }\n\n  registration.loadApp = sanitizeLoadApp(registration.loadApp);\n  registration.customProps = sanitizeCustomProps(registration.customProps);\n  registration.activeWhen = sanitizeActiveWhen(registration.activeWhen);\n  return registration;\n}\n\nfunction sanitizeLoadApp(loadApp) {\n  if (typeof loadApp !== \"function\") {\n    return () => Promise.resolve(loadApp);\n  }\n\n  return loadApp;\n}\n\nfunction sanitizeCustomProps(customProps) {\n  return customProps ? customProps : {};\n}\n\nfunction sanitizeActiveWhen(activeWhen) {\n  let activeWhenArray = Array.isArray(activeWhen) ? activeWhen : [activeWhen];\n  activeWhenArray = activeWhenArray.map(activeWhenOrPath => typeof activeWhenOrPath === \"function\" ? activeWhenOrPath : pathToActiveWhen(activeWhenOrPath));\n  return location => activeWhenArray.some(activeWhen => activeWhen(location));\n}\n\nfunction pathToActiveWhen(path, exactMatch) {\n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n  return location => {\n    // compatible with IE10\n    let origin = location.origin;\n\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n\n    const route = location.href.replace(origin, \"\").replace(location.search, \"\").split(\"?\")[0];\n    return regex.test(route);\n  };\n}\n\nfunction toDynamicPathValidatorRegex(path, exactMatch) {\n  let lastIndex = 0,\n      inDynamic = false,\n      regexStr = \"^\";\n\n  if (path[0] !== \"/\") {\n    path = \"/\" + path;\n  }\n\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === \":\";\n    const endOfDynamic = inDynamic && char === \"/\";\n\n    if (startOfDynamic || endOfDynamic) {\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, \"i\");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = \"[^/]+/?\";\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n    regexStr += inDynamic ? anyCharMaybeTrailingSlashRegex : commonStringSubPath;\n\n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don't match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += \"$\";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? \"\" : \".*\";\n        regexStr = // use charAt instead as we could not use es6 method endsWith\n        regexStr.charAt(regexStr.length - 1) === \"/\" ? `${regexStr}${suffix}$` : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n\n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n  }\n}\n\nlet appChangeUnderway = false,\n    peopleWaitingOnAppChange = [],\n    currentUrl = isInBrowser && window.location.href;\nfunction triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute();\n}\nfunction reroute(pendingPromises = [], eventArguments, silentNavigation = false) {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments\n      });\n    });\n  }\n\n  let startTime, profilerKind;\n\n  {\n    startTime = performance.now();\n\n    if (silentNavigation) {\n      profilerKind = \"silentNavigation\";\n    } else if (eventArguments) {\n      profilerKind = \"browserNavigation\";\n    } else {\n      profilerKind = \"triggerAppChange\";\n    }\n  }\n\n  const {\n    appsToUnload,\n    appsToUnmount,\n    appsToLoad,\n    appsToMount\n  } = getAppChanges();\n  let appsThatChanged,\n      cancelPromises = [],\n      oldUrl = currentUrl,\n      newUrl = currentUrl = window.location.href;\n\n  if (isStarted()) {\n    appChangeUnderway = true;\n    appsThatChanged = appsToUnload.concat(appsToLoad, appsToUnmount, appsToMount);\n    return performAppChanges();\n  } else {\n    appsThatChanged = appsToLoad;\n    return loadApps();\n  }\n\n  function cancelNavigation(val = true) {\n    const promise = typeof (val === null || val === void 0 ? void 0 : val.then) === \"function\" ? val : Promise.resolve(val);\n    cancelPromises.push(promise.catch(err => {\n      console.warn(Error(formatErrorMessage(42, `single-spa: A cancelNavigation promise rejected with the following value: ${err}`)));\n      console.warn(err); // Interpret a Promise rejection to mean that the navigation should not be canceled\n\n      return false;\n    }));\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      const loadPromises = appsToLoad.map(toLoadPromise);\n      let succeeded;\n      return Promise.all(loadPromises).then(callAllEventListeners) // there are no mounted apps, before start() is called, so we always return []\n      .then(() => {\n        {\n          succeeded = true;\n        }\n\n        return [];\n      }).catch(err => {\n        {\n          succeeded = false;\n        }\n\n        callAllEventListeners();\n        throw err;\n      }).finally(() => {\n        {\n          addProfileEntry(\"routing\", \"loadApps\", profilerKind, startTime, performance.now(), succeeded);\n        }\n      });\n    });\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      fireSingleSpaEvent(appsThatChanged.length === 0 ? \"before-no-app-change\" : \"before-app-change\", getCustomEventDetail(true));\n      fireSingleSpaEvent(\"before-routing-event\", getCustomEventDetail(true, {\n        cancelNavigation\n      }));\n      return Promise.all(cancelPromises).then(cancelValues => {\n        const navigationIsCanceled = cancelValues.some(v => v);\n\n        if (navigationIsCanceled) {\n          // Change url back to old url, without triggering the normal single-spa reroute\n          originalReplaceState.call(window.history, history.state, \"\", oldUrl.substring(location.origin.length)); // Single-spa's internal tracking of current url needs to be updated after the url change above\n\n          currentUrl = location.href; // necessary for the reroute function to know that the current reroute is finished\n\n          appChangeUnderway = false;\n\n          {\n            addProfileEntry(\"routing\", \"navigationCanceled\", profilerKind, startTime, performance.now(), true);\n          } // Tell single-spa to reroute again, this time with the url set to the old URL\n\n\n          return reroute(pendingPromises, eventArguments, true);\n        }\n\n        const unloadPromises = appsToUnload.map(toUnloadPromise);\n        const unmountUnloadPromises = appsToUnmount.map(toUnmountPromise).map(unmountPromise => unmountPromise.then(toUnloadPromise));\n        const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n        const unmountAllPromise = Promise.all(allUnmountPromises);\n        let unmountFinishedTime;\n        unmountAllPromise.then(() => {\n          {\n            unmountFinishedTime = performance.now();\n            addProfileEntry(\"routing\", \"unmountAndUnload\", profilerKind, startTime, performance.now(), true);\n          }\n\n          fireSingleSpaEvent(\"before-mount-routing-event\", getCustomEventDetail(true));\n        }, err => {\n          {\n            addProfileEntry(\"routing\", \"unmountAndUnload\", profilerKind, startTime, performance.now(), true);\n          }\n\n          throw err;\n        });\n        /* We load and bootstrap apps while other apps are unmounting, but we\n         * wait to mount the app until all apps are finishing unmounting\n         */\n\n        const loadThenMountPromises = appsToLoad.map(app => {\n          return toLoadPromise(app).then(app => tryToBootstrapAndMount(app, unmountAllPromise));\n        });\n        /* These are the apps that are already bootstrapped and just need\n         * to be mounted. They each wait for all unmounting apps to finish up\n         * before they mount.\n         */\n\n        const mountPromises = appsToMount.filter(appToMount => appsToLoad.indexOf(appToMount) < 0).map(appToMount => {\n          return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n        });\n        return unmountAllPromise.catch(err => {\n          callAllEventListeners();\n          throw err;\n        }).then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it's safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          callAllEventListeners();\n          return Promise.all(loadThenMountPromises.concat(mountPromises)).catch(err => {\n            pendingPromises.forEach(promise => promise.reject(err));\n            throw err;\n          }).then(finishUpAndReturn).then(() => {\n            {\n              addProfileEntry(\"routing\", \"loadAndMount\", profilerKind, unmountFinishedTime, performance.now(), true);\n            }\n          }, err => {\n            {\n              addProfileEntry(\"routing\", \"loadAndMount\", profilerKind, unmountFinishedTime, performance.now(), false);\n            }\n\n            throw err;\n          });\n        });\n      });\n    });\n  }\n\n  function finishUpAndReturn() {\n    const returnValue = getMountedApps();\n    pendingPromises.forEach(promise => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName = appsThatChanged.length === 0 ? \"no-app-change\" : \"app-change\";\n      fireSingleSpaEvent(appChangeEventName, getCustomEventDetail());\n      fireSingleSpaEvent(\"routing-event\", getCustomEventDetail());\n    } catch (err) {\n      /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n\n\n    appChangeUnderway = false;\n\n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      peopleWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n\n\n  function callAllEventListeners() {\n    // During silent navigation (when navigation was canceled and we're going back to the old URL),\n    // we should not fire any popstate / hashchange events\n    if (!silentNavigation) {\n      pendingPromises.forEach(pendingPromise => {\n        callCapturedEventListeners(pendingPromise.eventArguments);\n      });\n      callCapturedEventListeners(eventArguments);\n    }\n  }\n\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [MOUNTED]: [],\n      // for apps that were unmounted\n      [NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [SKIP_BECAUSE_BROKEN]: []\n    };\n\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, MOUNTED);\n      });\n      appsToUnload.forEach(app => {\n        addApp(app, NOT_LOADED);\n      });\n      appsToUnmount.forEach(app => {\n        addApp(app, NOT_MOUNTED);\n      });\n    } else {\n      appsThatChanged.forEach(app => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments === null || eventArguments === void 0 ? void 0 : eventArguments[0],\n        oldUrl,\n        newUrl\n      }\n    };\n\n    if (extraProperties) {\n      assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(app, status) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      newAppStatuses[appName] = status;\n      const statusArr = appsByNewStatus[status] = appsByNewStatus[status] || [];\n      statusArr.push(appName);\n    }\n  }\n\n  function fireSingleSpaEvent(name, eventProperties) {\n    // During silent navigation (caused by navigation cancelation), we should not\n    // fire any single-spa events\n    if (!silentNavigation) {\n      window.dispatchEvent(new customEvent(`single-spa:${name}`, eventProperties));\n    }\n  }\n}\n/**\n * Let's imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn't bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\n\nfunction tryToBootstrapAndMount(app, unmountAllPromise) {\n  if (shouldBeActive(app)) {\n    return toBootstrapPromise(app).then(app => unmountAllPromise.then(() => shouldBeActive(app) ? toMountPromise(app) : app));\n  } else {\n    return unmountAllPromise.then(() => app);\n  }\n}\n\nlet started = false;\nfunction start(opts) {\n  started = true;\n\n  if (isInBrowser) {\n    patchHistoryApi(opts);\n    reroute();\n  }\n}\nfunction isStarted() {\n  return started;\n}\n\nvar devtools = {\n  getRawAppData,\n  reroute,\n  NOT_LOADED,\n  toLoadPromise,\n  toBootstrapPromise,\n  unregisterApplication,\n  getProfilerData\n};\n\nif (isInBrowser && window.__SINGLE_SPA_DEVTOOLS__) {\n  window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools;\n}\n\nexport { BOOTSTRAPPING, LOADING_SOURCE_CODE, LOAD_ERROR, MOUNTED, MOUNTING, NOT_BOOTSTRAPPED, NOT_LOADED, NOT_MOUNTED, SKIP_BECAUSE_BROKEN, UNLOADING, UNMOUNTING, UPDATING, addErrorHandler, checkActivityFunctions, ensureJQuerySupport, getAppNames, getAppStatus, getMountedApps, getProfilerData, mountRootParcel, navigateToUrl, patchHistoryApi, pathToActiveWhen, registerApplication, removeErrorHandler, setBootstrapMaxTime, setMountMaxTime, setUnloadMaxTime, setUnmountMaxTime, start, triggerAppChange, unloadApplication, unregisterApplication };\n//# sourceMappingURL=single-spa.dev.js.map\n"],"names":[],"ignoreList":[],"sourceRoot":""}